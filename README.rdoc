== README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...
malam ini sebenarnya istirahat sudah ngodingnya
badan sudah capek dan agak demam kayanya bakalan sakit lama ini
mana saya bawa komputernya teman lagi
besok insay ALLAH siap

tapi ini pelajaran base rails makin susah saja, nda tau mesti dari mana mesti saya ulang lagi ini bacaannya dulu

hari ini jumat 27 maret 2015 saya belum bisa ngerjain banyak

penawaran yang ada tinggalh penawaran, banyak hal yang baru tiap harinya saya dapat di pemrograman
mudah mudahan di UPRI lebih baik lagi dgn adanya divisi IT nya

divisi IT ini bertugas banyak membenahi semua sistem administrasi UPRI

dan mudah mudahan saja website belajara dari baserails sudah bisa diterapkan langsung ilmunya

target malam ini dilihat sedikit dulu trips dari base rails

rencananya mau tidur jam 12 saja dlu terlalu lelah hari ini


hari ini telah selesai rapat kerja semoga ke depan lebih baik lagi
dan semoga tidak ada lagi kerusuhan di subuh hari pada saat kita salat
adn semoga kursusku di etsy cepat kelar agar tidak lama lama ini uang habis

besok juga saya harus menyusun mata kuliah
besok juga kembali ngoding perbaiki desain depan website
besok juga menyusun praktikum
besok juga saya mau menyiapkan data data lengkap masalah kelurahan
besok juga saya mau print spanduk


hari ini mau melakukan semua agenda yang direncanakan sebelumnya

sekarang tinggal mengerjakan sisa pekerjaan yang ada gogogogog

cuman bisa istirahat malam ini guys
pekerjaaan masih banyak numpuk
mudah mudahan besok bisa diselesaikan
setelah itu baru bisa tenang tenang

start lagi aktifitas hari ini
mau menyusun materi kuliah malam ini

mudah mudahan anak anak mengerti apa yang saya lakukan
saya mesti cari referensi dulu untuk meyakinkan anak anak masalah resource nya

nda ada yang mahal kalu nda ada harga pembandingnya
 besok nda tau apa jadi ke tonasa
 mudah mudahan ada juga kejelasan mengenai ini proyek pengadaan di alazhar
 dan besok pun saya libur kalu dari segi perkuliahan
 mana mata sudah mengantuk ini isi jadwal kuliah
 rencananya mau tidur kalu sudah banyak commit ku
 ya minimal 7 commit lah biar ada aktifitasnya
 
 siapa tau saya bisa mengerjalan kursusku ini besok lebih bagus lagi
 
 hari ini nda bisa pulang cepat ada demo uvri menolak caretaker
 ternyata errorku di validates yaitu present semestinya presence
 
 malam ini cukup sekian dulu aktifitasnya
 besok saja baru nyantai kegiatannya
 
 besok ke unhas dan ke upri
 
 hari ini mau ke upri dan ke unhas
 ada error lagi ini saya dapat di schedule
 semoga bisa selesai ini urusan
 saya mau kerja juga bahan ajar ini
 
 ngantuk sudah malam ini
 
 malam ini vukup istirahatnya
 besok lanjut kursus 
 
 
 bikin website lagi sambil dengar ceramah
 
 besok jalan lg planning 
 semua mesti d planning lagi dari awal
 
 mudah mudahan besok saya ingat input data mahasiswa baru
 dan sekalian saya mau buat daftar nilai mata kuliah yang sudah keluar
 
 awali hari ini dengan basmalah
 
 schedule numpuk cari cari dulu inspirasi
 okey back to nature cari materi kuliah buat hari senin
 
 hari ini sukses buat jurnal album
 tinggal belajar buat website lagi dengan 3taps
 
 sebentar coba dicek lagi
 mungkin sampai jam dua belas sebentar
 
 hari ini mulai pukul 18.00 banyak agenda acara
 nda belajar meki sedeng
 
 mudah mudahan besok nda terlalu padat kegiatan sehingga mudah urusan web
 
 ini lagi readme banyak sekalimi di tulis cuman sekedar commit
 
 tapi besok banyak lagi acara ii
 mau di sahid penyumpahan
 tapi sudah ngantik ini kasihan
 
 mungkin sesuatu yang bisa dibuat hari ini adalah :
 menulis penelitian mobil
 mengajar materi mekatronika
 membuat fitur baru website
 membuat materi menggambar mesin
 
 
 
Please feel free to use a different markup language if you do not plan to run
<tt>rake doc:app</tt>.



Craigslist Scraper Course Page:
1.Explore 3taps API
Introduction:
Welcome! In this course, we’ll learn how to work with an API to collect data and use this as the foundation for building a web app from scratch. This is an essential skill if you want to gain access to data from the most popular websites. For example, you could look at the social data from Twitter, track job listings on LinkedIn, pull headlines from the New York Times, and even get real-time weather updates from Accuweather. For this course, we’ll be working with the popular classified ads site, Craigslist, and build a web app using their apartment listing data.

In this video, we’ll cover the basics of what we’ll be learning and go over the app we’ll be building. But first, let me mention that this course does require having some familiarity with Ruby on Rails (we are building a web app after all). I’m going to assume that this isn’t the first time you’ve built a web app, but if you’re new to working with code or if you find yourself in over your head, I recommend taking a step back and going through one of the beginner level BaseRails courses first.

Ok, so first, I want to provide some context to make sure you’ll be learning the right skills. If you want to gain access to data on the Internet, there are two different approaches. The first approach is to write a computer program that can find and grab useful pieces of information on a webpage. This is essentially the same process as if we were to visit a URL and manually copy/paste the data we wanted into a spreadsheet. The difference is that by using the speed and power of a computer, we can scan many, many pages very quickly. This approach is called “web scraping” or “screen scraping”. This won’t be something we cover in this course, but I recommend learning it at some point because it can be used on almost any website on the Internet.

The second approach to gain access to data is by using an API. This is the skill we’ll be learning here, and it’s useful only for sites that have an API available. Fortunately, more and more popular sites are creating their own APIs for developers to use. In other words, they wanted to make the data available to the public and created an official process for developers to make requests. For example, Amazon created an API to allow access to their trove of product information. In doing so, they’ve made it much easier to build apps around this data, which ultimately drives more traffic to their site. Now these APIs aren’t always free, as we can sometimes be charged a fee (especially for valuable or hard-to-find data). But in general, it’s best to use an API when one exists, and rely on screen scraping only as a backup plan.

In this course, we’re going to use an API to collect data from Craigslist. This is a really interesting case because despite the popularity of their site, Craigslist does not have their own API. Instead, we’ll be using the third-party 3taps API as an alternative. 3taps will serve as a good, real-life example to give us practice on how to read unfamiliar documentation and explore a new dataset.

Using 3taps, we’ll be focusing on Craigslist’s apartment listings that are available for rent in Brooklyn. We’re going to take the data we retrieve, store it in a database, and build a web app around it. By having control over the data ourselves, we’ll be able to build our own user interface and provide custom features that may not be available on Craigslist itself.

A good example of the kind of site you can build with this approach is www.padmapper.com. Padmapper has become a popular alternative to Craigslist for finding apartment rentals. It takes Craigslist apartment listings and overlays them onto a Google Map to create an improved apartment browsing experience. This just goes to show that once you have control over the data yourself, there’s really no limit to how you can present the information to your users.

Let’s now go over the app that we’ll have built by the end of this course. We’ll be creating an apartment rental site for Brooklyn, New York by collecting the most recent posts from Craigslist and building a nice UI around the data we’ve gathered.

First, we’ll collect the data through the 3taps API and store the information in a database. We’ll then display this data on a web app we’ll build in Rails. When users first get to our homepage, they’ll be able to filter their apartment search by different categories such as price, number of bedrooms and bathrooms, square footage, and so on.

Let’s try it out now. We’ll search for 2 bedroom apartments in the Brooklyn neighborhood of Williamsburg. We’ll get taken to a search results page with all the apartments that match the filters we’ve set. Here, we’ll be able to see a preview of what the apartment looks like, as well as some general information about each one. If we click on a post, we can see the images that were uploaded, the details that we’ve gathered, and the description.

Finally, after building the app, we’ll automate the data collection process to run every 10 minutes so that our content will be updated automatically.

Okay, in the next video, we’ll get started by exploring the 3taps API for the first time.


Using the Reference API:
In this video, we’ll get started with the 3taps API, which we’ll be using to collect the apartment listing data we need from Craigslist. I’m going to assume that you already have Rails installed, along with a text editor, command line, and everything else you need to build a web app. If you don’t have all of these installed, I recommend going to one of the beginner-level BaseRails courses and following along with the installation process there.

Ok, let’s start by opening our Google Chrome browser and going to www.3taps.com. After closing the popup that appears, let’s scroll down and click on ‘Register as a Developer’. Fill in the signup form and you’ll be sent an email with a link to activate your account. I already have an account so I’ll skip this step. Once you do that, you’ll be given an API key that you’ll need whenever you request data from 3taps.

Now that we’re all set up, let’s go take a look at the documentation. The 3taps API is actually three different APIs: Search, Polling, and Reference. Whenever we start working with an unfamiliar API, the number one most important thing we can do is read the documentation. Only by reading the documentation and making a bunch of different data requests can we really start to understand the data we have available and how to access it.

Let’s begin with the Reference API. “The 3taps Reference API provides information about the data sources, category groups, categories and locations available within the 3taps system.” So basically, we can use the Reference API to ask for information about the 3taps data set. We’ll need this to look up the specific names and acronyms that they use to classify data into different categories, subcategories, countries, regions, and cities.

I’ve already read this documentation pretty thoroughly and so I’ll cover the highlights with you, but it’s a good exercise to read it over yourself and see if you can make sense of it. Before, I was always tempted to cut corners and just skim it, but I learned that reading documentation well is such an underrated skill. The extra 30 minutes it takes to read the API’s documentation can save anywhere from a couple hours up to a few days of messing around with the API yourself. So be patient and always read the documentation – you should pause the video here and go do it.

No seriously, pause the video. I can wait.

Ok so hopefully you’ve at least skimmed to the bottom. Even if you didn’t understand everything, you’ll have seen that there are basically five different types of data requests we can make to the Reference API. We can ask for a list of Data Sources; we can ask for a list of Category Groups; we can also ask for Categories, Locations, and do Location Lookups.
But in this case, it’s hard to get a good grasp of this – after all, we don’t even know what Categories and Category Groups are! So let’s start playing around with this and make some requests to the Reference API.

Under the section called ‘Data Sources’, it says: “To obtain a list of data sources, make an HTTP GET request to the following URL: http://reference.3taps.com/sources”.

A GET request is just a visit to this URL asking for data. GET requests are really no different from the normal browsing we do on an everyday basis. For example, when we go to www.nytimes.com, we’re asking for data. The data that’s returned to us comes in the form of a webpage with headlines and images.

Let’s make a GET request to 3taps now by copying the URL and pasting it in a different tab. We can see it says “Your query does not include a registered authentication token (auth_token). Please sign up for an authentication token at https://developer.3taps.com/signup”.

So one way in which GET requests differ from normal browsing is that they can accept one or more parameters as inputs. In this case, 3taps won’t give us any data unless we include our authentication token. We can see this is also mentioned back in the documentation as a required parameter.

To add a parameter to our request, we’ll go back to the URL and add a ? followed by the name of the parameter, which is auth_token, followed by an =, and finally the value which we got from 3taps. We can find this after we sign in and go to “Dashboard”.

So we’ll copy this and paste it on top. After we hit ‘Enter’, we’ll now see a list of 3taps data sources on the page. While we’re using 3taps to access Craigslist, there are many more sites that 3taps could help us collect data from. A few of the largest ones are Cars.com, eBay, and the job search site, Indeed.

The list that we see is written in a format called JSON. JSON is a way of organizing data, mainly by using these name-value pairs. In this case, each of the data sources we see has both a code and a name. We’ll need the code later on when we request data from 3taps, so let’s go to ‘File→Save Page As…’ and save this page to our desktop as sources.json. This way, in the future, we can pull up this page as a reference without having to submit another request to 3taps.

Great, let’s jump to the next section of the documentation, for Category Groups. Here, we’ll need the same auth_token parameter, but we’ll be making our GET request to a different URL. Let’s copy this, go back to our other tab, and replace the portion of the URL before the question mark.

This time, we get a different list of the 3taps Category Groups. All the data they have is organized into one of these groups. The one we’re interested in is “RRRR”, “Real Estate”. Like last time, we’ll save this to our desktop.

Let’s do the same thing for the third section of the documentation, Categories. This one also requires only the auth_token parameter, so we’ll just copy this URL and paste it in like before.

The list we see this time is much longer. From the structure of each section, we can tell that Categories are really a subdivision of the Category Groups we saw previously. For example, the Category Group “Animals” is further divided into “Pets”, “Supplies”, and “Other”. If we scroll down to “Real Estate”, we’ll see that we have “Commercial Real Estate”, “Housing for Rent”, “Housing for Sale”, and so on. The one we’re interested in is “Housing for Rent”. Let’s save this to our desktop.

Let’s move on to the fourth section of the Reference API, Locations. Locations are a little different from what we’ve seen so far. In addition to the auth_token, we also need to provide a second parameter, level. This level can be ‘country’, ‘state’, ‘metro’, basically how specific you want it to be. We’ll first copy this URL and paste it in like before. Then at the end, we’ll add &level=country and hit Enter.

We now have a list of all the countries that 3taps collects data for. Each country has latitude and longitude ranges, a code, a full name, and a short name. Let’s find the United States – its code is “USA”.

Great. Now going back to the documentation, if we wanted to get a list of all the US states, we could go to our URL and replace the word country with state. Let’s try it out. If we hit Enter, we’ll see not only US States like Alabama and Alaska, but also Canadian States like Alberta and Australian States like Australian Capital Territory. We need to add a filter to limit our list to US States only.

In the documentation, in addition to the two required parameters, we also have the option to use these optional parameters below. In this case, we’ll leave the level we have now, but we’ll add the optional country parameter. It says “the parameter’s value must be a valid 3taps country code”, so we’ll go back to our URL and add an &country=USA, which was the country code we saw earlier in our list of countries. Now our list is correct – we have a list of all 50 states plus the District of Columbia.

Since we’re looking for apartment listing data in Brooklyn, NY, the state code is “USA-NY”. And to get Brooklyn, let’s go to the URL and replace level=state with level=city, and change country=USA to state=USA-NY and hit Enter. If we scroll down, the code for Brooklyn is “USA-NYM-BRL”. We’ll need this code later on, so let’s save this to our desktop as well.

Of course, there’s a lot more you can do with all the different combinations of countries, states, metros, and cities, so I encourage you to explore around and get a feel for this yourself. A good exercise is to see if you can find the city or metro of where you live.

We’ll skip over the fifth and final section of the Reference API because we won’t need it for our project. This last section is designed for reverse location lookups, when we have a 3taps location code and need to look up its level, latitude, longitude, and other details.

Now that we’ve taken a close look at the data available in 3taps, including the various sources, categories, and locations, we’re ready for the next section, where we’ll move on from the Reference API and turn our attention to the Polling API, which we’ll use to start collecting the apartment listing data we need.

Retrieve Posting Data:
Get an anchor value through an Anchor API Call
Visit convert-unix-time.com and find a timestamp (e.g. one for the current hour). Then use this to create a data request: http://polling.3taps.com/anchor?auth_token={API_KEY}&timestamp={TIMESTAMP}.


Submit a data request using a Poll API Call
Visit http://polling.3taps.com/poll?auth_token={API_KEY}&anchor={ANCHOR}.


Install the JSON Formatter Google Chrome extension
In the Chrome browser, click the button on the upper-right, go to “More tools”, and select “Extensions”. Scroll to the bottom and click on “Get more extensions”. In the search bar, type “JSON Formatter” and hit Enter. Under ‘Extensions’, click the button to download and select ‘Add’ to give it the right permissions.



Last time, we took a look at the 3taps Reference API to learn about the data they had available. We learned that 3taps collects data from many sites beyond just Craigslist, such as Cars.com, eBay, and Indeed. We also saw that 3taps uses Category Groups, Categories, and Locations to organize the data it retrieves. In this video, we’ll start using the Polling API to start gathering data for ourselves.

When we were first introduced to the 3taps documentation last time, we saw that there were three different APIs available: Search, Polling, and Reference. We’ve looked at the Reference API already, so let’s take a look at the two others, starting with the Search API.

“The 3taps Search API is responsible for searching against the database of postings. For example, it can be used to find all postings from a particular data source, category and location, or to find postings with a given annotation value.”

You can read over the rest of this if you like, but the Search API is optimized for searching quickly. It’s best for situations where you need to search for content with specific keywords. However, we’re not so interested in search. We just want to retrieve the most recent apartment listings regardless of what keywords they contain. For that, we’ll need to look to the Polling API.

‘The 3taps Polling API makes it possible for external systems to “poll” the Data Commons server to obtain a list of new and updated postings as they come in.’

This is exactly what we need. We want to check with 3taps periodically and gather all the new apartment listings that have come in since the last time. Like last time with the Reference API, I recommend that you take some time to read this over, as it’s more complicated than last time. When you’re ready, we’ll go over the highlights together.

Ok, first let’s understand the way that 3taps processes its incoming data. If each of these rectangles is a Craigslist post, with the older ones on the left, then 3taps is receiving a constant stream of new posts from the right. That means if we gather all the latest posts at one point in time, then when we check 10 minutes later, there will probably be new posts, these green rectangles, that have come in since then. So for us, these three posts are the new ones we should now retrieve.

But newness is relative – it depends on when we checked last. 3taps uses something called an anchor to give us only the new posts that we haven’t seen yet. We’ll see that this anchor is a required parameter in many of the requests we’ll make.

One final note: if there are too many new posts, 3taps will give them to us one page at a time. So in these situations, we’ll have to make more than one request to be able to get all of them.
With that context out of the way, let’s move onto the API itself. There are two different types of requests we can make. The first is the “Anchor” API call. An API call is just the same as the GET requests we were making in the last video. Since we haven’t made any data requests yet, we don’t have an initial anchor to use. That’s what this Anchor API is for. Once we’ve made our first data request, we’ll always get back an updated anchor to keep track of the last post we’ve received.

To use the Anchor API, we need two required parameters. The first is our auth_token, which we have from last time. The second is timestamp, which is used to give us an anchor value from that time. It says the timestamp needs to be “the desired date and time, as an integer number of seconds since the 1st of January 1970 (”unix time"), in UTC".

Let’s first understand Unix time. Unix time is a way to display date and time. Rather than use Month/Day/Year or Day/Month/Year, Unix time is just the number of seconds since January 1st, 1970. And UTC is used as a universal time zone. It’s an abbreviation for Coordinated Universal Time, but it’s in French, which is why the letters are out of order.

All in all, we need to provide the Unix time corresponding to the date and time we want, and we’ll be given an anchor value in return. I like to use one of the many tools online to help with converting regular time into Unix time. If we open a new tab and search ‘convert Unix time’, we can click on any of these links. On the convert-unix-time.com site, we can enter any date and time and it will convert it for us. Instead, we’ll just be copying over the timestamp shown for the current hour.

But first, let’s start building our API request by going back to the documentation and copying the Anchor URL they provide. We’ll open a new tab and paste that in. At the end, we’ll add a question mark followed by the name of our first parameter, auth_token, and then an =. We now need to put in our 3taps API key. If you didn’t write it down anywhere, you can always go back and click the ‘sign in’ link to see it. Let’s copy this and paste it to the end of our URL.

Now to add our second parameter, we’ll add an & and the name of the parameter, timestamp, followed by an =. We’ll copy the timestamp we saw earlier, and paste it in. After we hit Enter, we’ll see that we got an anchor we can use. We’ll need this anchor in a moment.

Let’s go back to the documentation. The second type of request we can make is the “Poll” API call – this is what we’ll use to collect our Craigslist posts. We’ll start off by putting in the required auth_token parameter along with the optional anchor we just received. Let’s first copy the URL and paste it into another tab. We’ll now add a ? followed by auth_token= and then copy over our API key. For our second parameter we’ll add an & followed by anchor= and we’ll grab our anchor from our previous request. Let’s hit Enter.
You should see a massive amount of text – this is all the data that 3taps has collected from its many sources in the past hour. The data is still in JSON format, but because it isn’t formatted nicely like before, it’s pretty tough to read. To solve this problem, we’ll download a Google Chrome extension called JSON Formatter.

In our Chrome browser, we’ll click this button on the right, go to “More tools”, and select “Extensions”. Scroll to the bottom and click on “Get more extensions”. In the search bar, type “JSON Formatter” and hit Enter. Under ‘Extensions’, click the button to download and select ‘Add’ to give it the right permissions.

Now if we go back to our data request and refresh the page, the JSON should be automatically displayed in a structured format and much easier to read. We can even click on the small gray arrows to collapse the sections we don’t need to see. Note that the data you see will probably be different from mine, as 3taps is receiving new data all the time. But the overall structure should be the same.

Each post contains a ton of information. For example, it has an ID, a source (in this case, cars.com), a category which we saw earlier in the Reference API, and the external URL which we can click on to see the actual listing itself.
We also get all this other data, like the post’s heading, timestamp, a bunch of annotations, and location information. This is the structure that 3taps uses for all the data it collects, whether they’re used car listings, job posts, or items for sale. But we’re only interested in seeing apartment rental listings from Craigslist, so we need to filter this to show only the posts we want. And that’s what we’ll be working on next time.

So to sum up, in this video we made our first actual data request. We learned how 3taps uses its system of anchor values to keep track of whether data is old or new, and we made an API call to get an initial anchor to use. We then used that anchor in a second request to get back data, which was formatted nicely for us from the JSON Formatter Chrome extension we installed. All of this practice with making API calls will be put to good use next time, as we add optional parameters to build out our request further.

Refine Our API Request:
Add a filter for Craigslist posts only
Add &source=CRAIG to the end of the URL. The complete URL should look like this: http://polling.3taps.com/poll?auth_token={API_KEY}&anchor={ANCHOR}&source=CRAIG@


Filter for apartments available for rent
Add &category_group=RRRR&category=RHFR to the URL.


Filter for postings in Brooklyn, NY only
Add &location.city=USA-NYM-BRL to the URL.


Choose which additional fields should be returned
Add &retvals=location,external_url,heading,body,timestamp,price,images,annotations to the end of the URL.
In the last video, we received our first set of 3taps posting data. We got an initial anchor, which 3taps will use to remember which posts we have or haven’t seen yet.
As a refresher, here’s the API request we made last time. Note that your data may have changed, as it’s being updated constantly. If we collapse the postings section by clicking on the small gray arrow, we’ll see that there are 1,000 items, which is the maximum that 3taps will return to us. Most of these aren’t what we’re looking for though, so let’s add a few more parameters to our API request to refine the results we receive.

From the documentation, we can scroll down to the Poll API Call section and see that there are many optional parameters we can include. All but one of these are used for filtering the content that’s returned to us, which is what we’ll do now.

We’ll start by adding a filter for posts from Craigslist only. We’ll go back to our API call and add a source parameter. To check the code for Craigslist, let’s open the sources.json file on our desktop that we saved from the Reference API. The 3taps code for Craigslist is “CRAIG”, so let’s type that in and hit Enter.

Great – it seems like our results are now filtered to include Craigslist posts only. Let’s use the same approach and add a couple more filters. We’ll start by adding a category_group and category filter. Checking our category_groups.json reference file, we can see that ‘Real Estate’ has a code of ‘RRRR’. And opening our categories.json file, we’ll find ‘Housing for Rent’ listed under the code ‘RHFR’. Let’s add this to our API call: &category_group=RRRR&category=RHFR.

Okay, now we’re only looking at Craigslist apartment listings. If we take a look at this information, we should see that it matches exactly with that in the external URL. There’s even a lot of well-organized listing information contained in the annotations, like the number of bathrooms, whether cats are allowed, square footage, and so on.

Let’s add another parameter to filter by location as well. We can drill down and be as specific as we like here, setting the country, state, metro, even down to the zipcode. But for me, I’m going to add a city filter to limit my results to Brooklyn, NY. We already made a call to the Reference API previously, so I can open the locations.json file I have saved on my desktop and find that the 3taps code for Brooklyn is ‘USA-NYM-BRL’. Let’s add that to our URL, &location.city=USA-NYM-BRL, and hit Enter.

Now each one of the posting results will be in the city of Brooklyn. If we collapse the postings section, we’ll see that we have far fewer listings now. This makes sense, as our filters are now quite specific about what we’re looking for.

While there is a lot of data here, if we look carefully we’ll see that there are still some key pieces that aren’t being shown. For example, where is the body text of the post? Or the listing price?

We’ll be able to set which data fields we want to receive by using the final parameter called retvals, which is short for ‘return values’. The documentation says that retvals is:

“A string listing the fields which should be returned back to the caller. The various fields should be separated by commas. At present, the following fields can be included in this parameter.”

So the list below is the full range of posting fields that we can ask for. We can see the body and price fields we were looking for earlier. To use this, we’ll pick and choose the fields we want, and include them in our API request with commas in between. If we omit the retvals parameter, then 3taps will give us only these lower 8 fields by default. And if we need an explanation of what each field is, we can scroll down to see a description of each one at the bottom.

Let’s try this out. In our API request’s URL (which is getting pretty long now), we’ll type &retvals= and then we’ll pick a few fields to include. I’m going to omit fields like source, category, and category_group because those should be the same for all our posts. I’ll write location,external_url,heading,body,timestamp,price,images,annotations. Let’s hit Enter.

You can see that we got most of the same fields as before, but we now also have fields like body and price that we were missing earlier. The images field also gives us a list of URLs where we can find each of the images from this Craigslist post. Overall, the dataset that we see here is what we’ll want to build our web app around.

So in this video, we learned to use a variety of filters and other optional parameters to refine our API request. Now that we’ve had a chance to play around with the different options, our next step is to figure out how to make this same API call not through a URL, but through a script that we write ourselves in Ruby. That’s what we’ll be working on next time.


2.Import Data Into Our App
Convert Our Request to a Script:
In the last video, we refined our API request to include the specific source, categories, return values, and other data options we wanted. This time, we’ll make the same request, but through a Ruby script we’ll be writing, rather than through our browser. This is an important step because without a script, we won’t have a way to automate our request and integrate it into a web app later on.

Let’s start by opening a new file in Sublime Text. I’ll save this in my root directory (my “alexyang” folder) and call it craigslist_scraper.rb.

We’ll write our script in three chunks and I’ll explain as we go along. Here’s the first chunk:

craigslist_scraper.rb
require 'open-uri'

# Set API token and URL
auth_token = {AUTH_TOKEN}
polling_url = "http://polling.3taps.com/poll"
In this first section, we’re using the require statement at the top to give us access to the functionality of the ‘open-uri’ Ruby gem, which allows us to open URLs from within our script. Whereas in Rails, we would typically add gems to our Gemfile and install them by running bundle install, the process is slightly different when we’re working with a Ruby script. In this case, we just declare the gems we need at the top and install them manually, if necessary. The ‘open-uri’ gem comes installed by default, so we should be all set.

Below the require statement, we’re creating two variables, auth_token and polling_url. Pretty straightforward.

Okay, let’s write the second chunk of our script:

craigslist_scraper.rb
…
# Specify request parameters
params = {
  auth_token: auth_token,
  anchor: {ANCHOR}
}
If you don’t have the anchor we used from last time, just make another request to the anchor API to get a new one. In this section, we’re setting a couple of the basic parameters we want to use in our data request. It’s better not to spend time plugging in all of our parameters right away because we want to make sure that a basic request works first. In general, the more incrementally we can code, the easier it will be to find and fix errors that come up.

Here, our auth_token parameter is equal to the value of the auth_token variable we set above. And our anchor parameter is just hard-coded to what we used last time.

Let’s write the third chunk of our script:

craigslist_scraper.rb
…
# Prepare API request
uri = URI.parse(polling_url)
uri.query = URI.encode_www_form(params)

# Submit request
result = open(uri).read

# Display results to screen
puts result
This last chunk is a little more complicated, but let’s walk through it line-by-line. In these first couple lines, we’re preparing our URL request by starting with our base URL, which is the variable polling_url, and then adding on each of our parameters from the params variable above. To get into specifics, we need the parse method to take the string we have in our polling_url variable and convert it into a URI object, which we need in a data request. It sounds very technical but we’re basically telling our computer that this string here is actually a URL.

And the encode_www_form method takes the array of parameters we have above and converts it into the format with ampersands and equals signs. Together, these two lines are doing the equivalent of typing in the long URL in our browser.

We can think of this next line as essentially hitting Enter. It’s submitting our request (which is contained in the uri variable) and storing all the data that we get from 3taps in a variable named result.

Finally, we’re using the puts function, which stands for “put string”, to display all the information onto our screen.

It’s okay if you don’t understand all the individual details just yet. But it’s important to see the big picture, especially how each step here compares to the process of making this same request through our browser.

Let’s save and open up our command line to run this script. Since I saved the script in my root directory, ‘alexyang’, I can just run my script from here. If you saved your file somewhere else, you may need to cd (or change directory) into the folder where you saved it.

Let’s type ruby craigslist_scraper.rb and hit Enter.

Command Line
$ ruby craigslist_scraper.rb
It’s kind of hard to tell, but this is actually the same data we would get in our browser. It’s just very difficult to read because it isn’t formatted very well. The problem is that our script doesn’t realize that this data is all in JSON format. It thinks this is regular text and so it hasn’t applied any formatting whatsoever.

We can fix that by making a couple changes to our script. First, around our open(uri).read, we’ll wrap it with JSON.parse( and close our parentheses at the end. Then instead of puts result, we’ll type puts JSON.pretty_generate result.

craigslist_scraper.rb
…
# Submit request
result = JSON.parse(open(uri).read)

# Display results to screen
puts JSON.pretty_generate result
The JSON.parse is telling our script to interpret the 3taps data not as regular text, but as JSON. And the pretty_generate method formats that JSON to display nicely onto our screen.

Now to use these methods, we need to use the ‘json’ gem, which like ‘open-uri’ is also installed by default. So at the top, we’ll write require 'json'.

craigslist_scraper.rb
require 'open-uri'
require 'json'
…
Let’s save and run this again.

Command Line
$ ruby craigslist_scraper.rb
This time, the data should be much easier to read.

To finish off our script, the last thing we’ll do is add in all the other parameters we used from last time. In our params variable, let’s add a comma after the anchor parameter, and write a few more:

craigslist_scraper.rb
…
# Specify parameters
params = {
  auth_token: auth_token,
  anchor: {ANCHOR},
  source: "CRAIG",
  category_group: "RRRR",
  category: "RHFR",
  'location.city' => "USA-NYM-BRL",
  retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
}
…
This should all be pretty straightforward, except for the line starting with location.city. You’ll see that we couldn’t use the standard ‘name: value’ syntax here. Instead, we had to place the name in quotes and use a hashrocket instead (that’s what this => is called). In most cases, we’ll be fine using the ‘name: value’ syntax, but there are special cases like here when we have a period in the middle, where we need to fall back on the hashrocket syntax instead. They do exactly the same thing, but the ‘name: value’ syntax is just a shortcut that works 90% of the time.

Let’s save and run this script again.

Command Line
$ ruby craigslist_scraper.rb
Now we’ll see that all our results are from Craigslist, limited to posts related to housing for rent, and all the other filters that we set. We just took a really important step. The script that we wrote is going to serve as the foundation of database we’ll be using for our web app. In the next video, we’ll switch gears and begin building our web app. The plan is to get both pieces ready, so we’ll be able to integrate them together to finally have an app that can automatically pull in data from Craigslist.


Create a Rake Task:
Create a new Rails app
Command Line
$ rails new craigslist_scraper

Generate a Post scaffold
Command Line
$ rails generate scaffold Post heading body:text price:decimal neighborhood external_url timestamp
$ rake db:migrate
Don’t forget to restart your Rails server!


Generate two new rake tasks: scrape and destroy_all_posts
Command Line
$ rails generate task scraper scrape destroy_all_posts

Populate the scrape task with our code from last time
lib/tasks/scraper.rake
namespace :scraper do
  desc "Fetch Craigslist posts from 3taps"
  task scrape: :environment do
    require 'open-uri'
    require 'json'

    # Set API token and URL
    auth_token = "36ba890f43a7cfa7e5a68e23c6ed435d"
    polling_url = "http://polling.3taps.com/poll"

    # Specify request parameters
    params = {
      auth_token: auth_token,
      anchor: 1503713374,
      source: "CRAIG",
      category_group: "RRRR",
      category: "RHFR",
      'location.city' => "USA-NYM-BRL",
      retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
    }

    # Prepare API request
    uri = URI.parse(polling_url)
    uri.query = URI.encode_www_form(params)

    # Submit request
    result = JSON.parse(open(uri).read)

    # Display results to screen
    puts JSON.pretty_generate result
  end
  …

Run the scrape task in our command line
Command Line
$ rake scraper:scrape

Up to this point, we’ve managed to access Craigslist posts by making data requests to the 3taps API both through our browser and through the Ruby script we wrote. Now we’re going to switch gears and start building our web app.

For this portion of the course, I’ll assume that you’re already familiar with the fundamentals of building a Rails app, so I’m going to skip over basic Rails concepts like Gemfiles and launching the Rails server. That’ll allow us more time to focus on the more advanced topics that aren’t covered in the beginner-level BaseRails courses.

Let’s get started by creating a new Rails app from our command line. From my root directory, ‘alexyang’, I’ll type rails new craigslist_scraper and hit Enter.

Command Line
$ rails new craigslist_scraper
When this finishes, let’s type cd craigslist_scraper to change into our ‘craigslist_scraper’ directory, and then the subl . shortcut to open our app in Sublime Text. If you don’t have this shortcut set up, just open the file manually through the Sublime Text app.

Command Line
$ cd craigslist_scraper
$ subl .
With our code files open, let’s also go back to our command line, and open a second tab, navigate to our app’s folder, and launch our Rails server.

Command Line
$ rails s
You should be able to see that your app is running by opening the browser and going to localhost:3000.

Let’s begin by creating a structure for the main resource on our site, the Craigslist posts that we’re pulling from 3taps. For simplicity, we’ll use a scaffold and type rails generate scaffold Post, followed by each of the fields we want and their corresponding data types. Typically, we’d write heading:string body:text... but here’s a shortcut: we can leave off the :string and our app will still assume that the field is a string by default. So let’s delete this and write heading body:text price:decimal neighborhood external_url timestamp and hit Enter.

Command Line
$ rails generate scaffold Post heading body:text price:decimal neighborhood external_url timestamp
We’ll now run rake db:migrate to create our Post database and then restart our Rails server.

Command Line
$ rake db:migrate
Command Line
$ rails s
We can see our new index page by going to our browser and visiting localhost:3000/posts.

There’s no data here yet. Typically, we’d populate our database of Posts by manually entering them through our app’s New Post form, but let’s see if we can make a couple changes to the script we wrote last time and populate our database with real Craigslist data instead.

Before we do this, let me introduce the concept of a rake task. We can think of a rake task as a script that we can run from outside our app. For example, rake db:migrate and rake routes are two popular rake tasks that help us make database changes and view the available URLs for our app. We can see a list of all the rake tasks we can run by typing rake db -T -A.

Command Line
$ rake db -T -A
In the list that appears, the left column has the name of the rake task while the right side has a description, if it’s available.

In addition to these standard tasks, we can create our own custom rake task as well. And that’s exactly what we’re going to do – we’re going to convert the Ruby script we wrote into a custom rake task. Creating new rake tasks is much like generating a new controller. We’ll write rails generate task, and then come up with a name for our new group of tasks as well as each individual task itself. We’ll assign our tasks to a group called scraper, create two tasks, scrape and destroy_all_posts, and then hit Enter.

Command Line
$ rails generate task scraper scrape destroy_all_posts
A new file was created for us, so let’s go back to Sublime Text and go to lib/tasks to check it out.

This scraper.rake file can hold the code for multiple rake tasks, all grouped inside the namespace called scraper. Right now, it’s set up for two tasks: scrape, where we’ll be copying over our script from last time, and destroy_all_posts, which we’ll write in a later video to quickly reset our database of posts.

Let’s start by writing a description for our scrape task. We’ll write ‘Fetch Craigslist posts from 3taps’. Now we need to write the code for the task. Let’s open up our craigslist_scraper.rb file from last time which we’ll be using as a base, copy all the code, and paste it in between the do and the end.

lib/tasks/scraper.rake
namespace :scraper do
  desc "Fetch Craigslist posts from 3taps"
  task scrape: :environment do
    require 'open-uri'
    require 'json'

    # Set API token and URL
    auth_token = "36ba890f43a7cfa7e5a68e23c6ed435d"
    polling_url = "http://polling.3taps.com/poll"

    # Specify request parameters
    params = {
      auth_token: auth_token,
      anchor: 1503713374,
      source: "CRAIG",
      category_group: "RRRR",
      category: "RHFR",
      'location.city' => "USA-NYM-BRL",
      retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
    }

    # Prepare API request
    uri = URI.parse(polling_url)
    uri.query = URI.encode_www_form(params)

    # Submit request
    result = JSON.parse(open(uri).read)

    # Display results to screen
    puts JSON.pretty_generate result
  end
  …
Since the code is unchanged, we should be able to run it and see the same output from last time. So let’s save and go back to our command line. First, let’s type rake db -T -A to see our list of rake tasks again.

Command Line
$ rake db -T -A
If we look carefully, we’ll see the two new tasks we just added. To run our scrape task, we’ll just use rake scraper:scrape and hit Enter.

Command Line
$ rake scraper:scrape
Good, looks like it’s working. In the next video, instead of displaying the data to the screen, we’ll store it in our currently-empty database of Posts.


Save Posts to Database:
In the last video, we created our new Rails app and wrote a custom rake task to run our script. In this video, we’ll store the data we’ve scraped in our Posts database.

We’ll first need to create a row for each posting and pick out the heading, body, and other information here to fill in the row’s columns.

We first need to figure out the right syntax to use to grab a single field like the heading. It helps to view the 3taps data in our browser, so I’ve pulled up the API call from last time. Unlike in our command line, here we can see the full structure of the data. When this data is loaded up in Ruby, it’s stored in something called a hash. Remember that JSON is really just a kind of format to display data, but when Ruby sees JSON, it interprets it into a different format known as hash. So really, a hash is just the Ruby version of JSON data – you can think of them as essentially the same thing. You’ll be able to recognize hashes by their curly braces on the outside and their ‘name:value’ format on the inside.

This hash is really just three ‘name:value’ pairs. We have "success":true, "anchor":1503714374, and postings with all this information. That’s right – all the data we want is contained in the value corresponding to the postings name. We can see that by collapsing the postings section. See? Just like any other ‘name:value’ pair.

Instead of a single value like true or our anchor value, the third ‘name:value’ pair contains an array of 1,000 postings. We can tell it’s an array by the square brackets on the outside. (Remember, curly braces:hash :: square brackets:array.)

We’ll expand this back and instead collapse an individual posting to see that each posting is a hash as well. This means that postings is an array of hashes, itself contained inside a hash. A bit confusing, but it’s important to understand the structure of the data since we’ll need to work with it a lot and this will help us figure out what syntax to use.

Let’s open our rake task in Sublime Text under lib/tasks/scraper.rake. After the puts JSON.pretty_generate result, let’s add ["postings"].first.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts JSON.pretty_generate result["postings"].first
  end
  …
result["postings"] should give us the array of 1,000 postings, so result["postings"].first should give us the first of those postings. Let’s save and run our rake task again.

Command Line
$ rake scraper:scrape
Great – looks like we got exactly one posting back, as we expected. Let’s try grabbing the heading of this post. Since this a hash, we can get this value by adding a ["heading"] at the end.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts JSON.pretty_generate result["postings"].first["heading"]
  end
  …
So result["postings"].first gives us the first posting and the ["heading"] gives us the heading data for that post. Let’s save and try running this.

Command Line
$ rake scraper:scrape
This time, we should get an error that says “only generation of JSON objects or arrays allowed”. The reason why we’re seeing this error is because we’re still using pretty_generate to display our result. That was fine before, when our result was in JSON, or hash, format. But now that we’re displaying the heading only, our result should be a string and we won’t need pretty_generate anymore. A simple puts should be enough, so let’s delete this, save, and try it again.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["heading"]
  end
  …
Command Line
$ rake scraper:scrape
Perfect, looks like we got the heading we wanted. We’ll be able to use this same syntax to grab any of the other data for this post. For example, we can replace heading with body, save, and run it again.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["body"]
  end
  …
Command Line
$ rake scraper:scrape
It’s a little different for location though, because location is a hash as well. Scrolling up, we’ll see that location has a few different fields, but not every post will have these fields available. For example, the locality (which is what 3taps calls a neighborhood) is missing for this specific post. So let’s go back to our code and replace body with location to get the location hash. And then we’ll add a ["locality"].

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["location"]["locality"]
  end
  …
Let’s save and run our task again.

Command Line
$ rake scraper:scrape
I got a blank space because this first post doesn’t have a locality, so I’ll replace first with second just to show you that it works.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].second["location"]["locality"]
  end
  …
I’ll save and run this again.

Command Line
$ rake scraper:scrape
Good – there it is. Now that we know how to grab individual posting data, we can use this knowledge to populate our database of posts. Let’s go back to our text editor, comment out our puts code and write the following:

lib/tasks/scraper.rake
    …
    # Display results to screen
    # puts result["postings"].second["location"]["locality"]

    # Store results in database
    result["postings"].each do |posting|

      # Create new Post
      @post = Post.new
      @post.heading = posting["heading"]
      @post.body = posting["body"]
      @post.price = posting["price"]
      @post.neighborhood = posting["location"]["locality"]
      @post.external_url = posting["external_url"]
      @post.timestamp = posting["timestamp"]

      # Save Post
      @post.save
    end

  end
  …
Here, we’ve written a loop that takes each of the 1,000 or however many postings 3taps gives us, and creates a new Post object to put in our database. That’s stored in the @post variable and one-by-one, we’re filling in the columns for our database.

For example, this line takes the heading field from Craigslist’s data and uses it to fill in the heading column for our database. Similarly, this line takes Craigslist’s locality field that’s stored in the location hash and uses it to fill in the neighborhood column for our database. Finally, we save this @post variable so it gets entered into our database.

Let’s save and try this out.

Command Line
$ rake scraper:scrape
We don’t see any output on the screen this time, but that’s okay because we haven’t used puts to display anything. Instead, we can see if this worked by refreshing our localhost page.

Wow, it’s pretty ugly, but there we go – we’ve got a thousand new posts! Most of the columns seem to be filled in correctly, but scrolling to the right, we’ll see that there are some posts that have blank neighborhoods. That’s fine – we know that not all Craigslist posts have this neighborhood information available.

We’ve just populated our database with 1,000 live Craigslist posts. In the next video, we’ll work with the data we have here to improve the UI of our app.


3.Improve Display of Data
Clean Up Data Formats:
Add the bootstrap-sass gem
Gemfile
...
gem 'bootstrap-sass', '~> 3.3.1'
gem 'autoprefixer-rails'
Command Line
$ bundle install
Don’t forget to restart your Rails server!


Set up the bootstrap-sass gem
app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";
app/assets/javascripts/application.js
…
//= require jquery
//= require bootstrap-sprockets
//= require jquery_ujs
//= require turbolinks
//= require_tree .

Clear the contents of scaffolds.css.scss to prevent CSS conflicts
app/assets/stylesheets/scaffolds.css.scss


Add Bootstrap table styling and a container class
app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    …

Reorganize and format the display of content
app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    <thead>
      <tr>
        <th>Heading</th>
        <th>Price</th>
        <th>Neighborhood</th>
        <th>Last Updated</th>
      </tr>
    </thead>

    <tbody>
      <% @posts.each do |post| %>
        <tr>
          <td><%= link_to post.heading, post %></td>
          <td><%= number_to_currency(post.price, precision: 0) %></td>
          <td><%= post.neighborhood %></td>
          <td><%= "#{time_ago_in_words(Time.at(post.timestamp.to_i))} ago" %></td>
        </tr>
      <% end %>
    </tbody>
  </table>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>

We now have a basic web app with some Craigslist posting data that we’ve loaded from 3taps. In this video, we’re going to clean up our index page with some basic styling to improve the presentation of this data.

Let’s start by using Bootstrap on this table on our index page. We’ll be using the bootstrap-sass gem, so let’s open up our browser and go to the gem page. Let’s follow the instructions and copy the line here. Then, we’ll open up our Gemfile, paste it in at the bottom, and clean this up a bit. The ‘sass-rails’ gem was included in our Gemfile by default, so we can skip this step. And then we’ll add the ‘autoprefixer-rails’ gem as they recommend.

Gemfile
...
gem 'bootstrap-sass', '~> 3.3.1'
gem 'autoprefixer-rails'
Let’s save and run bundle install.

Command Line
$ bundle install
Let’s also remember to restart our Rails server.

Command Line
$ rails s
We now need to setup our CSS and JavaScript files. Unlike the gem page, which tells us to make changes to our application.css.scss stylesheet, I’m going to create a new file in my app/assets/stylesheets directory called custom.css.scss. At the top, let’s copy these two lines of code.

app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";
We’ll save this and while we’re here, let’s also open the scaffolds.css.scss file that was created when we generated our scaffold and delete all this code to prevent it from conflicting with any custom CSS we write later on. It’s better to do this than to delete the file entirely, because it’ll be recreated if we generate a new scaffold in the future.

app/assets/stylesheets/scaffolds.css.scss

Let’s save and now go to our application.js file, where we’ll copy over the //= require bootstrap-sprockets line and paste it in underneath //= require jquery. Let’s save this as well.

app/assets/javascripts/application.js
…
//= require jquery
//= require bootstrap-sprockets
//= require jquery_ujs
//= require turbolinks
//= require_tree .
With Bootstrap set up, all we need to do to add Bootstrap styling to our table is go to our view page, which is under app/views/posts/index.html.erb, and change <table> to <table class="table">.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table">
  …
Let’s save and refresh our localhost page. It’s already looking a little cleaner. Let’s also add a couple Bootstrap table options. We’ll make it so that the rows are highlighted as we hover over them with the class table-hover. We’ll also add table-condensed to make each row a little shorter.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table table-hover table-condensed">
  …
Let’s save and reload the page. Good.

Next, let’s think about what data we want to display here on the index page versus on the show page. This body field is definitely too long and it’s messing up the spacing on our table, so we’ll get rid of it. The @external_url field is also really long, so we’ll remove that as well.

Let’s go to our view page and delete these two lines along with their corresponding column headings and save.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td><%= post.heading %></td
      <td><%= post.price %></td
      <td><%= post.neighborhood %></td
      <td><%= post.timestamp %></td
      …
Our table spacing looks a lot better.

Let’s also remove these ‘Edit’ and ‘Destroy’ links and make this entire heading into a link to the ‘Show’ page. In our code, we’ll delete the column heading for these links and get rid of the ‘Edit’ and ‘Destroy’ code. To convert our ‘heading’ text into a link, we’ll add a ‘link_to’, and put a comma, followed by the route, which is ‘post’. Now we can delete the old ‘Show’ link as well.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table table-hover table-condensed">
  <thead>
    <tr>
      <th>Heading</th>
      <th>Price</th>
      <th>Neighborhood</th>
      <th>Timestamp</th>
    </tr>
  </thead>

  <tbody>
    <% @posts.each do |post| %>
      <tr>
        <td><%= link_to post.heading, post %></td>
        <td><%= post.price %></td>
        <td><%= post.neighborhood %></td>
        <td><%= post.timestamp %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New Post', new_post_path %>
Let’s save and refresh our page. Looks good. We can click on any of these post headings to see that it takes us to the ‘Show’ page, which means it’s working.

Let’s also delete the words ‘Listing posts’ at the top and put everything in a Bootstrap container. This just adds some padding to the sides of our screen.

app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    …   
  <%= link_to 'New Post', new_post_path %>
</div>
The last change we’ll make to the index page for now is to adjust the formatting of the ‘Price’ and ‘Timestamp’ fields. For ‘Price’, we want to display the apartment’s rent amount in dollars, so we’ll go back to our code and add the Rails helper ‘number_to_currency(’ in front and close the parentheses.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= post.timestamp %></td>
</tr>
Let’s save. Good. We can remove the decimal places by going back and adding a , precision: 0.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= post.timestamp %></td>
</tr>
Let’s save and check. Great!

If you’re ever unsure about all the different options available for something like number_to_currency, just search it in Google. I’ll type ‘number_to_currency rails’ and click on the first link. You can see that this api.rubyonrails.org site shows us the syntax for number_to_currency, which is to write number_to_currency followed by the number we want to format followed by any number of options we want to include. Here’s the precision option that we’re using and there are even some examples below.

Going back to our table, we can see that the ‘Neighborhood’ field is pretty tough to read. These are the locality code names that 3taps gave us, and we’ll skip this for now, but in a later video we’ll see how to convert these to more user-friendly names.

Finally, we have the ‘Timestamp’ field. This number is shown in Unix time, so we’ll want to convert this to a more easily understandable format. We’ll go to our code and write Time.at( and close our parentheses. Time.at does exactly what it sounds like – given a Unix time value, it tells us the normal date and time. We’ll also need to add a .to_i here because the timestamp field is stored in our database as a string. Since Time.at needs an integer, .to_i does the conversion for us.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= Time.at(post.timestamp.to_i) %></td>
</tr>
Let’s save and go see. Okay, our timestamp is now shown with the date, the time, and the timezone. But instead of displaying it in this format, we can just write how long ago the post was updated. We’ll write time_ago_in_words( and close our parentheses.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= time_ago_in_words(Time.at(post.timestamp.to_i)) %></td>
</tr>
Let’s save and see the change. It now says ‘3 days’. If it were closer to the time when the post was updated, it might say ‘5 hours’ or ‘33 minutes’ instead. I want to add the word ‘ago’ at the end, so it says ‘3 days ago’. We’ll go back to our code and since we’re trying to combine Ruby code with a string, we’ll use a technique called string interpolation. Let me show you how it works.

We can’t just write ‘ago’ at the end of this because then our app will think it’s Ruby code. And if we put this all in double quotes, then our app will think we want our timestamp to literally be ‘time_ago_in_words’ etc. With string interpolation, we can put a hashtag in front of our Ruby code and surround it in curly braces. This way, our app knows which parts are code and which parts are just strings. Anything inside the curly braces is interpreted as code.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= "#{time_ago_in_words(Time.at(post.timestamp.to_i))} ago" %></td>
</tr>
Let’s save and see if it worked. Great!

Finally, let’s rename the column header. We’ll call it ‘Last Updated’, save, and refresh.

app/views/posts/index.html.erb
…
  <th>Heading</th>
  <th>Price</th>
  <th>Neighborhood</th>
  <th>Last Updated</th>
…
Through our Bootstrap styling, data formatting, and removal of a couple columns, our table looks much better than it did at the start of this video. In the next video, we’ll continue working on this index page by adding pagination so we don’t need to load all 1,000 posts here at once.

Paginate the Index Page:
Add the will_paginate gem
Gemfile
…
gem 'will_paginate', '~> 3.0.6'
Command Line
$ bundle install
Don’t forget to restart your Rails server!


Set up the will_paginate gem
app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
end
…
app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>

Add the will_paginate-bootstrap gem
Gemfile
…
gem 'will_paginate-bootstrap'
Command Line
$ bundle install
Don’t forget to restart your Rails server!


Set up the will_paginate-bootstrap gem
app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts, renderer: BootstrapPagination::Rails %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>
Here’s what our index page looks like now. What we’ll do in this video is add pagination to divide these 1,000 posts into multiple pages.

Whenever you want to add a new feature on your site, it helps to know which gems are available so you can avoid having to write all the code from scratch. A great resource for discovering and comparing gems is a site called The Ruby Toolbox.

For example, if we want to see our options for setting up pagination, we can search ‘ruby toolbox pagination’. We’ll click on the link to go to the Ruby Toolbox website. Ruby Toolbox organizes gems into different categories, one of which is pagination. The site ranks the gems in that category by popularity, which it calculates using a combination of gem downloads and activity on the gem’s GitHub page.

So here we can see that there are two main gems, will_paginate and kaminari, that are equally popular for pagination. If we want, we can click on the links to check out each gem’s documentation and compare the setup instructions and options that each gem comes with. In this case, I’ve used both of these before and they’re pretty similar, so let’s just go with the will_paginate gem.

To install the gem, we’ll copy this line and paste it into our Gemfile.

Gemfile
…
gem 'will_paginate', '~> 3.0.6'
We’ll save, run bundle install, and restart our Rails server.

Command Line
$ bundle install
Command Line
$ rails s
Now setting up this gem is pretty simple. There are only two things we have to do. First, we need to use this .paginate method or even better, the .paginate method with the option to specify the number of posts per page. Let’s copy this last part, open up our controller file, and paste it in after Post.all. If we want, we can change this 30 to any other number, but 30 posts per page sounds about right to me.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
end
…
Let’s save this.

The second thing we need to do is put this <%= will_paginate @posts %> line in our view page. Let’s copy this, go to our app/views/posts/index.html.erb file and paste it at the bottom, right before the <br>. We don’t even need to customize this at all because this sample code has @posts, which happens to be the same name as the variable that we’ve defined in our controller. Remember that whatever variables we define in our controller in the index section will be available to our corresponding view page, index.html.erb.

app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>
Let’s save this and see it in our browser. There we go. The page numbers appear at the bottom where we placed our line of code. We can go to the next page by clicking on ‘2’ or ‘Next’, and we can go to the last page by clicking on ‘34’. Great!

The will_paginate gem is all set up now, but let’s make the styling look consistent with our Bootstrap table by using a second gem called will_paginate-bootstrap. Let’s Google this and go to the gem’s GitHub page. Let’s follow the installation instructions and copy this line and paste it into our Gemfile.

Gemfile
…
gem 'will_paginate-bootstrap'
We’ll save, run bundle install, and restart our Rails server.

Command Line
$ bundle install
Command Line
$ rails s
Now to set it up, we only need to change a single line. In our index.html.erb file, where we wrote <%= will_paginate @posts %>, we need to add a , renderer: BootstrapPagination::Rails. Let’s copy this, go to our index.html.erb file, and paste it in here. And save.

app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts, renderer: BootstrapPagination::Rails %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>
We’ll reload our localhost page and look, we’re done.

Our index page is now looking pretty good, with nice formatting and Bootstrap-styled pagination. We’ll hold off on improving our show page and instead in the next video, we’ll see if we can go back and grab more detailed information on these Craigslist posts from 3taps, like the number of bedrooms and bathroom.


4.Gather Detailed Data
Scrape Apartment Details:
Add extra fields to our Post database
Command Line
$ rails generate migration AddFieldsToPosts bedrooms:integer bathrooms:decimal sqft:integer cats dogs w_d_in_unit street_parking
$ rake db:migrate
Don’t forget to restart your Rails server!

Command Line
$ rails s

Write a rake task to clear the Post database
lib/tasks/scraper.rake
desc "Destroy all posting data"
task destroy_all_posts: :environment do
  Post.destroy_all
end
Run this task with rake scraper:destroy_all_posts

Command Line
$ rake scraper:destroy_all_posts

Revise our rake task to scrape the new fields
lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["sqft"]

# Store results in database
result["postings"].each do |posting|

  # Create new Post
  @post = Post.new
  @post.heading = posting["heading"]
  @post.body = posting["body"]
  @post.price = posting["price"]
  @post.neighborhood = posting["location"]["locality"]
  @post.external_url = posting["external_url"]
  @post.timestamp = posting["timestamp"]
  @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
  @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
  @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
  @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
  @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
  @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
  @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

  # Save Post
  @post.save
…
Re-scrape the data we need

Command Line
$ rake scraper:scrape

Download SQLite Database Browser
Open the craigslist_scraper/db/development.sqlite3 file and check that the data was populated correctly.
In the last few videos, we created our web app, loaded it with Craigslist data that we got from 3taps, and added some basic styling to our index page to allow our app to look presentable. This time, we’ll go back and take a second look at our 3taps data to see if we can pull some extra details.

If we look at any apartment listing on Craigslist, we’ll see that there are these tags on the right side. These tags show details like the number of bedrooms and bathrooms, when the apartment will be available, and whether cats or dogs are allowed. But these tags vary from post to post. They’re all optional, so some listings will be more complete than others.

Let’s see if we can access these details through 3taps. We’ll go back to our rake task under lib/tasks/scraper.rake. If we run this task as-is, it’s going to store another 1,000 posts into our database. So since we just want to explore around, let’s comment out this whole section. Then we’ll replace this line with puts JSON.pretty_generate result["postings"], which will display all the posting data onto the screen.

lib/tasks/scraper.rake
…
# Display results to screen
puts JSON.pretty_generate result["postings"]

# # Store results in database
# result["postings"].each do |posting|

#   # Create new Post
#   @post = Post.new
#   @post.heading = posting["heading"]
#   @post.body = posting["body"]
#   @post.price = posting["price"]
#   @post.neighborhood = posting["location"]["locality"]
#   @post.external_url = posting["external_url"]
#   @post.timestamp = posting["timestamp"]

#    # Save Post
#    @post.save
…
Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Okay, let’s take a look at some of these. It looks like most of the tag data is stored in this field called annotations. This specific listing has information on the number of bathrooms, the number of bedrooms, the neighborhood name, a link to a Google map of the address, the date the apartment will be available, whether cats or dogs are allowed, and even the phone number and IP address of the person who posted it.

Let’s look at a different post. This one seems to have a bunch of the same fields. The format of the bathrooms (“1ba”) and bedrooms (“0br”) seems to be consistent (“2ba”, “2br”). The source_neighborhood seems to be user-inputted with lowercase ‘bedstuy’ here and all caps ‘BEDSTUY / CROWN HEIGHTS’ here, so it’s good that we took our neighborhood information directly from 3taps’s location field as it’ll already be standardized.

What else? The values for cats and dogs seem to be consistent as well. They both have “YES” in all caps up here and down here.

Let’s choose a few of these fields to add as columns in our database. We’ll pick bedrooms, bathrooms, cats, dogs, and I’ll also throw in a few more fields, sqft and two more that seem to be pretty common in Brooklyn. One is a field called w_d_in_unit, which tells whether a washer and dryer are available in the apartment, and another is called street_parking, which tells us whether street parking is available outside the building.

Let’s generate a migration to add these extra fields to our Post database. We’ll write rails generate migration AddFieldsToPosts bedrooms:integer bathrooms:decimal sqft:integer cats dogs w_d_in_unit street_parking.

Command Line
$ rails generate migration AddFieldsToPosts bedrooms:integer bathrooms:decimal sqft:integer cats dogs w_d_in_unit street_parking
There are a couple points I should note here. First, bathrooms is a decimal because an apartment can have a half bath without a shower. Second, you’ll notice that the 3taps bathrooms and bedrooms values don’t just have a number, like 2 or 3. Instead, they’ll say ‘2ba’ or ‘3br’. But if we tell our app to save something like ‘2ba’ as an integer, it’ll ignore everything after the ‘2’ and save it as just the number ‘2’. So this little shortcut makes our life easier when it comes to formatting data.

Let’s hit Enter and then run rake db:migrate to add these new columns to our Post database.

Command Line
$ rake db:migrate
We’ll also restart our Rails server.

Command Line
$ rails s
We want to repopulate our database with all the columns this time, so let’s clear the old data out first. We could do this through the Rails console, but we might need to do it again later on, so let’s write a quick rake task.

In our scraper.rake file, we’ll go to the bottom and fill in the section for the destroy_all_posts task we created earlier. As the description, let’s write “Destroy all posting data” and for the actual task, we’ll write the following:

lib/tasks/scraper.rake
desc "Destroy all posting data"
task destroy_all_posts: :environment do
  Post.destroy_all
end
This destroy_all method destroys all the objects in our Post database. Let’s save and run it with rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Now when we refresh our localhost page, we’ll see it’s empty.

With our database emptied, let’s go back to our scrape task and figure out the code we need to write to access these new fields. It should pretty similar to the code we wrote to grab the neighborhood. In that situation, we wrote posting["location"] to get the location hash and then ["locality"] to get the value from within the hash.

Let’s try grabbing the bedrooms field. We’ll grab a single posting using puts result["postings"].first, and then we’ll tack on a ["annotations"] to get the annotations hash and then ["bedrooms"] to get the bedrooms field.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["annotations"]["bedrooms"]
…
Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Good, we got it. There’s one problem though – this won’t work in situations where the bedrooms field is missing. For example, we can comment out this current line and look at the annotations hash of the first posting with puts JSON.pretty_generate result["postings"].first["annotations"].

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["bedrooms"]
puts JSON.pretty_generate result["postings"].first["annotations"]
…
I’ll save and re-run this.

Command Line
$ rake scraper:scrape
You can see that this posting lacks the sqft field, for example. So if we delete this line and run the same code as before but with sqft instead of bedrooms, let’s see what happens.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["annotations"]["sqft"]
…
Command Line
$ rake scraper:scrape
We got a blank line. In other words, our rake task couldn’t find the sqft field and so it returned nil. This could be a problem because we’ve told our database that the sqft column should be an integer so when it sees nil, rather than leave our column blank, it’s going to put in 0 as the square footage.

To avoid this situation, we’ll have to first check whether the field exists. We’ll go back to our code, comment out the line where we display results to the screen, and uncomment out the section where we store our results in the database. After we set the post’s timestamp, let’s write:

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["sqft"]

# Store results in database
result["postings"].each do |posting|

  # Create new Post
  @post = Post.new
  @post.heading = posting["heading"]
  @post.body = posting["body"]
  @post.price = posting["price"]
  @post.neighborhood = posting["location"]["locality"]
  @post.external_url = posting["external_url"]
  @post.timestamp = posting["timestamp"]

  if posting["annotations"]["bedrooms"].present?
    @post.bedrooms = posting["annotations"]["bedrooms"]
  end

  # Save Post
  @post.save
…
This is saying that if the bedrooms field exists, then save it to the bedrooms column of our database. We can even simplify this into a one-liner by moving the ‘if statement’ and deleting the end.

lib/tasks/scraper.rake
…
@post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
…
Let’s do this same thing for each one of our new fields.

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["sqft"]

# Store results in database
result["postings"].each do |posting|

  # Create new Post
  @post = Post.new
  @post.heading = posting["heading"]
  @post.body = posting["body"]
  @post.price = posting["price"]
  @post.neighborhood = posting["location"]["locality"]
  @post.external_url = posting["external_url"]
  @post.timestamp = posting["timestamp"]
  @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
  @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
  @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
  @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
  @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
  @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
  @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

  # Save Post
  @post.save
…
Okay, let’s save and try running this.

Command Line
$ rake scraper:scrape
To see if it worked, I’m going to use a tool called SQLite Database Browser. You can download it by searching ‘SQLite Database Browser’, clicking the sourceforge link, and hitting ‘Download’. Once it’s installed, open it up, click on the ‘Open Database’ link on top, navigate to your ‘craigslist_scraper’ app directory, click on ‘db’ and double-click ‘development.sqlite3’. Make sure you’re in the ‘Browse Data’ tab and looking at the ‘posts’ table.

Scrolling to the right, we can see the new fields we’ve added and the good news is that most of them seem to be filled in. The majority of our posts have bedrooms and bathrooms filled in, along with cats and dogs, while sqft, w_d_in_unit, and street_parking are only available for a portion of our apartments.

With our new data fields added, it’s time to update our index and show pages with this new information in the next video.

Display Details:
Now that we’ve correctly populated our database with these new fields, let’s display this information on our app’s pages as well.

Let’s open up our Sublime Text and we’ll go to our view page code under app/views/posts/index.html.erb and add a couple new column headings:

app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    <thead>
     <tr>
       <th>Heading</th>
       <th>Price</th>
       <th>Beds</th>
       <th>Baths</th>
       <th>Neighborhood</th>
       <th>Last Updated</th>
     </tr>
    </thead>
    …
We’ll also add the data values below. After the line for ‘Price’, we’ll write:

app/views/posts/index.html.erb
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td><%= link_to post.heading, post %></td>
      <td><%= number_to_currency(post.price, precision: 0) %></td>
      <td><%= post.bedrooms %></td>
      <td><%= post.bathrooms %></td>
      …
Let’s save and see how it looks. Great!

Now for our Show page, we haven’t done any styling here yet, but I want to at least have the new data be displayed here so we’ll be ready when we need to format it later on. Let’s go to our code under app/views/posts/show.html.erb and below ‘Timestamp’, we’ll write:

app/views/posts/show.html.erb
…
<p>
  <strong>Timestamp:</strong>
  <%= @post.timestamp %>
</p>

<p>
  Bedrooms: <%= @post.bedrooms %>
</p>

<p>
  Bathrooms: <%= @post.bathrooms %>
</p>

<p>
  Square Footage: <%= @post.sqft %>
</p>

<p>
  Cats allowed: <%= @post.cats %>
</p>

<p>
  Dogs allowed: <%= @post.dogs %>
</p>

<p>
  Washer/dryer in unit: <%= @post.w_d_in_unit %>
</p>

<p>
  Street parking: <%= @post.street_parking %>
</p>
…
Let’s save and refresh our Show page. It’s neither pretty nor consistent, but at least the information is all here. While we’re here on the Show page, let’s also put this into a “container” class.

app/views/posts/show.html.erb
<p id="notice"><%= notice %></p>

<div class="container">
  <p>
    <strong>Timestamp:</strong>
    <%= @post.timestamp %>
  </p>
  ...
  <%= link_to 'Edit', edit_post_path(@post) %> | 
  <%= link_to 'Back', posts_path %>
</div>
We’ll save and refresh.

We now have a lot more data on each listing, from the price to the location, even on whether cats or dogs are allowed. In the next video, we’ll work on grabbing and displaying the last set of data we need, the images uploaded with each post.

Collect and Store Images:
We’ve now grabbed most of the relevant information on our Craigslist posts, but we’re still missing one very important thing: images.

We saw in an earlier video that 3taps gives us a list of URLs containing the images that were uploaded with the post. What we’ll do this time is grab those images and store them in our database.

Normally, when we want to attach images to a resource like our posts, we would use a file attachment gem like paperclip or carrierwave. This situation is different because we no longer need to attach an actual file – we can simply store the URL as a string instead.

Since each post can have multiple images, it’s best to create a new database for these image URLs that’s linked to our database of Posts. This is a has_many/belongs_to relationship, where a Post has many Images, and an Image belongs to a specific Post.

We’ll go to our command line and we could write rails generate model Image url:text, which would create an Image table for us with a single column, url. Notice that we’re storing the URL as text instead of string because strings max out at 256 characters and URLs for images could be very long, whereas URLs for Craigslist are standardized. After running this command, we’d then have to create another migration to add a post_id column which tells us which Post an Image belongs to.

But there’s a shortcut we can use to do it all in a single command. At the end of this, we’ll add a post:references. This will automatically create the post_id column for us. Let’s hit Enter, run rake db:migrate, and restart our Rails server.

Command Line
$ rails generate model Image url:text post:references
$ rake db:migrate
Command Line
$ rails s
Now that our database columns have been created, we need to go to our model files and set up the has_many/belongs_to relationship. If we open our app/models/image.rb file, we’ll see that the belongs_to side has already been done for us, so let’s open post.rb and write has_many :images. We’ll also add , dependent: :destroy, which will cause an Image to be deleted when the Post it belongs to is destroyed.

app/models/post.rb
class Post < ActiveRecord::Base
  has_many :images, dependent: :destroy
end
Let’s save that. If we want, we can open up our SQLite Database Browser, navigate to our app’s database, go to ‘Browse Data’, and look at our new Images table. Here are the url and post_id columns that we created. We now want to populate this table and have many image URLs in this column, all tied to an ID here that corresponds to an ID from our table of Posts.

To do this, we’ll open up our rake task under lib/tasks/scraper.rake. Like last time, let’s comment out the section where we save to our database so we can figure out the right syntax to use to grab the image URLs. We’ll then uncomment this line and write puts JSON.pretty_generate result["postings"].first["images"] which will grab the images hash that we want.

lib/tasks/scraper.rake
  …
  # Display results to screen
  puts JSON.pretty_generate result["postings"].first["images"]

  # # Store results in database
  # result["postings"].each do |posting|

  #   # Create new Post
  #   @post = Post.new
  #   @post.heading = posting["heading"]
  #   @post.body = posting["body"]
  #   @post.price = posting["price"]
  #   @post.neighborhood = posting["location"]["locality"]
  #   @post.external_url = posting["external_url"]
  #   @post.timestamp = posting["timestamp"]
  #   @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
  #   @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
  #   @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
  #   @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
  #   @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
  #   @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
  #   @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

  #   # Save Post
  #   @post.save
  # end
end
…

Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Ok, so to grab just this URL, we’ll look at the first image and take the name that corresponds to “full”. In our code, we’ll add .first["full"], but since the result won’t be a hash anymore, we’ll need to delete the JSON.pretty_generate.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["images"].first["full"]
…
Let’s save, and run this again.

Command Line
$ rake scraper:scrape
Good – that’s the URL we wanted. Let’s see if we can get this to save to our database. We’ll comment out this line of code and uncomment the section where we save to our database.

lib/tasks/scraper.rake
  …
  # Display results to screen
  # puts result["posting"].first["images"].first["full"]

  # Store results in database
  result["postings"].each do |posting|

    # Create new Post
    @post = Post.new
    @post.heading = posting["heading"]
    @post.body = posting["body"]
    @post.price = posting["price"]
    @post.neighborhood = posting["location"]["locality"]
    @post.external_url = posting["external_url"]
    @post.timestamp = posting["timestamp"]
    @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
    @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
    @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
    @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
    @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
    @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
    @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

    # Save Post
    @post.save
  end
end
The image URLs won’t be going in the database of Posts, so after ‘@post.save’, we’ll write:

lib/tasks/scraper.rake
    …
    # Save Post
    @post.save

    # Loop over images and save to Image database
    posting["images"].each do |image|
      @image = Image.new
      @image.url = image["full"]
      @image.post_id = @post.id 
      @image.save
    end  
  end
end
The code we just wrote is looping over the images hash of a post and for each of those URLs, it’s creating a new row in our Image database where we’re grabbing the URL and putting it in the url column. Then we’re taking the ID of the Post we just saved above and we’re putting that in the post_id column. Let’s save.

Before we run this, we’ll need to clear out our database of Posts again. Otherwise, we’re going to get repeats of the same 1,000 posts that are there already. To do that, we’ll run rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Now we’ll run rake scraper:scrape to populate our Post and Image databases.

Command Line
$ rake scraper:scrape
It takes a while to finish, but once it’s done, let’s look in our database to see if it worked. In our Images table, we can see we now have thousands of image URLs, each linked to a specific Post ID. That’s great.

Now, let’s display it in our Show page. Let’s open our app at localhost:3000/posts. We’ll click on one of these links to get to the Show page. We’ll see if we can display all the images for the Post down here.

Let’s first go to our controller file under app/controllers/posts_controller.rb, and in the ‘show’ section, we’ll define a new variable. We’ll write:

app/controllers/posts_controller.rb
…
def show
  @images = @post.images
end
…
This code finds all the images in our Image database that belong to the current Post. Let’s save this, and we’ll now be able to use this variable from our view page. Let’s go to app/views/posts/show.html.erb and right before the ‘Edit’ link, we’ll write:

app/views/posts/show.html.erb
  …
  <p>
    Street parking: <%= @post.street_parking %>
  </p>

  <% @images.each do |image| %>
    <%= image_tag image.url %>
  <% end %>

  <%= link_to 'Edit', edit_post_path(@post) %> |
  <%= link_to 'Back', posts_path %>
</div>
This will loop over each image and display the image that’s pulled from its URL. Let’s save and see this in our browser.

Alright, the images show up, but the spacing is off. To force them each onto a row of their own, we could add some <br> tags, but instead let’s add Bootstrap’s ‘thumbnail’ class. We’ll add a , class: "thumbnail" and save.

app/views/posts/show.html.erb
  …
  <% @images.each do |image| %>
    <%= image_tag image.url, class: "thumbnail" %>
  <% end %>

  <%= link_to 'Edit', edit_post_path(@post) %> |
  <%= link_to 'Back', posts_path %>
</div>
When we refresh, we’ll see that this has the extra benefit of adding a slight border around the image.

With images now set up, our dataset is nearly complete. There’s one last formatting change we should make, which is to translate these 3taps codes into actual neighborhood names. We’ll get started on that in the next video.


5.Scrape Location Data
Look Up Meighborhoods:
We’ve now saved all the data fields we want to our database. But let’s see if we can take the 3taps neighborhood codes and convert them into human-readable names. The perfect tool for the job is the 3taps Reference API that we used early on.

To refresh our memory, let’s go to the 3taps website and look at the documentation. We’ll be using the fourth section on Locations. If we want to get a list of neighborhood codes in Brooklyn, we’ll need the auth_token parameter, the locality parameter (which is 3taps’s name for a neighborhood), and also this optional city parameter which will limit our list to neighborhoods in Brooklyn only.

We’ll use these parameters to create a new rake task, where our goal will be to save a list of locality codes and their corresponding neighborhood names into our own database. But before we do that, we need to create the database itself. Let’s write rails generate model Location code name. This will create a new Location database with two columns, one for the 3taps code and another for the human-readable name.

Command Line
$ rails generate model Location code name
Let’s hit Enter, run ‘rake db:migrate’, and restart our Rails server.

Command Line
$ rake db:migrate
Command Line
$ rails s
Let’s now go to Sublime Text and open our lib/tasks/scraper.rake file. Scroll to the bottom and copy our ‘destroy_all_posts’ task which we’ll use as a template. Let’s paste it below and replace the description with “Save neighborhood codes in a reference table”. Instead of ‘destroy_all_posts’, let’s name this task ‘scrape_neighborhoods’.

lib/tasks/scraper.rake
  desc "Save neighborhood codes in a reference table"
  task scrape_neighborhoods: :environment do
    Post.destroy_all
  end

end
For the task’s code, we’ll delete this line and copy the code from the ‘scrape’ task above, up to the part where we store results in our database. Let’s paste it in here.

lib/tasks/scraper.rake
desc "Save neighborhood codes in a reference table"
task scrape_neighborhoods: :environment do
  require 'open-uri'
  require 'json'

  # Set API token and URL
  auth_token = "{YOUR_AUTH_TOKEN}"
  polling_url = "http://polling.3taps.com/poll"

  # Specify request parameters
  params = {
    auth_token: auth_token,
    anchor: {YOUR_ANCHOR},
    source: "CRAIG",
    category_group: "RRRR",
    category: "RHFR",
    'location.city' => "USA-NYM-BRL",
    retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
  }

  # Prepare API request
  uri = URI.parse(polling_url)
  uri.query = URI.encode_www_form(params)

  # Submit request
  result = JSON.parse(open(uri).read)

  # Display results to screen
  # puts result["postings"].first["images"].first["full"]
end
Since the code to make a data request is pretty similar, we’ll be able to use this as a base and just customize some of the details instead. Our auth_token is still the same, so we’ll leave that here, but we’re no longer using the 3taps Polling URL. Let’s rename this to be location_url and replace the URL itself with the one from the documentation. Don’t forget to change the polling_url down below as well.

lib/tasks/scraper.rake
  …
  # Set API token and URL
  auth_token = "{YOUR_AUTH_TOKEN}"
  location_url = "http://reference.3taps.com/locations"

  …

  # Prepare API request
  uri = URI.parse(location_url)
  uri.query = URI.encode_www_form(params)
  …
For the parameters, we’ll keep the auth_token and delete the rest. Instead, the other two parameters we need are level: "locality" and city: "USA-NYM-BRL", which is the 3taps code for Brooklyn. For now, let’s just display the entire JSON hash, so we’ll write puts JSON.pretty_generate result and save.

lib/tasks/scraper.rake
  …
  # Specify request parameters
  params = {
    auth_token: auth_token,
    level: "locality",
    city: "USA-NYM-BRL"
  }

  …

  # Display results to screen
  puts JSON.pretty_generate result
end
Let’s run this with rake scraper:scrape_neighborhoods.

Command Line
$ rake scraper:scrape_neighborhoods
If we scroll up, we’ll see that all of these sections are contained in a hash called locations. And we want the code and the short_name fields. In other words, we want to be able to look up “USA-NYM-WIU” and see that it’s the code for “Williamsburg”.

To do that, we’ll comment out this line and write a loop similar to the one from our first task:

lib/tasks/scraper.rake
  …
  # Display results to screen
  # puts JSON.pretty_generate result

  # Store results in database
  result["locations"].each do |location|
    @location = Location.new
    @location.code = location["code"]
    @location.name = location["short_name"]
    @location.save
  end
end
For each result we get back from 3taps, this will create a new row in our Location database table and fill in the code and name columns with the code and short_name values 3taps gives us. Let’s save and run this to see if it works.

Command Line
$ rake scraper:scrape_neighborhoods
Now we’ll open our database in SQLite Database Browser and go to the Locations table. Perfect – our app now has a table of neighborhood codes and names to use as a reference. With this set up, we can now translate these codes on our index page in the next video.

Display Neighborhoods:
In the last video, we created a new Location database to store a list of both the 3taps neighborhood codes as well as their corresponding human-readable names. In this video, we’ll take the neighborhood codes that appear in our index page and translate them.

We could take each code and use the Locations table to look up the matching neighborhood name, but we should avoid doing that because we’ll need to run these translations every time we load the index page. Instead, we can be more efficient by storing the human-readable names directly into our Post database. This way, we’ll only need to translate them a single time and avoid having to run these lookups again in the future.

We’ll do the translations when we first collect the data from 3taps. That means we need to update our rake task under lib/tasks/scraper.rake. Here, where we’re saving the neighborhood code, we should look up this code in our database and save the neighborhood name instead. We’ll write:

lib/tasks/scraper.rake
namespace :scraper do
  desc "Fetch Craigslist posts from 3taps"
  task scrape: :environment do
    …
    # Store results in database
      result["postings"].each do |posting|
        
        # Create new Post
        @post = Post.new
        @post.heading = posting["heading"]
        @post.body = posting["body"]
        @post.price = posting["price"]
        @post.neighborhood = Location.find_by(code: posting["location"]["locality"]).name
        …
This will look in our Location database, find the row with a code that matches the one we’ve grabbed, and give us the corresponding neighborhood name instead. For example, if the posting’s ‘locality’ is “USA-NYM-WIU”, then this will look in our database, find the row at the bottom with a code of “USA-NYM-WIU” and give us the corresponding name of “Williamsburg”.

Let’s save this and before we run it, clear our database again with rake scraper:destroy_all_posts. Remember that since we added the dependent: :destroy to our model file last time, this rake task will not only delete all our Posts, but it’ll also delete the Images that belong to those Posts.

Command Line
$ rake scraper:destroy_all_posts
Now we’ll run our scrape task with rake scraper:scrape.

Command Line
$ rake scraper:scrape
We got an error: “NoMethodError: undefined method `name’ for nil:NilClass”. This is a pretty common error – it’s one that we’ll see when code that we think should equal one thing equals nil instead. It says the error is from line 40, and we’ll see that that’s the line we just changed.

Here’s where we’re using the name method which is causing the problem. The name method should normally be fine. Given a row in our Location database, the name method will tell us the value stored in the name column. The problem occurs when this part is nil, or when it can’t find a Location with this matching code field. That happens whenever we have a locality code that doesn’t exist in our database or more likely, when we come across a posting where the locality is blank.

When the neighborhood data is missing, it’s fine to leave that column in our database blank, but we definitely don’t want an error that’ll cause our task to stop running. So to solve this problem, we’ll use a convenient method called try. Instead of .name, we’ll write .try(:name).

lib/tasks/scraper.rake
…
@post.neighborhood = Location.find_by(code: posting["location"]["locality"]).try(:name)
…
If the name is available, it will work as normal, but if it’s not available, then it’ll leave our database column blank and keep going. Let’s save and clear our database again with rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Then we’ll run this again with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Let’s go look at our index page. That’s much better. In the next video, we’ll take the information we’ve collected and work on creating some filters to help users more easily browse the posts on our site.


6.Add Data Filters
Build an Advanced Filter:
Our index page is looking great now. We’re showing all the data we want with nice formatting and even pagination. It’s time to make it easier to browse these posts by adding an advanced filter on top that will allow users to show only posts with a specific number of bedrooms, bathrooms, price ranges, and so on.

We’ll work up to having multiple filters, but we’ll start with a single filter for the number of bedrooms and then build it up layer-by-layer. Let’s go to our view page under app/views/posts/index.html.erb. Under our <div class="container">, we’ll write the following:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms %>
 
      <%= submit_tag "Search" %>
    <% end %>
  </div>

  …
Here we’re using form_tag to create a form. This form has one input field, bedrooms, and a submit button that says “Search”. By putting posts_path (which is the path for our index page), submitting this form will send us to the index page. The method: :get at the end makes sure it’s a normal GET request so we’re not saving anything to a database but instead, the parameters appear in the URL. Let’s save this and see how it looks.

If we try submitting this form with bedrooms as 1 for example, we’ll see that our bedrooms parameter appears in the URL, but the posts that are shown below remain unchanged.

Of the other two parameters, utf8=✓ is automatically added as it’s needed for Internet Explorer browsers, so we’ll leave it there. The commit parameter doesn’t really do anything though, and we can prevent it from showing up by going to our code and adding the , name: nil option to the end.

app/views/posts/index.html.erb
…
<%= submit_tag "Search", name: nil %>
…
Let’s save, go back to localhost:3000/posts and try submitting the form again. Great – we now just have the utf8 and bedrooms parameters.

Let’s use the bedrooms parameter to filter the posts that get shown. We’ll go to our controller file under app/controllers/posts_controller.rb and write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"])
end
…
This line takes the @posts variable that we’ve defined in the line above, selects only those in the list that have the specified number of bedrooms, and replaces the old list in that same @posts variable.

Let’s save and refresh the page. Now, all the posts in our table have only one bedroom, which means our filter is working. Let’s build on this and add a second filter for the number of bathrooms. We’ll start by adding a second input field to our form. We’ll copy the two lines for our bedrooms field and customize it to say bathrooms instead.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
After saving, we’ll go to our controller file and write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"])
  @posts = @posts.where(bathrooms: params["bathrooms"])
end
…
You can see how we’re chaining these together to narrow down our list based on the filter criteria. Let’s save and refresh the page to see our updated filter. We can try searching for 2-bedroom apartments with 1.5 bathrooms and see that it works.

But if instead we leave one of these fields blank by searching for just 2 bedrooms, our filter will return no results. It’s doing this because our app sees these as required fields. So when we leave the field blank, it searches for posts that have an empty string as the number of bathrooms, when of course there are none.

We need to tell our controller to apply the filters only when the field was filled in. To do that, we’ll add a couple ‘if statements’:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"]) if params["bedrooms"].present?
  @posts = @posts.where(bathrooms: params["bathrooms"]) if params["bathrooms"].present?
end
…
Let’s save and refresh the page. This time, it works!

But notice that the filters we apply always disappear after we hit ‘Search’. We can make them persist by adding an option to our input field. In our index.html.erb file, after text_field_tag :bedrooms we’ll write , params[:bedrooms] and do the same for our bathrooms input field.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
What this code does is set the default value of the field to be the value of the parameter in the URL. So when we hit ‘Search’, our search terms are used to auto-populate the filter for us.

Let’s save and try searching again. We’ll see that this time, our search results persist. Great job with filtering our first two fields!

Let’s add filters for each of the remaining fields users might want to search by. We’ll copy and paste this section and replace bedrooms with neighborhood.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>

      <%= label_tag :neighborhood %>
      <%= text_field_tag :neighborhood, params[:neighborhood] %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll repeat this for a few more fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>

      <%= label_tag :neighborhood %>
      <%= text_field_tag :neighborhood, params[:neighborhood] %>

      <%= label_tag :price %>
      <%= text_field_tag :price, params["price"] %>

      <%= label_tag :sqft %>
      <%= text_field_tag :sqft, params["sqft"] %>

      <%= label_tag :cats %>
      <%= text_field_tag :cats, params["cats"] %>

      <%= label_tag :dogs %>
      <%= text_field_tag :dogs, params["dogs"] %>

      <%= label_tag :w_d_in_unit %>
      <%= text_field_tag :w_d_in_unit, params["w_d_in_unit"] %>

      <%= label_tag :street_parking %>
      <%= text_field_tag :street_parking, params["street_parking"] %>

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
Let’s save this and go to our controller file to add the code that will filter by these parameters. We’ll copy the last line and paste it in, changing bathroom to neighborhood. We’ll do the same thing again for price, sqft, cats, dogs, w_d_in_unit, and finally street_parking.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"]) if params["bedrooms"].present?
  @posts = @posts.where(bathrooms: params["bathrooms"]) if params["bathrooms"].present?
  @posts = @posts.where(neighborhood: params["neighborhood"]) if params["neighborhood"].present?
  @posts = @posts.where(price: params["price"]) if params["price"].present?
  @posts = @posts.where(sqft: params["sqft"]) if params["sqft"].present?
  @posts = @posts.where(cats: params["cats"]) if params["cats"].present?
  @posts = @posts.where(dogs: params["dogs"]) if params["dogs"].present?
  @posts = @posts.where(w_d_in_unit: params["w_d_in_unit"]) if params["w_d_in_unit"].present?
  @posts = @posts.where(street_parking: params["street_parking"]) if params["street_parking"].present?
end
…
Let’s save and refresh the page. It looks messy, but it should work. We’ll try typing in Williamsburg as the neighborhood and YES in the cats field and sure enough, the filter works!

Great job! In the next video, we’ll improve the format of our filters so it’s more intuitive to use.

Improve Filter Display:
Last time, we created these filters for data, but these text input fields aren’t ideal. Users shouldn’t have to type YES to search for apartments that allow cats. Instead, it should be a simple checkbox. In fact, the same is true for dogs, w_d_in_unit, and street_parking. Let’s go make that change.

In our index.html.erb file under app/views/posts, we’ll delete this text_field_tag line and replace it with:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :cats %>
      <%= check_box_tag :cats, "YES", params[:cats] %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
The syntax for this is the name of the parameter (:cats), followed by the value of the parameter when checked, which in our case is "YES" because that’s what will match what’s in our database. Finally, the params[:cats] at the end sets the default value of the checkbox.

Let’s repeat this for our three other fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :cats %>
      <%= check_box_tag :cats, "YES", params[:cats] %>

      <%= label_tag :dogs %>
      <%= check_box_tag :dogs, "YES", params[:dogs] %>

      <%= label_tag :w_d_in_unit %>
      <%= check_box_tag :w_d_in_unit, "YES", params[:w_d_in_unit] %>

      <%= label_tag :street_parking %>
      <%= check_box_tag :street_parking, "YES", params[:street_parking] %>

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll save and check it out. We’ll search for apartments in Williamsburg that allow cats and dogs. Good – it works.

Let’s now make our neighborhood field into a dropdown menu that displays all the possible neighborhoods in Brooklyn. We’ll go to our code and replace this text_field_tag line with:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :neighborhood %>
      <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
Here, the select_tag is creating a dropdown menu for the neighborhood field. The options_from_collection_for_select is basically taking the objects in our Location database, which are neighborhood names, and it’s using the name column to populate our dropdown menu. The include_blank: true at the end will show a blank as the first dropdown result.

Let’s save and see the change in our browser. There we go – that should make it a lot easier for our users.

The last change we’ll make is split our ‘Price’ and ‘Sqft’ filters into a minimum and maximum range. Let’s copy this price section and rename them to be min_price and max_price. We’ll do the same for sqft.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :min_price %>
      <%= text_field_tag :min_price, params[:min_price] %>

      <%= label_tag :max_price %>
      <%= text_field_tag :max_price, params[:max_price] %>

      <%= label_tag :min_sqft %>
      <%= text_field_tag :min_sqft, params[:min_sqft] %>

      <%= label_tag :max_sqft %>
      <%= text_field_tag :max_sqft, params[:max_sqft] %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll save and this time, we also need to adjust our controller code. So in our app/controllers/posts_controller.rb, rather than where(price: params["price"], we’ll write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  …
  @posts = @posts.where("price > ?", params["min_price"]) if params["min_price"].present?
  @posts = @posts.where("price < ?", params["max_price"]) if params["max_price"].present?
  …
end
…
Now let’s repeat that for sqft.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  …
  @posts = @posts.where("price > ?", params["min_price"]) if params["min_price"].present?
  @posts = @posts.where("price < ?", params["max_price"]) if params["max_price"].present?
  @posts = @posts.where("sqft > ?", params["min_sqft"]) if params["min_sqft"].present?
  @posts = @posts.where("sqft < ?", params["max_sqft"]) if params["max_sqft"].present?
  …
end
…
Just so you know, you’ll notice that we’ll sometimes grab our URL parameters using double quotes for a string and sometimes we’ll use a colon for a symbol. These are interchangeable and do exactly the same thing.

Let’s save and take another look. Now we can filter for apartments that cost between $2,000 and $3,000.

Good job! Getting our filters working for text fields, checkboxes, and dropdown menus wasn’t easy. In fact, this still looks pretty bad, though it is functional. So next time, we’re going to use the Bootstrap grid system to organize this a bit and add some options to our inputs to make this look a little more professional.

Structure Filter Layout:
We now have working filters we can use to browse our database of Craigslist posts. This time, we’re going to clean this up by adding some layouts as well as placeholders and other options.

Let’s start by using the Bootstrap grid system to organize these into rows and columns. We want to put the headings in their own row above the input fields. That will give us four total rows: heading, input, heading, input.

We’ll go to our app/views/posts/index.html.erb file to set this up. First, let’s rearrange these fields a bit. We’ll move the price fields first as they’re the filters that are most likely to be used. So our first row will have price, bedrooms, bathrooms, and neighborhood. Our second row will have sqft, our four checkboxes, and our ‘Search’ button.

Let’s create a <div class="row"> and move the labels for our top fields here. We’ll close this <div> and create a new row for those input fields. Let’s do the same thing for our remaining fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <%= label_tag :min_price %>
        <%= label_tag :max_price %>
        <%= label_tag :bedrooms %>
        <%= label_tag :bathrooms %>
        <%= label_tag :neighborhood %>
      </div>

      <div class="row">
        <%= text_field_tag :min_price, params[:min_price] %>
        <%= text_field_tag :max_price, params[:max_price] %>
        <%= text_field_tag :bedrooms, params[:bedrooms] %>
        <%= text_field_tag :bathrooms, params[:bathrooms] %>
        <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
      </div>

      <div class="row">
        <%= label_tag :min_sqft %>
        <%= label_tag :max_sqft %>
        <%= label_tag :cats %>
        <%= label_tag :dogs %>
        <%= label_tag :w_d_in_unit %>
        <%= label_tag :street_parking %>
      </div>

      <div class="row">
        <%= text_field_tag :min_sqft, params[:min_sqft] %>
        <%= text_field_tag :max_sqft, params[:max_sqft] %>
        <%= check_box_tag :cats, "YES", params[:cats] %>
        <%= check_box_tag :dogs, "YES", params[:dogs] %>
        <%= check_box_tag :w_d_in_unit, "YES", params[:w_d_in_unit] %>
        <%= check_box_tag :street_parking, "YES", params[:street_parking] %>
       <%= submit_tag "Search", name: nil %>
      </div>

    <% end %>
  </div>

  …
Let’s save and take a look.

Not exactly how we expected. We need to set the number of columns each section gets. For example, of the 12 Bootstrap grids, we can allocate 4 grids to our price fields and 4 grids to our neighborhood field because it’s pretty long. Bedrooms and bathrooms will each get 2 grids.

So in our code, we’ll add a <div class="col-md-4"> around our price labels. In fact, we should probably combine these into a single label.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Price" %>
        </div>
        <%= label_tag :max_price %>
        <%= label_tag :bedrooms %>
        <%= label_tag :bathrooms %>
        <%= label_tag :neighborhood %>
      </div>
      
      …
Let’s do these other three as well.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Price" %>
        </div>
        <div class="col-md-2">
          <%= label_tag :bedrooms %>
        </div>
        <div class="col-md-2">
          <%= label_tag :bathrooms %>
        </div>
        <div class="col-md-4">
          <%= label_tag :neighborhood %>
        </div>
      </div>
      
      …
We’ll use these same grid spacings for the input fields below.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"] %>
          <%= text_field_tag :max_price, params["max_price"] %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"] %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"] %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
        </div>
      </div>
      
      …
Let’s now set the spacing for the headings and fields in the second section.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag :min_sqft %>
          <%= label_tag :max_sqft %>
        </div>
        <div class="col-md-1">
          <%= label_tag :cats %>
        </div>
        <div class="col-md-1">
          <%= label_tag :dogs %>
        </div>
        <div class="col-md-2">
          <%= label_tag :w_d_in_unit %>
        </div>
        <div class="col-md-2">
          <%= label_tag :street_parking %>
        </div>
      </div>
      
      …
Let’s also rename this label to say <%= label_tag "Washer/dryer in unit" %>.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
        …
        <div class="col-md-2">
          <%= label_tag "Washer/dryer in unit" %>
        </div>
        …
Now let’s set the same spacing for the input fields below.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"] %>
          <%= text_field_tag :max_sqft, params["max_sqft"] %>
        </div>
        <div class="col-md-1">
          <%= check_box_tag :cats, "YES", params["cats"] %>
        </div>
        <div class="col-md-1">
          <%= check_box_tag :dogs, "YES", params["dogs"] %>
        </div>
        <div class="col-md-2">
          <%= check_box_tag :w_d_in_unit, "YES", params["w_d_in_unit"] %>
        </div>
        <div class="col-md-2">
          <%= check_box_tag :street_parking, "YES", params["street_parking"] %>
        </div>
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil %>
        </div>
      </div>

    <% end %>
    …
Let’s save and refresh the page. That looks much better!

Let’s make a couple more changes. We’ll put our checkbox headings inline with the checkboxes themselves by going to our code and adding Bootstrap’s form-inline class to our form_tag.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
Then we’ll need to make sure that the labels and checkboxes fall within the same Bootstrap row, so let’s move the labels out of the third row and into the fourth.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag :min_sqft %>
          <%= label_tag :max_sqft %>
        </div>
      </div>
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"] %>
          <%= text_field_tag :max_sqft, params["max_sqft"] %>
        </div>
        <div class="col-md-1">
          <%= label_tag :cats %>
          <%= check_box_tag :cats, "YES", params["cats"] %>
        </div>
        <div class="col-md-1">
          <%= label_tag :dogs %>
          <%= check_box_tag :dogs, "YES", params["dogs"] %>
        </div>
        <div class="col-md-2">
          <%= label_tag "Washer/dryer in unit" %>
          <%= check_box_tag :w_d_in_unit, "YES", params["w_d_in_unit"] %>
        </div>
        <div class="col-md-2">
          <%= label_tag :street_parking %>
          <%= check_box_tag :street_parking, "YES", params["street_parking"] %>
        </div>
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil %>
        </div>
      </div>

    <% end %>
    …
While we’re here, let’s also add some placeholder text to our text fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"], placeholder: "minimum" %>
          <%= text_field_tag :max_price, params["max_price"], placeholder: "maximum" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"], placeholder: "# of beds" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"], placeholder: "# of baths" %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
        </div>
      </div>

      …
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"], placeholder: "minimum" %>
          <%= text_field_tag :max_sqft, params["max_sqft"], placeholder: "maximum" %>
        </div>
        …
We’ll save and refresh the page again.

Okay, the next change we’ll make is to add some Bootstrap styling to each of these text fields as well as the ‘Search’ button. In our code, we’ll add a , class: "form-control input-sm" to the end. The form-control class is what gives it the Bootstrap look and the input-sm class sets the height of the field to be small. Let’s add this to each of our text fields. We’ll also add it to our dropdown menu after include_blank: true.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"], placeholder: "minimum", class: "form-control input-sm" %>
          <%= text_field_tag :max_price, params["max_price"], placeholder: "maximum", class: "form-control input-sm" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"], placeholder: "# of beds", class: "form-control input-sm" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"], placeholder: "# of baths", class: "form-control input-sm" %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true, class: "form-control input-sm" }) %>
        </div>
      </div>

      …
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"], placeholder: "minimum", class: "form-control input-sm" %>
          <%= text_field_tag :max_sqft, params["max_sqft"], placeholder: "maximum", class: "form-control input-sm" %>
        </div>
        …
Finally, we’ll put a , class: "btn btn-primary" to style the ‘Search’ button.

app/views/posts/index.html.erb
        …
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil, class: "btn btn-primary" %>
        </div>
        …
Let’s save and see our updated filters. Great – this looks way better than when we started.

But it looks like we forgot to combine our square footage label. Let’s go fix that now.

app/views/posts/index.html.erb
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Square Footage" %>
        </div>
      </div>
      …
Let’s save and take a look. Great.

Now while this is looking pretty good, notice what happens when we try using some unrealistic search parameters. For example, let’s search for apartments with 25 bathrooms. As expected, our table comes up empty. But it would be much more user-friendly if we could display a message here instead.

So we’ll go to our code and below the filter section, we’ll add an ‘if statement’. We’ll write:

app/views/posts/index.html.erb
      …
    <% end %>
  </div>

  <% if @posts.empty? %>
    <hr>
    <h3>No results found</h3>
  <% else %>
    <table class="table table-hover table-condensed">
      …
    <%= link_to 'New Post', new_post_path %>
  <% end %>

Let’s save and refresh our search. It looks much better. In the next video, we’ll work on creating a homepage for our app and adding some CSS to put a little polish onto our site.

7.Add Front End Styling
Design Homepage:
Now that we have our functionality and data all set up, let’s work on adding some CSS to spruce up the look of our app.

Our index page has a lot of information, but instead of having this be the first page users see when they visit our site, let’s create a separate homepage with just this filter area as a call-to-action. The best example of this kind of homepage is actually Google, where all that’s displayed is a search bar on a plain background.

To add a new page, we’ll need to do three things. First, we’ll go to our controller file under app/controllers/posts_controller.rb and add a new action. We’ll write:

app/controllers/posts_controller.rb
…
def home
end
…
Let’s save. Next, we’ll create a view page to match the new controller-action we just added. Under app/views/posts, let’s create a new file called home.html.erb.

app/views/posts/home.html.erb

Finally, we’ll set up a URL that corresponds to this view page and make it our homepage. In our config/routes.rb file, we’ll write:

config/routes.rb
Rails.application.routes.draw do
  resources :posts
  
  root 'posts#home'
  …
end
Let’s save and go to localhost:3000. We can see it’s blank, but that’s because we haven’t added any code to the view page yet.

One of the easiest ways to design the homepage is to add a Bootstrap jumbotron. A jumbotron is a container that you can fill with information about your site. It’s also a good way to showcase attention-grabbing content or images.

Let’s go to the Bootstrap website at getbootstrap.com and click on “Components”. On the right, let’s click on the “Jumbotron” section. Here, Bootstrap gives us some sample code to use with an option of having the jumbotron span the full width of our site. Let’s use that option here by copying over the second code block. Going back to our home.html.erb file, let’s paste this in.

app/views/posts/home.html.erb
<div class="jumbotron">
  <div class="container">
   ...
  </div>
</div>
Inside the container, we’ll write some information about our site.

app/views/posts/home.html.erb
<div class="jumbotron">
  <div class="container">
    <h1>Craigslist Scraper</h1>
    <h2>The easiest way to find apartment rentals in Brooklyn</h2>
  </div>
</div>
Let’s save and see what this looks like. Great, our text is displaying properly within this jumbotron container. Let’s center this text with CSS. We’ll go to Sublime Text and under app/assets/stylesheets, we’ll click on our custom.css.scss file.

I’ll assume you already have a basic understanding of CSS syntax such as classes, IDs, properties, and values, so we’ll create a “center” class by writing:

app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";

.center {
  text-align: center;
}
We’ll save and then we’ll use this class in our home.html.erb file by wrapping our headers inside a <div>.

app/views/posts/home.html.erb
<div class="jumbotron">
  <div class="container">
    <div class="center">
      <h1>Craigslist Scraper</h1>
      <h2>The easiest way to find apartment rentals in Brooklyn</h2>
    </div>
  </div>
</div>
Let’s save and go back to localhost and refresh the page. Looks better. Let’s now add a background image to our jumbotron. I’ve already found a background image I like but you can use whatever image you want. Just make sure the resolution is high and the size is large enough to fill your screen. Beautiful images can really bring a website to life, but finding the right one can take some trial-and-error.

In our custom.css.scss file, we’ll write:

app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";

.center {
  text-align: center;
}

.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
}
Let’s save and refresh localhost. We can see that our image isn’t displaying all the way because the default height of the jumbotron is too short. Let’s expand the height to fill our screen, mine is around 800px, but yours could be a little different. In my jumbotron CSS, on the next line, I’ll write:

app/assets/stylesheets/custom.css.scss
…
.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
  height: 800px;
}
Don’t forget that users who view your homepage will potentially have multiple screen sizes so make sure to find an image that will be large enough to fill even a
desktop-sized monitor if people will be viewing your site live on the web.

Let’s save and take a look. The jumbotron also has a default margin on the bottom that we can get rid of. Since my image is so large, I’d also like to center it so that the interior of the room is more visible.

Back in our CSS file, we’ll write:

app/assets/stylesheets/custom.css.scss
…
.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
  height: 800px;
  margin: 0px;
  background-position: center;
}
Let’s save and check it out. It’s looking much better! With our background image in place, let’s format this header text font so it looks more fancy.

Inside our .jumbotron class, we’ll write:

app/assets/stylesheets/custom.css.scss
…
.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
  height: 800px;
  margin: 0px;
  background-position: center;
  h1 {
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0px 2px 3px #555;
  }
  h2 {
    color: #fff;
    text-shadow: 0px 2px 3px #555;
  }
}
Here, we’re using a text-shadow to give our text a letterpress effect so it looks more 3D and is easier to read against the background image. Let’s save and go see.

Looks great! We’re now ready to add our filter section underneath this text. Let’s go to Sublime Text and open our app/views/posts/index.html.erb page where the code for our filter is located. We could copy over this code, but since our file is getting pretty long and to avoid having to keep both filters up-to-date, I’d rather move it to a common location.

To do this, we’ll place it in a partial, so let’s create a new file in our app/views/posts folder and call it ___filter.html.erb__. Then we’ll cut out everything starting with this <div class="filter"> and paste it into our partial.

app/views/posts/_filter.html.erb
<div class="filter">
  <%= form_tag posts_path, method: :get, class: "form-inline" do %>
  
    <div class="row">
      <div class="col-md-4">
        <%= label_tag "Price" %>
      </div>
      <div class="col-md-2">
        <%= label_tag :bedrooms %>
      </div>
      <div class="col-md-2">
        <%= label_tag :bathrooms %>
      </div>
      <div class="col-md-4">
        <%= label_tag :neighborhood %>
      </div>
    </div>
    
    <div class="row">
      <div class="col-md-4">
        <%= text_field_tag :min_price, params[:min_price], placeholder: "minimum", class: "form-control input-sm" %>
        <%= text_field_tag :max_price, params[:max_price], placeholder: "maximum", class: "form-control input-sm" %>
      </div>
      <div class="col-md-2">
        <%= text_field_tag :bedrooms, params[:bedrooms], placeholder: "# of beds", class: "form-control input-sm" %>
      </div>
      <div class="col-md-2">
        <%= text_field_tag :bathrooms, params[:bathrooms], placeholder: "# of baths", class: "form-control input-sm" %>
      </div>
      <div class="col-md-4">
        <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true, class: "form-control input-sm" }) %>
      </div>
    </div>
    
    <div class="row">
      <div class="col-md-4">
        <%= label_tag "Square Footage" %>
      </div>
    </div>
    
    <div class="row">
      <div class="col-md-4">
        <%= text_field_tag :min_sqft, params[:min_sqft], placeholder: "minimum", class: "form-control input-sm" %>
        <%= text_field_tag :max_sqft, params[:max_sqft], placeholder: "maximum", class: "form-control input-sm" %>
      </div>
      <div class="col-md-1">
        <%= label_tag :cats %>
        <%= check_box_tag :cats, "YES", params[:cats] %>
      </div>
      <div class="col-md-1">
        <%= label_tag :dogs %>
        <%= check_box_tag :dogs, "YES", params[:dogs] %>
      </div>
      <div class="col-md-2">
        <%= label_tag "Washer/dryer in unit" %>
        <%= check_box_tag :w_d_in_unit, "YES", params[:w_d_in_unit] %>
      </div>
      <div class="col-md-2">
        <%= label_tag :street_parking %>
        <%= check_box_tag :street_parking, "YES", params[:street_parking] %>
      </div>
      <div class="col-md-2">
        <%= submit_tag "Search", name: nil, class: "btn btn-primary" %>
      </div>
    </div>  

  <% end %>
</div>
Let’s save this, and now we call the partial with <%= render 'filter' %>.

app/views/posts/index.html.erb
<div class="container">
  
  <%= render 'filter' %>

  …
Let’s save this and add it to our homepage code as well, and we’ll save.

app/views/posts/home.html.erb
<div class="jumbotron">
  <div class="container">
    <div class="center">
      <h1>Craigslist Scraper</h1>
      <h2>The easiest way to find apartment rentals in Brooklyn</h2>
    </div>
    
    <%= render 'filter' %>
  </div>
</div>
Let’s check it out in our browser. Not so good, it’s a little hard to read. Let’s add a solid background color so that we can differentiate this section from the rest of the page.

Back in our CSS file, let’s write

app/assets/stylesheets/custom.css.scss
…
.filter {
  background-color: rgba(215,226,241,0.9);
}
RGBA stands for red, green, blue, alpha. The 215, 226, and 241 correspond to the amount of those primary colors that are mixed together to make the specific color that we want. The alpha is a way to set the opacity, with 1 being completely opaque and 0 being completely transparent. Here, our background color will be slightly transparent.

Let’s save and go see what it looks like. It’s much easier to read now, but the spacing is cramped inside the filter and it’s too close to the H2 heading. Let’s take care of that now. We’ll add some padding inside our filter <div> and make the borders round.

app/assets/stylesheets/custom.css.scss
…
.filter {
  background-color: rgba(215,226,241,0.9);
  padding: 20px 30px 10px 30px;
  border-radius: 10px;
}
And under h2, we’ll add:

app/assets/stylesheets/custom.css.scss
…
.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
  height: 800px;
  margin: 0px;
  background-position: center;
  h1 {
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0px 2px 3px #555;
  }
  h2 {
    color: #fff;
    text-shadow: 0px 2px 3px #555;
    margin-bottom: 80px;
  }
}
…
Let’s save and take a look. Much better. Finally, all this content here looks a little high on the page, so we’ll add some padding to our overall container on the top and bottom to push the content toward the center of our screen.

Inside our .jumbotron class, we’ll add a .container class and write

app/assets/stylesheets/custom.css.scss
…
.jumbotron {
  background-image: url({YOUR_IMAGE_URL});
  height: 800px;
  margin: 0px;
  background-position: center;
  h1 {
    text-transform: uppercase;
    color: #fff;
    text-shadow: 0px 2px 3px #555;
  }
  h2 {
    color: #fff;
    text-shadow: 0px 2px 3px #555;
    margin-bottom: 80px;
  }
  .container {
    padding: 80px 0px;
  }
}
…
This is adding 80 pixels worth of padding to the top and bottom of our container and 0px to the left and right of our container. Because this CSS is nested inside the .jumbotron selector, it’ll only apply to the container within the jumbotron. Any other containers won’t be affected.

Let’s save and take a look. Great, this is really the minimalist homepage look that we’re going for. We have a strong call-to-action and users will be able to search for their apartment rentals immediately.

Keep in mind that all the changes we just made usually require lots of trial-and-error, but to save time, I’ve already figured out the optimal settings to use. When you do this for your own site, you’ll need to play around with different values to find ones that you’re satisfied with.

To recap, in this video, we created and styled our new homepage with some CSS, Bootstrap, and a custom image. In the next video, we’ll continue to improve the look and feel of our site by styling our index page.

Add Thumbnail Images:
In the last video, we created a homepage for users to browse apartment rentals in Brooklyn. In this video, we’ll continue adding some front-end design to our app by formatting the index page.

Let’s click “Search” to go to our index page. This doesn’t look bad, but let’s fix some small formatting issues. We’ll add a margin on top so the filter isn’t glued to the top of the page. We’ll also add a different background color since the white here looks a little plain.

We’ll open our custom.css.scss file under app/assets/stylesheets. Inside our .filter section, we’ll add:

app/assets/stylesheets/custom.css.scss
…
.filter {
  background-color: rgba(215,226,241,0.9);
  padding: 20px 30px 10px 30px;
  border-radius: 10px;
  margin-top: 30px;
}
Then, to add a default background color for our body, we’ll write:

app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";

body {
  background-color: #f4f7fb;
}
…
This will become the default background color for all our future pages so we can have a consistent look and color palette throughout our site.

Let’s save and check it out. That’s much better. I’m choosing to use this specific color, but you can play around with the background color until you find something you like.

Now if we hover over each post, we can see that the row automatically changes to this peach color because of Bootstrap’s default settings, but let’s change it so it’s more consistent with our color palette.

One cool way to do this is to take whatever color your background is, in our case, it’s this #f4f7fb, and find similar shades in this color family. I like to use a site called colorhexa.com. In their search field, we’ll type in #f4f7fb. If we scroll down, we can find different tint for our initial color along with their corresponding hex codes.

Let’s go two shades darker and use this #d7e2f1 for our hover color. Back in our code, let’s write:

app/assets/stylesheets/custom.css.scss
…
.table-hover tbody tr:hover {
  background-color: #d7e2f1;
}
Here, we’re selecting the <tr> nested inside <tbody> that’s itself nested inside our table-hover class. The :hover at the end means to activate this style only when a user is hovering over a table row.

Let’s save and take a look. Now if we hover over each row, we can see it’s 2 shades darker than our background image, which is what we wanted.

The final thing we’ll do is add a column to our table with thumbnail images of each apartment. That way, users can get a preview of what each apartment looks like before they click to go to the Show page.

We’ll go to our view page under app/views/posts/index.html.erb and we’ll create a new column heading in our table by adding <th>Preview</th>.

app/views/posts/index.html.erb
…
<thead>
  <tr>
    <th>Preview</th>
    <th>Heading</th>
    <th>Price</th>
    <th>Beds</th>
    <th>Baths</th>
    <th>Neighborhood</th>
    <th>Last Updated</th>
  </tr>
</thead>
…
Then we’ll choose the first image from each Craigslist post to display. We’ll write:

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td>
        <%= image_tag post.images.first.url, class: "thumbnail" %>
      </td>
      …
Here, post.images finds all the images that belong to this specific post, .first chooses the first one, and .url gives us the value in the ‘url’ column in our database. Finally, we’re adding Bootstrap’s thumbnail class at the end. Let’s save and see what happens.

Okay, we get an error here. It says “NoMethodError…undefined method `url’”. This is the same error we saw in a previous video and it means that our .url method couldn’t work because it’s being used on something that’s nil. If we look back at our code, we’ll see that .url is being called on post.images.first. This would only be nil if our Craigslist post happens to have zero images.

To fix this, let’s use an ‘if else statement’ to handle both cases. We’ll write:

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td>
        <% if post.images.empty? %>
          <%#= TO DO %>
        <% else %>
          <%= image_tag post.images.first.url, class: "thumbnail" %>
        <% end %>
      </td>
      …
When our Craigslist post has images available, then we’ll display the first one as usual. As for what we’ll do when there aren’t any images available, let’s use a default image instead. I’ve already found one online, so I’ll copy the link, and then write:

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td>
        <% if post.images.empty? %>
          <%= image_tag "{YOUR_DEFAULT_IMAGE}", class: "thumbnail" %>
        <% else %>
          <%= image_tag post.images.first.url, class: "thumbnail" %>
        <% end %>
      </td>
      …
Let’s save and go check it out. Well at least the images are now appearing. But these photos are bleeding out of their columns because the sizes of the actual images are so large. If we were hosting these images ourselves, we could use the paperclip or carrierwave gems to resize them. But they’re all stored online at different URLs, so unless we want to download them all and host them ourselves, this won’t be possible.

Instead, we’ll use a CSS workaround to solve this. We’ll go to our stylesheet and write:

app/assets/stylesheets/custom.css.scss
…
tbody {
  .thumbnail {
    width: 100%;
    height: 100%;
  }
}
The width and height set to 100% just means to resize the image to fit the width and height of its container, that way it won’t overflow out. Know that this CSS won’t preserve the aspect ratio of our images, but since we’ll only be seeing a thumbnail anyway, it won’t be nearly as noticeable as if it were a high-resolution, full-sized image. And like before, this CSS code only affects the thumbnail class that’s nested within our <tbody>.

Let’s save and refresh localhost. It’s much better, but the width and height are still much too big. Let’s write some inline CSS to style just this one table column.

In our index.html.erb, we’ll add a width="13%" and height="120px" for this column.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td width="13%" height="120px">
        …
In case you haven’t seen inline CSS before, it’s equivalent to going to our stylesheet and adding the CSS there. But sometimes we won’t need to reuse the CSS code, so this is an easy way to style a single HTML element without having to create a new class for it and adding it to our CSS stylesheet. This shortcut can be really handy for situations like these where we just want to style this one <td> tag.

Let’s save and take a look. Great, now it looks like a real thumbnail. You can play around with your dimensions here if you like. Try adjusting the width and height, either by % or by the number of pixels until you’re happy with the result.

There’s a margin underneath all the thumbnails here so let’s get quickly get rid of that by going to our stylesheet and adding margin-bottom: 0px;.

app/assets/stylesheets/custom.css.scss
…
tbody {
  .thumbnail {
    width: 100%;
    height: 100%;
    margin-bottom: 0px;
  }
}
Let’s save and refresh. Good, the margin is gone.

One more improvement we can make to this column is to change our thumbnail into a link to the Show page. The header is already a link, but I think it’s more intuitive for some people to use the image to get to the Show page as well. We’ll go to our view page and wrap our ‘if else statement’ with <%= link_to post_path(post) do %>. We’ll tab all this in and put an <% end %> at the bottom.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td>
        <%= link_to post_path(post) do %>
          <% if post.images.empty? %>
            <%= image_tag "{YOUR_DEFAULT_IMAGE}", class: "thumbnail" %>
          <% else %>
            <%= image_tag post.images.first.url, class: "thumbnail" %>
          <% end %>
        <% end %>
      </td>
      …
Now the entire thumbnail becomes a link to our Show page. Let’s save and go take a look. If we click on the image, we’re taken to the Show page. It works.

Our table is almost done. Let’s write some last few lines of inline CSS so we can align the content in the middle of our columns.

We’ll use the center CSS class that we set up previously for all our <th> tags so that our titles are centered within their columns.

app/views/posts/index.html.erb
…
<thead>
  <tr>
    <th class="center">Preview</th>
    <th>Heading</th>
    <th>Price</th>
    <th>Beds</th>
    <th>Baths</th>
    <th>Neighborhood</th>
    <th>Last Updated</th>
  </tr>
</thead>
…
Let’s copy this and add it to our other <th> tags as well.

app/views/posts/index.html.erb
…
<thead>
  <tr>
    <th class="center">Preview</th>
    <th class="center">Heading</th>
    <th class="center">Neighborhood</th>
    <th class="center">Beds</th>
    <th class="center">Baths</th>
    <th class="center">Price</th>
    <th class="center">Last Updated</th>
  </tr>
</thead>
…
Let’s also add a width="45%" to our <th> tag for the Post’s heading text. This will set the width of the column to prevent it from taking up too much space.

app/views/posts/index.html.erb
…
<thead>
  <tr>
    <th class="center">Preview</th>
    <th class="center" width="45%">Heading</th>
    …
Let’s save and see how that looks.

Great. Now let’s align the actual data in the table. We’ll keep the Post’s heading text as left-aligned and center the others. We’ll also want to vertically center everything. Let’s go to our code and add a class="center" to all the <td> tags after post.heading.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      …
      <td><%= link_to post.heading, post %></td>
      <td class="center"><%= number_to_currency(post.price, precision: 0) %></td>
      <td class="center"><%= post.bedrooms %></td>
      <td class="center"><%= post.bathrooms %></td>
      <td class="center"><%= post.neighborhood %></td>
      <td class="center"><%= "#{time_ago_in_words(Time.at(post.timestamp.to_i))} ago" %></td>
      …
Then, we’ll add a style="vertical-align:middle" to all of them, including the Post’s heading.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      …
      <td style="vertical-align:middle"><%= link_to post.heading, post %></td>
      <td class="center" style="vertical-align:middle"><%= number_to_currency(post.price, precision: 0) %></td>
      <td class="center" style="vertical-align:middle"><%= post.bedrooms %></td>
      <td class="center" style="vertical-align:middle"><%= post.bathrooms %></td>
      <td class="center" style="vertical-align:middle"><%= post.neighborhood %></td>
      <td class="center" style="vertical-align:middle"><%= "#{time_ago_in_words(Time.at(post.timestamp.to_i))} ago" %></td>
      …
Let’s save and take a look. Much better.

We did a lot in this video. We added a new column to our table with a thumbnail image of each apartment. We also set up a default image to display in case there weren’t any and then we converted all the thumbnails into links. We also styled the content inside our table with some inline CSS. In the next video, we’ll move on from the index page and add some styling to our Show page.

Structure Show Page:
Coming soon!

Style Show Page:
Coming soon!

8.Deploy And Automate
Refresh Our Data:
Coming soon!

Deploy On Heroku:
Coming soon!

Automate Rake Tasks:
Coming soon!

Conclusion:
Coming soon!




Yelp Demo Course Page:
1.Get Up And Running
Course Introduction:
Hello and welcome to BaseRails!

In this course, we’ll learn how to build a restaurant review site similar to Yelp. Let’s take a look at the final app we’ll be building. We’ll go to http://yelpdemo.herokuapp.com/. Here, we have a list of restaurants along with their address, phone number, and website info. We can search for specific restaurants and click on one to see its location in Google Maps and browse the reviews that have been written. To write a review, users need to register on our site and login with their email and password. Once they’ve signed in, they can write a review by choosing a star rating and adding some comments. Finally, we’ll give some users admin privileges, so they’ll be able to add additional restaurants and moderate the reviews that are being submitted.

In the process of building Yelpdemo, we’ll learn to use the latest versions of popular technologies. We’ll be working with Ruby on Rails, as well as front-end tools like Twitter Bootstrap and CSS. We’ll touch upon databases with SQLite, APIs with Google Maps, and even hosting platforms such as GitHub, Heroku, and Amazon S3.

Before we get started, let me quickly show you how to navigate around our site – it should be pretty intuitive. Below this video, you should see three tabs. The Transcript tab contains the word-for-word text for each video. The Notes tab has a summary of all the code we wrote for you to use as a quick reference. And the Discussion tab is a moderated forum where you’ll be able to see helpful tips from the instructor and other students taking the course.

If you get stuck at any point, just leave a comment in the Discussion section. In addition to a description of the problem, make sure you include all the information that will help us diagnose the issue, such as the operating system you’re using, the error messages you see, and what you’ve tried so far.

Now that you’ve had a chance to look around, we’re ready to get started in the next video, where we’ll tackle all the installations we’ll need to start coding on our computer.

Installation For Mac Users
Instalation For Non-Mac Users

2.Create Our Website
Create a New App
Add Our First Pages:
In the last video, we created our first Rails application. In this video, we’ll be adding our first pages.

Let’s open up our command line. Now we need to navigate to the folder for our app. If you don’t remember, you can type ls to list out the folders that you have available. Here we can see the yelpdemo folder that we created last time. We can navigate to that folder by typing cd yelpdemo.

Now that we’re in this folder, we can go ahead and create our first web pages. We’ll hold off on creating a home page for now, but almost all websites have an About page and a Contact page, so that’s what we’ll be making first.

In our command line, let’s type rails generate controller Pages about contact. This command is telling Rails to create a framework for these two pages that we want to build. These two pages will be called About and Contact. Hit enter.

Command Line
$ cd yelpdemo
$ rails generate controller Pages about contact
We see that Rails has created these files automatically for us and we can actually view these two new pages we’ve created by launching our Rails server. Unlike last time, instead of launching our Rails server within this tab we can open up a new tab. We’ll do this by going to Shell → New Tab. We first need to navigate to our app’s folder, so type cd yelpdemo. Now that I’m in this folder, I can type rails server, or even rails s for short.

Command Line
$ rails s
Now that the Rails server has launched, I can open the Google Chrome browser and go to localhost:3000. You’ll see that this is still the default home page we saw last time. Our new About page is located at localhost:3000/pages/about. It says ‘Find me in app/views/pages/about.html.erb’. This is the default page that Rails gives us. The same is true if we go to localhost:3000/pages/contact.

We can edit the content that we see here by using Sublime Text. We’ll use a shortcut and open up Sublime Text from our command line by going to our original tab and typing subl .. Alternatively, you could just open up the Sublime Text app separately.

Here are all our files. We can see the files for the two pages we just created by going to the app folder, under views and pages. You can see we have the About page and the Contact page that we just created. Let’s edit the Contact page first. The code here is written in a language called HTML. HTML structures our content using tags like <h1> and <p> to organize our text into headers, paragraphs, lists, and so on. In this file, we’re saying that this text is going to be a header and this text is going to be a paragraph. Every time you open a tag like <h1>, you need to close the tag at the end by putting a slash in front like </h1>.

Let’s change the text that’s here. I’ll put an <h1> tag, which says I want this to be a header, and I’ll type “We would love to hear from you!”. We’ll close this with </h1>. Let’s start a new paragraph and say “Contact us at alex@baserails.com” (or whatever email address you want). Finally, let’s add another paragraph with <p>Copyright Alex Yang</p> (of course, you should put your name, since this is your website!).

/app/views/pages/contact.html.erb
<h1>We would love to hear from you!</h1>
<p>Contact us at alex@baserails.com</p>
<p>Copyright Alex Yang</p>
I can save this using a Mac shortcut, Command-S, (or Control-S if you’re using Windows), and I can now view this by going to Google Chrome and refreshing the page.

Let’s do the same thing with our About page. We’ll go back to Sublime Text and open up the corresponding code file. This time I’ll write <h1>Welcome to Yelpdemo!</h1>. I’ll create a second header tag that’s a little smaller. I’ll write <h2>This is one of the sample applications for BaseRails, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>. Finally, I’ll add the same copyright as before: Copyright Alex Yang.

/app/views/pages/about.html.erb
<h1>Welcome to Yelpdemo!</h1>
<h2>This is one of the sample applications for BaseRails, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>
<p>Copyright Alex Yang</p>
I’ll save this and view my changes by going back to Google Chrome to localhost:3000/pages/about.

In this video, we learned how to generate new pages with the Rails generate command. You can see this by going back to our command line. The only command we used was this: rails generate controller Pages about contact. That’s all we needed to do to create our default About and Contact pages. Then we used our Sublime Text to edit the content on these pages. In the next video, we’ll be creating some links to connect these pages together.

Add Links:
In the last video, we created an About page and a Contact page. This time, we’ll create some links to navigate between these two pages.

First, if it’s not open already, let’s open up our command line. Navigate to the folder where the app is stored. I’ll type cd yelpdemo and I’ll do this for a second tab as well. The reason why I’m creating this second tab is because I want to make sure my Rails server is running in the background at all times. By typing rails s, which is short for rails server, I can make sure that I still have access to the command line in this first tab while my Rails server is running in the second tab. This is important because then when I go to Google Chrome, I can easily see the results of any changes I make to my code files. Let’s look at our current app by going to localhost:3000. Here’s the default home page that every Rails app comes with. The two new pages we added are at localhost:3000/pages/about and localhost:3000/pages/contact, where the text is the custom content we created last time.

But it’s inconvenient to edit the URL every time to access these pages. What I want is to add a couple links right up on top so I can more easily navigate my app. To do this, I first need to open up my Sublime Text. A shortcut to do this is to go to my command line and type subl .. Let’s go back to the code that we have for the two pages that we created. You can find these under app/views/pages/about and app/views/pages/contact.

We want to add two links at the top of each page: one link to the About page and one link to the Contact page. We can add that in by using HTML. Here I’m going to put the HTML for creating links: I’ll type <a href="/pages/about">About</a>. Here, the <a> is a tag just like the header and paragraph tags we saw last time, except that the <a> tag is used for links. This href= is used to put the page the link directs to, and this About is the link text that users will see. Don’t worry too much about understanding the syntax for now – it’s most important to understand what’s going on at a high level.

I’ll create a second link to the Contact page: <a href="/pages/contact">Contact</a>.

/app/views/pages/contact.html.erb
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<h1>We would love to hear from you!</h1>
<p>Contact us at alex@baserails.com</p>
<p>"Copyright Alex Yang"</p>
I’ll save this file, copy both links, paste them at the top of our code file for the About page, and save this as well.

/app/views/pages/about.html.erb
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<h1>Welcome to Yelpdemo!</h1>
<h2>This is the one of the sample applications for BaseRails, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>
<p>"Copyright Alex Yang"</p>
Let’s see these changes by going back to Google Chrome and refreshing the page. We’re able to do this because our Rails server is still running in the background. Here we have our Contact page and the two new links we created. Let’s test out the link to our About page. Now let’s try the link to the Contact page. Looks like it’s working!

Now that we’ve seen how to set up links to other pages on our site, let’s see if we can create a link to an external site. We’ll go back to Sublime Text and look at the code for our About page. We’re going to convert the word BaseRails into a link. Let’s copy the link code we used earlier and modify it. Instead of “About”, we want this link to read “BaseRails”. And instead of “/pages/about”, we’ll replace the link route with 
“http://www.baserails.com/”. Notice that we had to include the “http” in front because this is an external URL.

/app/views/pages/about.html.erb
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<h1>Welcome to Yelpdemo!</h1>
<h2>This is the one of the sample applications for <a href="http://www.baserails.com/">BaseRails</a>, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>
<p>"Copyright Alex Yang"</p>
Now let’s test this out. I’ll save this file, open up my browser, and go to the About page. If I click on the BaseRails link, you can see it works.

Before we finish, let me show you one last thing. We’ve inserted two navigation links at the top of each page, but you’ll notice that the code for the links is identical. When you start building websites with hundreds of pages, it can become really tedious to update each individual page separately. Whenever we have common code, we want to be able to put that in a single, common location. For situations where we want something to be applied to every page, we can add this code to a file called the Application Layout file. You see this file under app/views/layouts/application.html.erb. If you look at this closely, you’ll see that inside these body tags, there’s a line that says <%= yield %>. What this does is pull in the page-specific code and inserts it right here. All the code that we have in the About file or the Contact file will get pulled in and inserted right here.

To simplify things, let’s take the common link code for both pages and place it in the Application Layout file instead. I’ll cut it out from the About page, save the file, do the same with the Contact page, and save again. Now I’ll paste it back in right above the <%= yield %>. The reason why I’m pasting it above is because I want it to appear on top of the other content.

/app/views/pages/about.html.erb
<h1>Welcome to Yelpdemo!</h1>
<h2>This is the one of the sample applications for <a href="http://www.baserails.com/">BaseRails</a>, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>
<p>"Copyright Alex Yang"</p>
/app/views/pages/contact.html.erb
<h1>We would love to hear from you!</h1>
<p>Contact us at alex@baserails.com</p>
<p>"Copyright Alex Yang"</p>
/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Yelpdemo</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
</head>
<body>
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<%= yield %>
</body>
</html>
Let’s save this file and go back to our About page.

As expected, we see the same links as before. It’s just that now the code for those links appears on a common page, as opposed to each page individually.

Let’s go back to our Sublime Text and we see in our About and Contact code files that we still have this copyright text that’s the same on both pages. Let’s also move those into the Application Layout file. I’ll cut it out from each file, and save both. Now I’ll paste it below the <%= yield %> this time because I want it to appear at the bottom of the page.

/app/views/pages/about.html.erb
<h1>Welcome to Yelpdemo!</h1>
<h2>This is the one of the sample applications for <a href="http://www.baserails.com/">BaseRails</a>, a platform that teaches people to build awesome custom websites with the Ruby on Rails programming language.</h2>
/app/views/pages/contact.html.erb
<h1>We would love to hear from you!</h1>
<p>Contact us at alex@baserails.com</p>
/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Yelpdemo</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
</head>
<body>
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<%= yield %>
<p>"Copyright Alex Yang"</p>
</body>
</html>
Let’s save this file and go back to our browser. If we refresh, sure enough the copyright is still here.

In this video, we learned how to add links to our pages using HTML. We also learned that we can simplify our code files by adding common elements to our Application Layout file. In the next video, we’ll allow users to add new restaurants to our site’s directory.

Add Restaurants:
In the last video, we added links to our About and Contact pages. We simplified our code by replacing repetitive content in a common Application Layout file. In this video, we’ll give users the ability to add restaurants to our site’s directory.

First, I’ll go ahead and open up my command line. I’ll navigate to the folder where my app is stored by typing cd yelpdemo. I’ll also start my Rails server in a second tab.

To allow users to add restaurants, I need to type the following command: rails generate scaffold Restaurant name:string address:string phone:string website:string. Hit enter.

Command Line
$ cd yelpdemo
$ rails generate scaffold Restaurant name:string address:string phone:string website:string
You can see that again, Rails has created a lot of different files for us. One of these files is this db/migrate file. This file is called a migration. When we add new restaurants, we need to have a database to store the information about them. We give Rails instructions on what information to store and these instructions are called migrations. Any time we change our database, whether we’re adding a new field or changing an existing field, we need to create a new migration.

Whenever we deal with migrations, we need to remember that it’s always a three-step process. The first step is to generate the migration in Rails, as we did just now. We told Rails that we wanted to store the name, address, phone, and website for each of the Restaurants we’ll be adding.

After creating the migration, the second step is to use a command called rake db:migrate, which will take the instructions from our migration and run them by actually creating the database tables or new columns that we want.

Command Line
$ rake db:migrate
The final step is to restart our Rails server. We do that by going to our second tab where our Rails server is running, and pressing Control-C to shut it down, and then rails s again to restart it. Unless we restart our Rails server, we won’t be able to see any of the database changes that were made.

Command Line
$ rails s
Migrations may seem a little complicated now, but just remember the three-step process. First, we generate the migration. Then we run rake db:migrate. Finally, we need to restart our server.

Now let’s open up our Google Chrome browser to see the pages that Rails has created for us. We’ll go to localhost:3000/restaurants/new. You’ll see this is a whole new page that Rails has created and this page allows us to create a new Restaurant and add it to our site. Let’s try it out. We’ll add a new restaurant called Test Cafe at 123 Fake Street, New York, NY 10001 with a phone number of (123) 456-7890 and a website of http://www.testcafe.com/.

After clicking “Create Restaurant”, we’ll be taken to a page that shows the Restaurant we just created. We can click ‘Back’ to see that we now have links to show, edit, and destroy this Restaurant. Let’s try editing it. We’ll update the address to say 123 Fake Avenue instead. We can update it to see that it’s changed. We can also go back and even destroy this Restaurant.

So to recap, in this video we first used the rails generate scaffold command to create a database for our Restaurants. This command also generated some default pages for us to create, view and edit our Restaurants.

Now that we’ve given users the ability to add Restaurants on our site, you should take some time to add 3 Restaurants of your own. Make sure you don’t spend too much time perfecting these because in a later section, we’ll need to add images for each Restaurant and that will require us to start this list from scratch. In the next video, we’ll see how to make this page our home page.

Set The Home Page:
Since the last video, I’ve added 3 Restaurants to our site. If you haven’t done so yet, pause the video here and add some Restaurants of your own. Alright, the next thing we’ll do is replace the default Rails home page with this page, which is an index of all the Restaurants that have been added. To do that, since my command line is already up, I’ll type subl . to open Sublime Text.

We can find the file to set our home page under config/routes.rb. If we open up this file, we can see that some of the code here is grayed out. These grayed-out lines are called comments. The hashtag at the beginning of the line tells us that this code is inactive and purely informational. To set our home page, you can see there are some instructions here. You can have the home page, or root of your site routed with this command. I’ll write: root 'restaurants#index'.

/config/routes.rb
Rails.application.routes.draw do
  resources :restaurants

  get 'pages/about'

  get 'pages/contact'

  root 'restaurants#index'
  …
end
Now how did I know to do restaurants#index? We can figure this out using something called routes. You need to understand routes because they tell you which URLs are matched to which pages. Rails lets us see all the URLs for a site by running a command called rake routes. Let’s go back to our command line and run rake routes now.

Command Line
$ rake routes
Here, you can see all the available URLs that belong to our site. For example, we can visit localhost:3000/restaurants to see a page that looks like this. We can also go to localhost:3000/pages/about to get to our About page. But if instead we try to go to a URL that doesn’t exist in this table, such as localhost:3000/books, we’re going to get an error. Let’s try that out in our browser – we’ll go to localhost:3000/books. You can see it says ‘No route matches [GET] “/books”’.

Let’s go back to our restaurants homepage at "localhost:3000/restaurants:localhost:3000/restaurants. This is the URL for the page showing an index of all our restaurants. This corresponds to something called a controller action, which we can see in rake routes.

You can see ‘/restaurants’ in this first row corresponds to a controller action called ‘restaurants#index’, and that’s exactly what we put into our config/routes.rb file in Sublime Text. I’ll save this.

Don’t worry about understanding exactly what controller actions are for now, but know that it’s what you’ll use whenever you want to change your URLs.

Now that we’ve set up our home page, we can go back to our browser and check that it works by going to localhost:3000. We’re taken to the main Restaurants page – it’s working!

While things may be functioning, our restaurants aren’t formatted very well. In the next section, we’ll add some front-end design to improve the look and feel of our website.


3.Get Started With Bootstrap
Install Bootstrap:
In the last video, we set our home page to be our main Restaurants index page. In this video, we’ll focus on installing Bootstrap, an awesome front-end tool to make your website look sleeker and more professional. If you haven’t heard of front-end or back-end before, you can think of front-end as the look and feel of a site’s design while back-end is the functionality of the website itself. Bootstrap is a collection of preset style features that we can incorporate into our own website. There’s a pretty wide range to choose from and you can just pick and choose from the features you need.

Let’s visit the Bootstrap website to see how to set it up. I’ll go to www.getbootstrap.com and click on the ‘Getting started’ tab. Under ‘Download’, you’ll see that there are multiple ways to install Bootstrap. The simplest approach is to do this is to follow the instructions for the Bootstrap CDN. All we need to do is click ‘Copy’ to copy these lines of code and assuming you already have your Sublime Text open, we’ll go to our Application Layout file under app/views/layouts/application.html.erb and paste it in right before the closing <head> tag. I’ll then tab these over so they’re in line with the code above.

/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Yelpdemo</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">

  <!-- Optional theme -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">

  <!-- Latest compiled and minified JavaScript -->
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
</head>
<body>
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<%= yield %>
<p>"Copyright Alex Yang"</p>
</body>
</html>
If you remember from before, the Application Layout file is the place where we put common code that’s needed for all the pages on our site. We’re placing this Bootstrap CDN code here so that the Bootstrap designs will be available for all our pages.

Let’s test it out now. Assuming that your Rails server is already running, we can go directly to our browser and refresh the page. As you can see, the Bootstrap styles we installed have already made some slight changes. The spacing on this table still looks pretty bad though, so let’s go back to the Bootstrap website to see what kind of table options they have.

This time, I’ll go to the ‘CSS’ tab. As you can see on the right, Bootstrap provides many front-end options you can incorporate into your site, with sections covering nearly everything you can think of: typographies, code formatting, tables, forms, buttons, and more. We’ll click on the ‘Tables’ section. It starts with a basic example with some brief introductions on top and sample code down below. There are lots of different options, but in the basic example, all we need to do is add the base class table.

To integrate this into our own table, we first need to go to the code file corresponding to our main Restaurants index page. We can find this under app/views/restaurants/index.html.erb. Near the top, we already have this <table> tag, so let’s edit this to say <table class="table">.

/app/views/restaurants/index.html.erb
<h1>Listing restaurants</h1>

<table class="table">
  …
With just that small change, we’ll save and see the result in our browser. Refreshing the page, you can see how big of a difference that made.

Let’s try out a couple of the other table options that Bootstrap provides. If we scroll down, we can see there are options for striped rows and borders. One of my favorites is ‘hover rows’. Setting this up is just as easy as before. In addition to our table class, I’ll add an additional table-hover class as well.

/app/views/restaurants/index.html.erb
<h1>Listing restaurants</h1>

<table class="table table-hover">
  …
After saving, we can refresh our browser page and see that our table rows now turn gray when we hover over them.

The cool part about Bootstrap features is that you can layer options on top of one another. Let’s say that I want both ‘hover rows’ and a ‘condensed table’. Then I’ll just tack on a table-condensed.

/app/views/restaurants/index.html.erb
<h1>Listing restaurants</h1>

<table class="table table-hover table-condensed">
  …
I’ll save, refresh the page, and I’m done.

If you think about how much Bootstrap can simplify the design of our tables, and imagine that same power applied to forms, buttons, page layouts, and more, it’s easy to see why Bootstrap is the most popular front-end framework on the web.

To summarize what we’ve done, in this video, we installed Bootstrap using the CDN links that we placed in our Application Layout file and we used Bootstrap to upgrade the look of our tables. Next time, we’ll see how to move our About and Contact links into a navigation bar at the top of our site.

Add a Navigation Bar:
In the last video, we installed Bootstrap and applied its powerful front-end styling to the table on our Restaurants index page. We’ll use Bootstrap again this time to add a navigation bar to the top of our site. This navbar will contain the About and Contact links we created before.

Whenever we add a new feature for the first time, it helps to read the documentation or the instructions. In this case, we’ll go to the Bootstrap website at www.getbootstrap.com and go to the ‘Components’ tab at the top. On the right, we’ll select the Navbar section. Just like with tables, we start with a default navbar that looks like this. You can see the code to create this looks a little scary but that’s because the navbar is cluttered with many links, dropdown menus, and a search bar. When we remove the pieces we don’t need, the code will become much simpler.

First, let’s copy this code. We want to include this navbar on every page of our site, so let’s paste this into our Application Layout file. With my Sublime Text open, I’ll go to app/views/layouts/application.html.erb and paste it in, right below the <body> tag. I’ve put it at the top of the <body> section because I want it to show up at the top of the page.

/app/views/layouts/application.html.erb
…
<body>
<nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Brand</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Link</a></li>
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li class="divider"></li>
            <li><a href="#">Separated link</a></li>
            <li class="divider"></li>
            <li><a href="#">One more separated link</a></li>
          </ul>
        </li>
      </ul>
      <form class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">Dropdown <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu">
            <li><a href="#">Action</a></li>
            <li><a href="#">Another action</a></li>
            <li><a href="#">Something else here</a></li>
            <li class="divider"></li>
            <li><a href="#">Separated link</a></li>
          </ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
<a href="/pages/about">About</a>
<a href="/pages/contact">Contact</a>
<%= yield %>
<p>Copyright Alex Yang</p>
</body>
</html>
Let’s see what this looks like now. I’ll save, and with my Rails server already running, I’ll go directly to my browser and refresh the home page. There we go – the default Bootstrap navbar appears at the top.

Now let’s customize it. We don’t need a lot of these elements, so we’ll remove them one-by-one. First, let’s get rid of this dropdown menu. We’ll go to our code, and if we look carefully, we’ll see that there’s this <li class="dropdown"> followed by all of these dropdown menu options. The “Action”, “Another action”, and “Something else here” corresponds to what we see when we open the dropdown menu in our browser. So to remove this, all we need to do is delete everything from the <li class="dropdown"> to the closing </li> tag. We’ll save this, refresh the page, and see that the dropdown is now gone. We’ll do the same thing to remove the dropdown on the right.

/app/views/layouts/application.html.erb
  …
  <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="active"><a href="#">Link</a></li>
        <li><a href="#">Link</a></li>
      </ul>
      <form class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="#">Link</a></li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
… 
With both of those gone, let’s now remove the link on the right. We’ll find the code for this link right under the <ul class="nav navbar-nav navbar-right">. Let’s save and refresh – ok it’s gone.

/app/views/layouts/application.html.erb
      …
      <ul class="nav navbar-nav navbar-right">
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
… 
Let’s also get rid of the gray background behind this first link. If we compare the code for these two links under <ul class="nav navbar-nav">, we’ll see that the only difference is that the first link has an extra class="active", so we’ll delete that and save.

/app/views/layouts/application.html.erb
  …
  <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="#">Link</a></li>
        <li><a href="#">Link</a></li>
      </ul>
      … 
Let’s keep the Search bar (even though it doesn’t work yet) because we’ll want it later on to search for Restaurants in our database. Instead, let’s customize these two links to take us to our About and Contact pages. We’ll edit the link text by replacing the word “Link” with “About” and “Contact”. But to make the links take us to the right page, we’ll need to do more than change the link text – we’ll have to set the link route as well. Let’s copy the route for our existing ‘About’ link and paste it to replace this hashtag. We’ll do the same for our ‘Contact’ link.

/app/views/layouts/application.html.erb
  …
  <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/pages/about">About</a></li>
        <li><a href="/pages/contact">Contact</a></li>
      </ul>
      … 
Let’s save, go back to our site, and refresh. Now if we click on the ‘About’ link, it takes us to the ‘About’ page. Click on the ‘Contact’ link, and it takes us to the ‘Contact’ page. This already looks much nicer than what we had a few minutes ago.

But there’s one more thing we should do. Instead of ‘Brand’, we want our navbar to say the name of our app. It would also be nice to have this function as a button to the home page. Back in our code, we can find the word ‘Brand’ and replace it with ‘Yelpdemo’. We’ll also replace this # with simply a /, as this is the route to the home page. Let’s save, refresh, and test it out. It works!

/app/views/layouts/application.html.erb
…
<nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Yelpdemo</a>
    </div>
    …
With our navbar set up, our old ‘About’ and ‘Contact’ links are no longer needed. Let’s delete those as well and save.

/app/views/layouts/application.html.erb
…
</nav>
<%= yield %>
<p>Copyright Alex Yang</p>
</body>
</html>
As you can see, with Bootstrap, we were able to quickly put together a nice-looking navbar. However, with all the code we added, our Application Layout file is starting to get cluttered, so in the next video, we’ll see how to clean up and organize our code to make it more manageable.

Simplify Our Code:
So far, we’ve used Bootstrap to customize our tables and add a navbar to our site. This time, we’ll simplify our code by using something called partial templates.

You can see that after adding all this navbar code, our Application Layout file is starting to look a little cluttered. It’s a good habit to have concise code for two reasons. First, it’s easier to spot typos and mistakes. You’ll realize how important this is once a rogue punctuation mark causes you to waste hours trying to debug your code. The second reason is that simple code is a lot more readable. You’d be surprised how difficult it can be to understand complicated code you wrote a couple months ago. To help with this, we’ll use partial templates, which are usually shortened as just partials.

Partials allow us to store big chunks of code like this one in a separate file, which allows your main file to stay compact and readable. We’ve actually seen something similar with the yield statement. If you remember, this yield statement allows us to take the page-specific code that we have under app/views/pages, and it inserts it in here.

To add a new partial, we’ll create a new file in the layouts folder. We’ll right-click and select ‘New File’. All partials start with an underscore (this is how Rails knows it’s a partial). Let’s call ours _navbar.html.erb. Let’s now move our navbar code into our newly created partial and save both files.

/app/views/layouts/_navbar.html.erb
<nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Yelpdemo</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="/pages/about">About</a></li>
        <li><a href="/pages/contact">Contact</a></li>
      </ul>
      <form class="navbar-form navbar-left" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search">
        </div>
        <button type="submit" class="btn btn-default">Submit</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>
With our navbar code stored away, we now need to tell Rails when to use it. Back in our Application Layout file, where the navbar code once was, we’ll write the following: <%= render 'layouts/navbar' %>. This tells Rails to pull in the code in the navbar partial in the layouts folder.

/app/views/layouts/application.html.erb
…
<body>
<%= render 'layouts/navbar' %>
<%= yield %>
<p>"Copyright Alex Yang"</p>
</body>
</html>
You’ll notice that I’m using these open and close tags with percent signs in them. We need this whenever we use something called Embedded Ruby, or erb for short. Embedded Ruby is one of the most powerful features of Rails. It allows us to use all the features of Ruby code while inside an HTML file. That means we can do dynamic things like run calculations, convert foreign currency, and automate repetitive tasks, all of which we couldn’t do using HTML alone.

You’ll also notice that the extension of many of our files is .html.erb. This means we can include both HTML code and Embedded Ruby in the same file. When the browser looks at the code for the page, the Embedded Ruby will actually be converted into HTML code so the file will appear to be a normal HTML file.

To distinguish between the HTML and the Embedded Ruby we write, we have to use these opening and closing tags to tell Rails when we’re writing erb. It’s important to know that there are two kinds of opening erb tags. We’ll use <%= with an equals sign when we want the Embedded Ruby to physically show up on the page, like when we add a link or a navbar. We’ll remove the equals sign when there’s no result to be shown, like when you’re creating a variable or starting a loop. In either case, you always end with this closing tag without the equal sign, %>. We’ll see many more examples of this later on, so you’ll have plenty of time to get the hang of it.

Let’s save this file and since I already have my Rails server running, let’s open up our browser and refresh the page. As we expected, our navbar is still on top. That’s because the navbar code is still there – it’s just moved into a different file.

Let’s now do the same thing for our copyright text. While it’s only one line right now, it might become bigger in the future, so let’s create another partial called _footer.html.erb. We’ll move the copyright code into this new file, save it, and use similar code from earlier to render the partial in our Application Layout file. Let’s save and test it out. Looks good!

/app/views/layouts/_footer.html.erb
<p>"Copyright Alex Yang"</p>
/app/views/layouts/application.html.erb
…
<body>
<%= render 'layouts/navbar' %>
<%= yield %>
<%= render 'layouts/footer' %>
</body>
</html>
Let’s do this once more for our Bootstrap CDN code. I’ll create yet another partial file. I’ll call this _bootstrap.html.erb. And I’ll take the code that we put in earlier and I’ll place it in our new partial. I’ll save and call the same render statement up here. And I’ll save. There we go.

/app/views/layouts/_bootstrap.html.erb
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">

  <!-- Optional theme -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap-theme.min.css">

  <!-- Latest compiled and minified JavaScript -->
  <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
/app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Yelpdemo</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
  <%= render 'layouts/bootstrap' %>
</head>
…
Alright, that’s all for this video. Now that we’ve cleaned up our code, we’re ready for the next video, where we’ll be making a massive upgrade to the look and feel of our forms.

Build Beautiful Forms:
In the last video, we organized and simplified our code by storing pieces of it in files called partials. In this video, we’ll look to Bootstrap once more, this time to transform the look of our Restaurant forms.

Let’s first see how our forms currently look. Since my Rails server is already running, I’ll open my browser directly and go to localhost:3000. We can access one of the forms by clicking on the ‘Edit’ link. We can see that it’s pretty bad. Not only is there no margin on the left side, but the input fields are boxy and the button is very plain.

Let’s improve this. We can find the code for this page under app/views/listings/edit.html.erb, but you’ll notice that there’s no form code here. Instead, it says render 'form'. If you remember from the last video, this render statement was what we used to pull in our partial code. If we look in our restaurants folder, sure enough, we’ll see that there’s a _form.html.erb file. The underscore in front tells us that this is a partial. Opening this file, we can now see all the code used to create our form, with individual sections for the name, address, phone, and website fields.

This is the form that Rails automatically generated for us when we initially ran rails generate scaffold Restaurant to allow our users to add restaurants. To improve this look, let’s see what the Bootstrap documentation says about forms. Let’s go to the Bootstrap home page at www.getbootstrap.com. We’ll go to the ‘CSS’ tab, and click on ‘Forms’ on the right side. Under the basic example, it says: “Individual form controls automatically receive some global styling. All textual <input>, <textarea>, and <select> elements with .form-control are set to width: 100%; by default.”

This means that your form will stretch across the entire page by default. When you see a dot like the one in front of form-control, this means it’s a class. In CSS, a class is a way of assigning categories to your code so you can assign the same styles to multiple elements at once. In this case, Bootstrap has assigned the class form-control with preset CSS styles, which means any time we add this class to our code, all the styling will appear. The power of Bootstrap is that just by adding this class, we can assign all the styling without having to write the CSS code ourselves.

For our form, we want to set all our form inputs to have class form-control. The documentation also says that we should wrap labels and controls in a class called form-group for optimum spacing.

Let’s do both of those things now. But unlike last time when we added a Bootstrap navbar, this time we can’t just copy over the code that we see below. This is because the form isn’t simple HTML. Going back to our Sublime Text, we see it contains lots of embedded Ruby, which we can identify from these special opening and closing tags.

This time, instead of copying the Bootstrap code, we’ll follow the Bootstrap instructions to customize our existing code. Let’s do these two things one at a time. First, let’s add this form-control class to our inputs fields. Going back to our code, we’ll see a few of these f.text_field lines. It’s these lines that we need to edit. So in erb, the syntax to add a class is to add a comma at the end, then put class: "form-control". Let’s do this for each of our 4 text_field lines.

/app/views/restaurants/_form.html.erb
…
  <div class="field">
    <%= f.label :name %><br>
    <%= f.text_field :name, class: "form-control" %>
  </div>
  <div class="field">
    <%= f.label :address %><br>
    <%= f.text_field :address, class: "form-control" %>
  </div>
  <div class="field">
    <%= f.label :phone %><br>
    <%= f.text_field :phone, class: "form-control" %>
  </div>
  <div class="field">
    <%= f.label :website %><br>
    <%= f.text_field :website, class: "form-control" %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
…
Let’s save this file and see what we have. If we refresh the page, we can see some changes immediately. Our input fields now have nice, rounded edges and stretch across the width of the entire page. We even have a blue border automatically highlighting the first input field. Let’s move on to the second step to improve our form spacing.

Back on the Bootstrap website, it says we need to wrap labels and controls in this class form-group. In the example below, we’ll see a <div class="form-group"> at the start of each input section. Going to our code, we’ll replace each of our <div class="field"> with <div class="form-group"> as they suggest. Let’s save and take a look. After refreshing the page, the only change is that the vertical spacing expanded slightly. It’s not a big difference, but our form is a little more comfortable now.

/app/views/restaurants/_form.html.erb
…
  <div class="form-group">
    <%= f.label :name %><br>
    <%= f.text_field :name, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :address %><br>
    <%= f.text_field :address, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :phone %><br>
    <%= f.text_field :phone, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :website %><br>
    <%= f.text_field :website, class: "form-control" %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
…
What other improvements can we make to this page? Well, this button isn’t great. Let’s see what Bootstrap has on buttons. Underneath Forms, we’ll see a section on Buttons. For each of the different types of buttons, we’ll see the code used to generate them below. So just as we did with our form, we’ll need to customize the button code we already have. For example, to add this ‘Primary’ button, we’ll use this class btn btn-primary. Let’s go back to our code and after f.submit, let’s write with no comma this time, class: btn btn-primary". We’ll save and take a look. There we go – now it looks a lot nicer.

/app/views/restaurants/_form.html.erb
…
  <div class="form-group">
    <%= f.label :name %><br>
    <%= f.text_field :name, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :address %><br>
    <%= f.text_field :address, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :phone %><br>
    <%= f.text_field :phone, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :website %><br>
    <%= f.text_field :website, class: "form-control" %>
  </div>
  <div class="actions">
    <%= f.submit class: "btn btn-primary" %>
  </div>
…
Let’s upgrade our links as well. If we go back to the button section of the Bootstrap documentation, we’ll see that they also provide some code for updating our links. The code to create this uses class btn btn-link. Back in our code, we’ll see that the links don’t appear in our form partial. Instead, we’ll see them in the original edit.html.erb file. At the end of this ‘Show’ link, which is written in erb, let’s put a comma and class: "btn btn-link". We’ll do the same thing for the ‘Back’ link. Let’s save and test it out. Great!

/app/views/restaurants/edit.html.erb
…

<h1>Editing restaurant</h1>

<%= render 'form' %>

<%= link_to 'Show', @restaurant, class: "btn btn-link" %> 
<%= link_to 'Back', restaurants_path, class: "btn btn-link" %>
…
This ‘Edit Restaurant’ form is looking pretty good, with upgraded input fields, spacing, buttons, and links. The margin can still be improved, and we’ll fix that in a moment. But first, let’s take some time to upgrade the other Restaurant-related pages on our site. If we click ‘Back’, we’ll get to our Restaurant index page. While there’s no form here, we can improve the links. The code for this page is under index.html.erb. There’s a lot of Embedded Ruby here, but we’ll see the code for the ‘Show’, ‘Edit’, and ‘Destroy’ links near the bottom. For each of these, we’ll add a comma and class: "btn btn-link" right before the closing Ruby tag. Let’s save and go back to our browser.

/app/views/restaurants/ index.html.erb
…
<tbody>
  <% @restaurants.each do |restaurant| %>
    <tr>
      <td><%= restaurant.name %></td>
      <td><%= restaurant.address %></td>
      <td><%= restaurant.phone %></td>
      <td><%= restaurant.website %></td>
      <td><%= link_to 'Show', restaurant, class: "btn btn-link" %></td>
      <td><%= link_to 'Edit', edit_restaurant_path(restaurant), class: "btn btn-link" %></td>
      <td><%= link_to 'Destroy', restaurant, method: :delete, data: { confirm: 'Are you sure?' }, class: "btn btn-link" %></td>
    </tr>
  <% end %>
</tbody>
…
With the index page cleaned up, let’s move on to the Restaurant Show page. Let’s upgrade the ‘Edit’ and ‘Back’ links. The code for this page is under show.html.erb. We’ll do the same thing as before.

/app/views/restaurants/show.html.erb
…
<p>
  <strong>Website:</strong>
  <%= @restaurant.website %>
</p>

<%= link_to 'Edit', edit_restaurant_path(@restaurant), class: "btn btn-link" %> |
<%= link_to 'Back', restaurants_path, class: "btn btn-link" %>
The last page we haven’t checked is the New Restaurant page. We’ll notice that this page is already using the upgraded form, but the links below are still the same. This is because our new.html.erb code file renders the same form partial as our Edit Restaurant page. In this case, having the form stored in a single location saves us from having to go through the same process a second time. Let’s edit this ‘Back’ link by adding a comma and class: "btn btn-link". Let’s save and now we’ve updated all our Restaurant pages.

/app/views/restaurants/new.html.erb
…
<h1>New restaurant</h1>

<%= render 'form' %>

<%= link_to 'Back', restaurants_path, class: "btn btn-link" %>
One last thing I’d like to do is fix the margins. Fortunately, Bootstrap gives us an easy way to do that. Back on the documentation page, under “Overview”, there’s a section called “Containers”. These containers do a couple things for us. First, they’ll help us add some comfortable margins to our site. Second, they’ll make our site responsive. Responsiveness is important because it means that users will all see a similar version of your site, regardless of their screen size and whether they’re using a desktop, laptop, tablet, or mobile phone. This is a pretty deep topic area, but one of the easiest things we can do is add a Bootstrap container. There are two that we can choose from: a regular container class and a container-fluid class. It’s probably easiest to show you the difference through an example.

In the regular container example, you can see the width of our content jumps to certain preset dimensions as my screen size changes. In the container-fluid example, our content expands and shrinks fluidly with my screen size. There’s no right or wrong answer here, but let’s go with the container-fluid option for now. We want all our content below the navbar to have a margin, so let’s go to our Application Layout file under app/views/layouts/application.html.erb and below our navbar we’ll put a <div class="container-fluid">. And we’ll make sure to close this <div> right before the ending <body> tag. I’ll also make sure to tab everything over to make sure I have proper tabbing. And I’ll save.

/app/views/restaurants/ application.html.erb
…
</head>
<body>
  <%= render 'layouts/navbar' %>
  <div class="container-fluid">. 
    <%= yield %>
    <%= render 'layouts/footer' %>
  </div>
</body>
</html>
The reason why we keep the navbar outside of our "container-fluid" class is because we want our navbar to have no margin; we want it to stretch all the way across the page.

Going back to our site, we’ll see that now the margin issue has been fixed and we have the added benefit of a fluidly responsive site. Pretty cool!

Now that we’ve used Bootstrap to get our basic site looking good, in the next section, we’ll see how to put both our code and our site itself live on the web.

4.Launch Our Site
Set Up GitHub
Save Our Progress
Deploy on Heroku

5.Add Images
Add the Carrierwave Gem
Image Hosting With Amazon S3
Protect Our Passwords:
Last time, we set up online file hosting with Amazon S3 in order to get images to work on Heroku. However, we weren’t able to test that it worked because we ran into a problem. We needed to pass our confidential Amazon S3 account information to Heroku without having it show up on GitHub for anyone to see. In this video, we’ll set up a gem called Figaro that will help us do exactly that.

Let’s go to the gem page for the Figaro gem. We should be able to find it with a quick Google search. Just like we’ve done in previous videos, let’s read the gem documentation on how to install and set this up.

This gem is actually in the process of being updated to a new version and the documentation here reflects the version that’s still in beta. We’ll click on this link to use the documentation for the current version instead.

Under ‘Give me an example’, we’ll add this gem to our Gemfile. After saving, we’ll follow the standard process for installing the gem by going to our command line and running bundle install. We’ll also remember to restart our Rails server.

/Gemfile
…
gem "figaro"
Command Line
$ bundle install 
Restart your server if necessary

Command Line
$ rails s
Back on the gem page, we can see the next step is to run this command. Let’s copy it over and paste it in.

Command Line
$ figaro install # if you're using Figaro v1.0
$ rails generate figaro:install # if you're using Figaro v0.7
This has created a new file for us under config/application.yml. Let’s go check it out. The first thing we’ll notice is that this is a file extension we haven’t seen before. We’ve seen .rb files for Ruby code and .html.erb files for HTML code with Embedded Ruby, but this .yml extension is a new one. This is known as a YAML file, which is often used to hold data in the form of key-value pairs. That’s just a fancy way of saying that each line of code will follow the pattern of SOME_KEY: SOME_VALUE.

Let’s copy over our AWS account credentials now by opening our config/initializers/carrierwave.rb file. We’ll need the aws_access_key_id, aws_secret_access_key, and bucket name. Make sure you follow the key-value pattern precisely. YAML files are sensitive to spaces and tabbing, so even just omitting the space after the colon will cause problems.

/config/application.yml
…
aws_access_key_id: 'YOUR_KEY_ID' 
aws_secret_access_key: 'YOUR_SECRET_KEY'
fog_directory: 'YOUR_BUCKET_NAME'
With our account credentials now in this protected Figaro file, we can replace the hard-coded passwords with a reference to our Figaro ones. To do that, we’ll write capital ENV["KEY_NAME"]. I’ll do the same for the other two.

/config/initializers/carrierwave.rb
CarrierWave.configure do |config|
  config.fog_credentials = {
    :provider               => 'AWS',                        # required
    :aws_access_key_id      => ENV["aws_access_key_id"],                        # required
    :aws_secret_access_key  => ENV["aws_secret_access_key"],                        # required
  }
  config.fog_directory  = ENV["fog_directory"]                    # required
end
Our last step in setting up Figaro is to tell Heroku about these account credentials. The Figaro gem provides a command for this under the section called ‘How does it work with Heroku’. Let’s copy that over now.

Command Line
$ figaro heroku:set -e production # if you're using Figaro v1.0
$ rake figaro:heroku                       # if you're using Figaro v0.7
With Figaro set up, we’re finally ready to save our work, push our code to GitHub, and launch our site on Heroku. We’ll first run git status to see the changes we’ve made since we last saved. We’ll now run $ git add . to prepare these changes to be saved. Then git commit –m with the message Add images with carrierwave, S3, and Figaro will save our changes.

Now that we’ve saved, we can push our code to GitHub by running git push. Finally, we’ll push our latest changes to Heroku by running git push heroku master.

While we’re waiting for this to finish, let’s visit our GitHub repository. Notice that in the config folder, our new YAML file called application.yml doesn’t appear. That means the Figaro gem is working – our account credentials are safely kept off GitHub and away from the public eye.

Back in our command line, we’ll see the push to Heroku is now complete. We’ve made changes to our database by adding the image column since the last time we pushed to Heroku. This means we need to run heroku run rake db:migrate to make sure those changes apply on Heroku as well as localhost.

Command Line
$ git status
$ git add .
$ git commit –m " Add images with carrierwave, S3, and Figaro"
$ git push
$ git push heroku master
$ heroku run rake db:migrate
We can run heroku open to check out our app live. Let’s delete this test Restaurant and try adding a new Restaurant.

Panera Bread
201 Brookline Avenue, Boston, MA 02215
(617) 247-0174
http://www.panerabread.com/

The image is working!

*If however, yours is not working, try running heroku restart and trying it again*

Command Line
$ heroku restart
If we view the image URL, we’ll see that it’s hosted on Amazon S3 as expected. Perfect!

Now that our image functionality is working on both localhost and Heroku, let’s spend some time in the next video on resizing our images so they fit more nicely on the page.

Resize Images:
In the last video, we used the Figaro gem to protect our Amazon S3 account credentials so we could add images to our site on Heroku. In this section, we’ll resize our images to a more normal size.

Right now, our uploaded image will appear on the Restaurant page, regardless of how large or small it is. To fix this, let’s go to the carrierwave gem documentation to explore its image processing features.

Let’s find the section titled ‘Adding versions’. Carrierwave has an option to help us resize the image by automatically processing it as soon as it’s uploaded. For example, if our image is originally 800×800 pixels, carrierwave can resize it into a thumbnail version that’s only 200×200 pixels.

In order to access these image manipulation features, we need to install a free software program called ImageMagick as well as another one called MiniMagick. Let’s start with ImageMagick. The process for installing ImageMagick varies depending on the computer you’re using. I’ll demonstrate this for Mac computers first.

We’ll visit cactuslab.com/imagemagick and click on the first link to download the file. Once it finishes downloading, open it up and it will guide you through installation. I already have imagemagick installed so I won’t go through the installation process again, but it should be pretty straightforward. Once it’s finished installing, go back to the command line and type ‘convert’. A ton of information should show up and if you scroll all the way to the top, you should see ‘Version: ImageMagick’. Mac users should be all set.

*If you’re on a Mac and having trouble with installation, try installing Homebrew (it should have been installed already if you followed the BaseRails installation video) and run ‘brew install imagemagick’*

On the other hand, if you’re running Windows, you should visit the ImageMagick website directly at imagemagick.org. You can see on the left they have this section called ‘Binary Releases’. We’ll go to the link for ‘Windows’. We’ll click the HTTP download link to download the installer. Once it finishes installing, just follow the installation guide. To check that it’s installed correctly, we’ll follow the same process as we did earlier for Mac computers. We’ll go to our command line and type ‘convert’. This should show us lots of information and if we scroll to the top, we’ll see ‘Version: ImageMagick’.

Now that ImageMagick is installed, let’s move on to installing MiniMagick. Fortunately, there’s a gem to help us do this. We’ll go through the standard gem installation process by adding it to our Gemfile. After saving, we’ll run ‘bundle install’. Finally, we’ll remember to restart our Rails server.

Follow the direction on the transcript/lecture to install ImageMagick

/Gemfile
…
gem "mini_magick"
Command Line
$ bundle install 
Restart your server if necessary

Command Line
$ rails s
We’re now ready to use carrierwave to create resized versions of our original images. In our app/uploaders/image_uploader.rb file, let’s first uncomment the line near the top that includes MiniMagick. We’ll then uncomment the line of code for processing files. We’ll leave the default dimensions as 200 pixels wide by 300 pixels tall and we’ll change scale to :resize_to_fit. :resize_to_fit will scale our image proportionally so it fits within our dimensions but it’ll maintain the same aspect ratio of the original. If instead we had wanted our image to fill the dimensions exactly, we would use :resize_to_fill, which crops our image if necessary.

/app/uploaders/image_uploader.rb
# encoding: utf-8

class ImageUploader < CarrierWave::Uploader::Base

  # Include RMagick or MiniMagick support:
  # include CarrierWave::RMagick
  include CarrierWave::MiniMagick

  # Choose what kind of storage to use for this uploader:
  if Rails.env.production?
    storage :fog
  else
    storage :file
  end
  …
  process :resize_to_fit => [200, 300]
  ...
Let’s save and try this out. If we view one of our existing Restaurants, we’ll see that the image is just as large as it was before. That’s because the image processing only takes place when the image is first uploaded so we need to re-upload this file. Let’s go back to the Restaurants index page and click the ‘Edit’ link. We’ll upload the same file again and submit the form. It looks a lot better now.

Let’s quickly re-upload the images for each of our restaurants.

It’s now time to save our progress. We’ll type git status to see the changes we’ve made. Let’s type git add . to prepare these changes to be saved, and then git commit –m with the message "Resize images" to commit our changes to Git. We’ll then push our changes to GitHub with git push, and update our live site with git push heroku master. We’ll run heroku open to launch our site now.

Command Line
$ git status
$ git add .
$ git commit –m "Resize Image"
$ git push
$ git push heroku master
Like we did in localhost, we need to re-upload the images on Heroku so they can be processed and resized for us.

Alright, we’re all set. Now that images are resized and working properly, we’re ready for the next section, where we’ll be using some advanced CSS styling to upgrade the look of our home page further.


6.Add Front-End Design
Create a Custom Banner:
In the last section, we added image functionality to our site. In this section, we’ll learn some front-end web design to customize the look and feel of our site. This is where we’ll see our app visually come together. Let’s start by learning how to add a custom banner to our website by implementing some basic CSS.

For those of you who are new to this, CSS is a programming language that allows us to style the layout and design of our web pages. We can use CSS to format our headers, borders, columns, fonts, colors, and more. We’ve actually already seen a little bit of CSS through Bootstrap. Remember that Bootstrap is essentially a bundle of CSS code that comes pre-packaged for us so we don’t have to rewrite it all from scratch.

Let’s visit the actual Yelp website to see how we want our site to look. We can see they have a banner here, which we’ll add to our own Yelpdemo home page. The easiest way to do this is to use Bootstrap to create a banner called a jumbotron.

Let’s go to the Bootstrap page at getbootstrap.com and click the ‘Components’ tab. We’ll see the jumbotron section on the lower right. Here’s what a basic jumbotron looks like. All we need to do to set it up is add this <div class="jumbotron">.

Let’s add this into our app. We want to add this to our home page, so we’ll go to the corresponding view page in our Sublime Text, under app/views/restaurants/index.html.erb. The jumbotron should appear above the Restaurants, so we’ll delete the Listing Restaurants line and replace it with <div class="jumbotron"> . We’ll close out this div below.

Let’s now add some text to go inside our jumbotron. We’ll write:

/app/views/restaurants/index.html.erb
<div class ="jumbotron">
  <h2>Yelpdemo is the best way to find reviews on local restaurants.</h2>
  <h3>Explore the favorite diners, pastry shops, and eateries in your community.
  <br>Leave reviews and ratings for your fellow foodies.</h3>
</div>
…
The <h2> and <h3> tags just signify that these are two differently sized HTML headers and the <br> tag just means put a break in the paragraph and start the sentence on the next line. The <br> tag is a special HTML tag that you don’t need to close. Let’s save and since our Rails server is already running, we’ll go directly to localhost to take a look. Not bad, the basic structure is there.

Bootstrap gave us a very quick way to put up a basic jumbotron, but there are many more customizations we can do by using CSS. We can find our CSS stylesheets under app/assets/stylesheets. A couple of these stylesheets were created for us automatically when we added our Restaurants and Pages scaffolds, but they’re currently empty and are mainly there to help us stay organized.

We also have a scaffolds.css.scss file, and we’ll see that there’s actually quite a bit of CSS code here already. When we generate a scaffold, Rails starts us off with some basic styling, but this default file can sometimes conflict with the custom CSS that we’ll be writing. To avoid any potential conflicts, let’s delete all the code in this file.

/app/assets/stylesheets/scaffolds.css.scss

Let’s now create a new stylesheet to hold the custom CSS code we’ll be writing. We’ll call it custom.css.scss. With our custom CSS file ready, let’s see how we can model our jumbotron off of Yelp’s banner. The first thing we can do is change the jumbotron’s background color. In CSS, all colors are specified by 6-digit codes that are specific to a precise color. There are countless color combinations that you can look up for unique font and background colors.

To figure out a specific code for a color on a web page, I like to use a Chrome Extension called Eye Dropper. You can see my Eye Dropper extension here. You can download this yourself by going to the Chrome Web Store. Search for Eye Dropper and it should be the first result.

Eye Dropper allows us to quickly find the exact 6-digit code for any color we see. For example, let’s go back to the Yelp page. Let’s say we wanted to figure out the color of the Yelp banner. We can figure that out by clicking on the Eye Dropper extension, selecting “Pick color from web page”, clicking the color we want on the page. We can see this color by going back to Eye Dropper and you can see the color on the right.

Lets copy this 6-digit code and back in our CSS file, let’s write

/app/assets/stylesheets/custom.css.scss
.jumbotron {
  background-color: #fdf7e1;
}
Let me briefly explain how CSS syntax works. In this case, the .jumbotron is called a selector and selectors tell our browser what to style on the webpage. We chose this specific selector name because in our index.html.erb file, this jumbotron class is what we want to apply our styles to. That’s why we use dot, which in CSS means it’s a class, jumbotron.

The selector is always followed by a curly brace and that curly brace has property and value combinations within. The property tells us what style effect we want to use which in this case is background-color. The property is followed by a colon, the value we’re assigning the property, and a closing semicolon. You’ll see this CSS syntax over and over again.

Before we see how this looks, we need to go to our Application Layout file under app/views/layouts/application.html.erb. Let’s move this “render layouts/bootstrap” code on top of the stylesheet_link_tag. We do this so that our custom CSS code overrides the preset Bootstrap ones.

/app/views/layouts/application.html.erb
...
  <title>Yelpdemo</title>
  <%= render 'layouts/bootstrap' %>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
…
Let’s save this to see how it looks. Great! The background color adds a lot. The actual yelp banner also has a border so let’s add that to our jumbotron as well. We can use Eye Dropper again to pick out the exact border color, but CSS is all about experimentation, so don’t feel compelled to be too exact. We’ll now add the CSS to create the border effect.

/app/assets/stylesheets/custom.css.scss /
.jumbotron {
  background-color: #fdf7e1;
  border: 1px solid #f2cb3b;
}
Here, we’re using the border property and setting the value to be a solid line that’s 1px wide with the color #f2cb3b. Let’s save and take a look.

Alright, now let’s format the text. If we go to our index.html.erb file, we see that in order to format the text, we need to format the selectors called <h2> and <h3>.

So in our stylesheet, we’ll write

/app/assets/stylesheets/custom.css.scss /
.jumbotron {
  background-color: #fdf7e1;
  border: 1px solid #f2cb3b;
  h2 {
      color: #c41200;
      font-weight: bold;
   }
}
We want our main <h2> header to be a shade of red with a specific 6-digit color code and we want the font to be bold. I’ll leave our <h3> header the same.

Let’s save and take a look. Great, this banner really does look like Yelp’s banner now. In the next video, we’ll add more custom CSS to format our navigation bar.

Format the Navbar:
In the last video, we added a custom banner to our home page to provide some information about our web app. In this video, we’ll continue to improve upon the design of our site by formatting the navigation bar.

Let’s start by formatting the background-color. If you remember from last time, we used the Eye Dropper extension to figure out the 6-digit color code for our banner. We’ll do the same thing to pinpoint the exact shade of red for the Yelp navbar.

We’ll copy this over and back in our app/assets/stylesheets/custom.css.scss , we’ll write:

/app/assets/stylesheets/custom.css.scss
.navbar-default {
  .container-fluid {
    background-color: #c41200;
  }
}
We know to use the .navbar-default selector because if we go to the code file for our navbar under app/views/layouts/_navbar.html.erb, I can see that the class for our navbar is titled navbar-default here, and the container-fluid selector is nested inside our navbar-default.

Let’s save and see what that looks like. Our link text looks pretty bad so let’s start by fixing our About and Contact links.

/app/assets/stylesheets/custom.css.scss
.navbar-default {
  .container-fluid {
    background-color: #c41200;
    .navbar-nav > li > a {
      color: #ffffff;
      font-size: 16px;
      font-weight: bold;
    }
  }
}
What we’re doing here is we’re styling all the links in our navbar. The a tag is used for links, so this sequence targets all the links that are contained within an li tag, which are contained within a class navbar-nav. So let’s save, go back and see the change. You can see our links are now white which is the code #ffffff, and it’s bold.

Finally, let’s format our app logo here on the left. We’ll style it with a round font, change the color to black with a white border, and make it bigger, just like the real Yelp logo.

In our custom.css.scss file, I’ll write

/app/assets/stylesheets/custom.css.scss
.navbar-default {
  .container-fluid {
    background-color: #c41200;
    .navbar-nav > li > a {
      color: #ffffff;
      font-size: 16px;
      font-weight: bold;
    }
    .navbar-brand {
        color: black;
        font-size: 30px;
        font-weight: bold;
        font-family: 'Hobo Std';
        text-shadow: 2px 0 0 #fff, -2px 0 0 #fff, 0 2px 0 #fff, 0 -2px 0 #fff, 1px 1px #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;        
    }
  }
}
We’re already familiar with the properties of color, font-size, and font-weight. Font-family specifies the name of the font, where here I’ve chosen one called Hobo Std because it’s a playful round font. Text-shadow is exactly what it sounds like. It adds a shadow around your text to give it an outline. Don’t worry about understanding what all the different values are, just know that we’re setting a white shadow all around our text.

Let’s save and take a look. That looks great! Currently, our page stretches across our entire screen but I’d like to push out some area around our content with a property called padding.

Back in our custom.css.scss file, we’ll write

/app/assets/stylesheets/custom.css.scss
.navbar-default {
  .container-fluid {
    background-color: #c41200;
    .navbar-nav > li > a {
      color: #ffffff;
      font-size: 16px;
      font-weight: bold;
    }
    .navbar-brand {
        color: black;
        font-size: 30px;
        font-weight: bold;
        font-family: 'Hobo Std';
        text-shadow: 2px 0 0 #fff, -2px 0 0 #fff, 0 2px 0 #fff, 0 -2px 0 #fff, 1px 1px #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;        
    }
  }
}
.container-fluid {
    padding: 10px 120px;
}
The first value of 10px specifies that we want to expand the page with 10px of padding on the top and bottom. The second value of 120px means we want to expand the padding by 120px on the left and right. Don’t be afraid to play around with padding to get dimensions that you like. Let’s save and take a look.

Our website looks a lot better now that we’ve added some basic CSS. The properties we covered in the last two videos are some of the most common ones you’ll be using. I recommend taking the time to experiment with different colors, fonts, and padding to get familiar with how it all works. A lot of front-end web development is trying different things in CSS until you design something you like. In the next video, we’ll continue to improve on the design by adding a static image to the bottom of our site.

Add Static Images:
In the last video, we used CSS to upgrade the look of our navbar. The last thing we’ll do in this section is learn how to add static images to our site.

On the Yelp page, if we scroll to the bottom, we can see this cartoon image of a bunch of buildings. We’ll implement this on our site as well. Obviously, when you build your own original app, please don’t use other people’s images, but for our purposes of recreating a Yelp-like demo, we’ll borrow this one.

Let’s right-click on the image and choose ‘Inspect element’. We see on the left all the HTML code for the site and on the right, the CSS code. Inspect element is one of the most useful things you can get in the habit of doing. Whenever you see a beautifully designed website and you want to know how it was created, you can use Inspect Element to see the code used to achieve that look.

On the right, we see the URL for the image listed under the background property. Let’s right-click and open this in another tab.

Let’s now save this image onto our computer. We could add this image to our site by linking it to the file on our computer, but that wouldn’t work for a live site hosted on Heroku. Instead, we’ll need to store this file using an online file hosting service. We set up Amazon S3 last time, so let’s go to aws.amazon.com and login to our account. Let’s click on ‘Services’ and find ‘S3’. We’ll open our yelpdemo bucket and upload this file.

We also need to change the permissions for all manually uploaded files to allow anyone to view it in their browser. Let’s right-click on the file and select “Make public”.

With our file now in Amazon S3, we can see the link to it under ‘Properties’. Let’s copy this link and add it to our site. Let’s open the code for our home page under app/views/restaurants/index.html.erb. We want to display the image at the bottom of the page, so at the bottom of the code file, we’ll write:

/app/views/restaurants/index.html.erb
…
<%= image_tag "YOUR_S3_URL" %>
We saw image_tag when we added our uploaded Restaurant images to our show.html.erb page. Here, we’re doing the same thing, except that this time we’re using the URL directly. Let’s save and go take a look. Awesome!

After all this front-end design work, let’s save our code to Git. We’ll run git status, then git add ., then git commit –m "Add custom CSS". Let’s then push our code to GitHub with git push. And finally we’ll push up to Heroku with git push heroku master.

Now we can run heroku open to see our changes live. Looks great!

Command Line
$ git status
$ git add .
$ git commit –m "Add custom css"
$ git push
$ git push heroku master
There’s so much more you can do with CSS that you’re limited only by your imagination. You’ll learn the most by exploring websites with designs you like, using ‘Inspect Element’ to see how they were built, and experimenting on your own. That’s the bulk of the front-end work we’ll be doing for Yelpdemo and in the next section, we’ll set up the Devise gem to add users to our site.

7.Add Users
Install Devise:
In the last section, we focused on upgrading our site’s front-end design by writing some custom CSS. In this section, we’ll be adding users to our site. We’ll start in this video by installing a gem called Devise.

Devise is a popular gem that’s useful for quickly adding the ability to have multiple user accounts and allow users to sign in and sign out. It also has a lot of different options. For example, you can choose to automatically sign out users who have been inactive for a while, or you can lock out a user when they use the wrong password a certain number of times in a row.

Let’s visit the devise GitHub page to see how to install it. If we Google ‘devise gem’, we should see the page as the first link. Let’s scroll down and under the ‘Getting Started’ section, we’ll see that as with any new gem, we need to add it to our Gemfile. Let’s do that now. In Sublime Text, we’ll open up our Gemfile and add Devise at the end. Let’s save.

/Gemfile
…
gem 'devise'
To install it, let’s go to our command line and run bundle install. Let’s also remember to restart our Rails server.

Command Line
$ bundle install 
Restart your server if necessary

Let’s go back to the GitHub page. After adding this gem to our Gemfile, we now need to run this devise generator. Let’s copy this and paste it into our command line.

Command Line
$ rails generate devise:install
Okay, we see it’s given us some more instructions to follow. First it says we need to define these default URL options in our environments files. We’ll go into our Sublime Text and under config we have this folder called environments. We’ll open that and see a file called development.rb. We’ll go back to our command line, copy this line of code, and paste it in right before the end statement. Right above it, let’s put in a comment so we’ll remember what it does. Let’s type a hashtag followed by “Required for Devise gem” and save.

/config/environments/development.rb
…
# Required for Devise gem
config.action_mailer.default_url_options = { host: 'localhost:3000' }
end
Now we need to do the same thing for another file. This time, we’ll open up our production.rb file. Scroll all the way to the bottom and let’s do the same thing. This time, in our comment, we’ll say “Required for Devise. Remember to change localhost:3000 to actual application host.” And we’ll save.

/config/environments/production.rb
…
# Required for Devise. Remember to change localhost:3000 to actual application host
config.action_mailer.default_url_options = { host: 'localhost:3000' }
end
This means that if we set up a custom domain name to www.yelpdemo.com, we need to make sure that in our production.rb file, we change this to yelpdemo.com. This is important if we decide to implement email functionality later on.

Back in our command line, the second step says to ensure that we’ve defined our root URL in our routes.rb file. We’ve actually done this already. If we go to our config/routes.rb file, we see that we’ve already defined our home page to be the Restaurants index page, so we don’t need to do anything here.

The third step says to ensure we have flash messages enabled. Let’s copy this code and go to Application Layout file under app/views/layouts/application.html.erb and paste it in right inside our Bootstrap container above the yield statement.

/app/views/layouts/application.html.erb
…
</head>
<body>
  <%= render 'layouts/navbar' %>
  <div class="container-fluid">. 
    <p class="notice"><%= notice %></p>
    <p class="alert"><%= alert %></p>
    <%= yield %>
    <%= render 'layouts/footer' %>
  </div>
</body>
</html>
These two lines enable us to send alert notifications to our users. For instance, if our users have signed in, then we can send them a message at the top that says “Sign in successful.” Let’s save this and move on to the fourth step.

We’re using a more recent version of Rails, so we can skip this. The last step says we can copy Devise views by running this command. Let’s do that now. This special Devise command allows us to see the code for each of the Devise view pages the gem provides. This allows us to customize our pages however we like.

Command Line
$ rails generate devise:views
Now that we’ve completed the steps in our command line, let’s go back to the Devise gem page to see the rest of the setup guide. Now we’ll run another special Devise generate command. We’ll copy this and paste it into our command line but don’t hit enter just yet. We need to decide what to call our user account model. We could really use any word here, but let’s use ‘User’. We’ll replace the default word ‘MODEL’ with the word ‘User’.

Command Line
$ rails generate devise User
Running this command has done a few things for us, one of which is that it created a migration file, which allows our Rails app to remember the details of our users by storing it in a new User database. We know that every time we change our database, we need to run the command rake db:migrate.

Command Line
$ rake db:migrate
Restart the server if necessary

Command Line
$ rails s
After we run rake db:migrate, we also need to remember to restart our Rails server. If we go back to the guide, we’ve already done this next step, so that’s all we have to do for setup. Let’s go look at our new app. With our Rails server running, we can go directly to localhost:3000.

Our home page still looks the same but we can go to localhost:3000/users/sign_up and we’ll see there’s a new page here for us to use. It doesn’t look great but we’ll see that the functionalities are all there. Let’s say we type an email “admin@yelpdemo.com”, put in a password, add a password confirmation, and hit ‘Sign up’. We get a message that says ‘Welcome! You have signed up successfully.’ We can even edit our profile by going to localhost:3000/users/edit. Here we have the option to change the different fields of our user profile. For instance, if we want to change our email to “alex@baserails.com”, we need to type in our current password to confirm it. Let’s hit “Update”. We can see that we updated your account successfully.

Let’s save our progress. We’ll run git status, followed by git add .. Then we’ll commit our code to Git with git commit –m "Add user accounts with Devise". We can now push to GitHub with git push. And finally we’ll push to Heroku with git push heroku master.

Since we ran rake db:migrate to change our database in localhost, we need to run heroku run rake db:migrate to do the same for Heroku.

Command Line
$ git status
$ git add .
$ git commit –m "Add user accounts with Devise"
$ git push
$ git push heroku master
$ heroku run rake db:migrate
We’ll now run heroku open to view our app. Let’s go to /users/sign_up and create a new user account. Good, it looks like it’s working.

With just a little setup, Devise is working correctly now. However, it’s a pain to type in a new URL every time we want to sign in or sign out so in our next video, we’ll see if we can add in a couple links to the right of our navbar to make it really convenient for users of our site.

Insert Conditional Links:
In the last video, we set up our Devise gem to add users to our site. In this video, we’ll add some convenient sign in and sign out links to our navbar and along the way, learn some more about Rails routes.

Previously, when we wanted to add a link, we would code the link in HTML. We can find an example of what we did in our navbar. We can find the code file for this in our Sublime Text under app/views/layouts/_navbar.html.erb. Here we have the link to the About page that’s written in HTML. Rails gives us a more natural way to do the same thing. To show you, I’ll leave this line here so we can compare. We’ll be replacing this with <%= link_to "About", pages_about_path %>.

Let me explain what we just did. Instead of writing this link using HTML, we’re doing the same thing with Embedded Ruby, or ERB. Like the last few times we’ve seen ERB, we use these opening and closing tags to tell Rails that the code we’re writing is Embedded Ruby. link_to is a Rails helper which will create our link for us. It needs two things from us: the link text that users will see and the route that the link directs to. The link text is straightforward, but how did I know to use pages_about_path?

We can figure this out by going to our command line and running rake routes. We’ll see it gives us this long table. We saw the rake routes command briefly in an earlier video when we were figuring out how to set our homepage but it’s worth a deeper look now. rake routes shows us all the pages that make up our site. Each of the URLs below is matched with something called a view page, which contains the code for what we see when we visit that URL. These view pages can all be found in our Sublime Text under app/views. They’re what we’ve been using this whole time to edit the content on our site.

Back to rake routes, we see that it tells us where we can find the right view page. For example, for localhost:3000/users/sign_in, the view page will be found in the folder devise/sessions, and it will be called new.html.erb. We can see that in our Sublime Text. In the views folder, under devise/sessions, we have a new.html.erb file.

Along with its very own view page, each page on our site also has its own route. This route is shown in the Prefix column here, and this is what we’ll use to write our links using Rails. The link we need is the one to the About page. The prefix for the About page is listed as pages_about. That’s why we used pages_about_path in our link code. The _path is something we’ll need to add at the end of each route every time. Let’s delete the original HTML link code and see if it works.

/app/views/layouts/_navbar.html.erb
…
      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
          <li><%= link_to "About", pages_about_path %></li>
...
We’ll save and with our Rails server running, we’ll open localhost directly. Our About link looks the same, and if we click on it, it still takes us to the same page. That means it’s working.

Let’s go ahead and convert all the links on our site to use the Rails link_to method. We’ll start with our link to the Contact page. Let’s check rake routes for the right route to use. It’s pages_contact. Let’s go to our code file and use the same format as before. We’ll replace the word ‘About’ with ‘Contact’ and replace pages_about_path with pages_contact_path. Let’s save and take another look. We can click it and see that it works.

/app/views/layouts/_navbar.html.erb
…
      <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
        <ul class="nav navbar-nav">
          <li><%= link_to "About", pages_about_path %></li>
          <li><%= link_to "Contact", pages_contact_path %></li>
...
We’ll also apply this approach on the link to our home page. Let’s check rake routes to see that the home page is the last one, the one with just the slash. The route is the word root. So in our code file, below the existing HTML link code, we’ll write <%= link_to "Yelpdemo", root_path, class: "navbar-brand" %>. This one is a little different because we needed to retain the “navbar-brand” class that was used previously. Let’s delete the original HTML line and save. We’ll see in our browser that it works.

/app/views/layouts/_navbar.html.erb
…
  </button>
       <%= link_to "Yelpdemo", root_path, class: "navbar-brand" %>
  </div>
...
There’s one more kind of link we can create: links to external URLs. In our About page, we can see there’s a link to the BaseRails site. Let’s go to the corresponding View Page in Sublime Text under app/views/pages/about.html.erb. Instead of our HTML link code, we’ll replace this with <%= link_to "BaseRails", "http://www.baserails.com" %>. We need to include the http in front in order for it to work. Let’s delete the original link code, save, and go to our browser. We’ll refresh and click the link to see that it works.

app/views/pages/about.html.erb
<h1>Hi welcome to Yelpdemo!</h1>
<h2>This is one of the sample applications for <%= link_to "BaseRails", "http://www.baserails.com" %>, a platform that teaches people to build awesome custom web sites with the ruby on rails programming language. Sign up and start learning today!</h2>
The last links we need to convert are on our home page. These are the links to the Restaurants on our site. Let’s go to the corresponding View Page under app/views/restaurants/index.html.erb. The website URL we see is pulled from our database using the code ‘restaurant.website’. We want this to be a functional link, not just text. To do that, we’ll write link_to restaurant.website, restaurant.website. They’re the same here because the link text will show the same URL that the link routes to. We’ll save and see this in action. Looks like it’s working!

app/views/restaurants/index.html.erb
…
<td><%= restaurant.phone %></td>
<td><%= link_to restaurant.website, restaurant.website %></td> 
…
Now that we’ve had plenty of practice on creating links in Rails, let’s put some new links in our navbar for users to sign up, sign in, and sign out. Let’s start with the sign up link.

rake routes tells us that the route for the /users/sign_up page is new_user_registration. So in our navbar partial, we’ll find the <ul> tag with class nav navbar-nav navbar-right which just means that the link will appear on the right side, and here we’ll add a link to the Sign Up page. Let’s copy over the code for our About link above, including these <li> tags, and customize it to become:
<li><%= link_to "Sign up", new_user_registration_path %></li>

Let’s save this and try it out. Normally, this link would take us to a sign up page but since we’re already signed in, it sends us this message that says “You are already signed in.” To fix that, let’s add a sign out link. We’ll find the route for the sign out page: destroy_user_session. We’ll now type in the code for the link.
<li><%= link_to "Sign out", destroy_user_session_path, method: :delete %>

Whenever you destroy something, like an active user session, you have to add a method: :delete to the end of your link. This is just something you have to remember to do every time you’re creating a link to sign out.

Let’s save and go back to our browser. We’ll refresh and see that there’s now a sign out link. It works! We can now click the “Sign Up” button and verify that it works as well. Okay, looks good.

Now let’s create the sign in link. We’ll go to rake routes and this time, we’ll see that there are two /users/sign_in URLs. One takes you to a new user session here and the other creates a new user session. This can be confusing, but you can think of the first as bringing the user to a login form and the second as submitting the completed form and actually signing them in. We want our link to take users to the sign in form, so we’ll use the route for the first one. That route is new_user_session. Let’s add the link to our navbar. We’ll save and check that it works.

Okay, looks good. The last link we need will take users to a page to edit their profile. We’ll find the route: edit_user_registration. And we’ll write the link code. Now we’ll save and take a look. It says “You need to sign in or sign up before continuing.” Let’s sign in with the user account we created last time: “alex@baserails.com”. We can now click “Edit Profile” and see that it takes us to the right page. We can sign out, sign up, and see that all the links are working.

There’s one last thing we should do. It doesn’t make sense to show a “Sign in” or “Sign up” link to a user who is already signed in. We can control when links appear to users who are either signed in or signed out by using a special Devise keyword. Let’s read more about it on the Devise gem page.

We’ll scroll down, and under the section titled ‘Controller filters and helpers’, there’s a note that says to verify if a user is signed in, we can use the following code <% if user_signed_in? %>. Let’s incorporate this into our code file. We want the “Sign Up” and the “Sign In” links to appear only to users who aren’t signed in. We want the “Sign Out” and “Edit Profile” links to appear only to users who are already signed in.

To do this, let’s add some Ruby code. We’ll write <% if user_signed_in? %>. This statement will check whether our user is signed in. If they are, we’ll make sure to show the ‘Edit Profile’ link followed by the ‘Sign Out’ link.

What happens if a user isn’t signed in? We’ll use the Ruby keyword ‘else’ to control this case. What this is saying is if the user is signed in, display these two links. Otherwise, we want to show the ‘Sign up’ and ‘Sign in’ links. At the very end, we need to tell Rails that we’re done with our if statement by putting an end statement. Notice that for our if, else, and end statements, we omitted the equals sign in our opening Ruby tag. That’s because we only use the equals sign when that line of Ruby code is displaying something onto the page.

Let’s save this and take a look. Right now, we’re only seeing the “Sign Up” and “Sign In” links because we’re logged out. If we sign in, we’ll see that that changes. Looks like it’s working.

/app/views/layouts/_navbar.html.erb
…
      <ul class="nav navbar-nav navbar-right">
        <% if user_signed_in? %>
          <li><%= link_to "Edit Profile", edit_user_registration_path %></li>
          <li><%= link_to "Sign out", destroy_user_session_path, method: :delete %></li>
        <% else %>
          <li><%= link_to "Sign up", new_user_registration_path %></li>
          <li><%= link_to "Sign in", new_user_session_path %></li>
        <% end %>
      </ul>
…
Let’s save our progress. We’ll run git status, followed by git add .. Then we’ll commit our code to Git with git commit –m "Add sign in links". We can now push to GitHub with git push. And finally we’ll push to Heroku with git push heroku master.

We haven’t made any database changes that require a rake db:migrate, so let’s open our app directly with heroku open. There are our links and looks like they’re working.

Command Line
$ git status
$ git add .
$ git commit –m "Add sign in links "
$ git push
$ git push heroku master
$ heroku open
To recap, in this video, we converted our links to use the new Rails syntax and we added a bunch of links for our users to sign in and sign out. In the next video, we’ll work on improving the look of our new Devise pages.

Style Devise Forms:
So far, we’ve installed the Devise gem that added users with the ability to sign in and sign out using links in our navbar. In this video, we’ll simply be adding the same Bootstrap form styles that we used for our Restaurant forms to our new Devise user forms. We’ll be applying these same styles to give our site a consistent look across all its pages. I’ll run through this pretty quickly because we’ve already seen this once before.

It’s ok if you forget how to convert a normal form into a Bootstrap one. We never need to memorize the specific classes to use because we always have the documentation to refer to. Let’s go take a quick look. We’ll go to getbootstrap.com, click on the ‘CSS’ tab, and we’ll see ‘Forms’ on the right.

Devise has already provided us with form code of our own which contains Embedded Ruby. So like we did last time, there are two things we need to do to style a form in Bootstrap. The first is to add a class form-control to all of our input, text area, and select elements. The second is to wrap each section in a class called form-group. Let’s start by going to the View Page for our ‘Sign In’ page under app/views/devise/sessions/new.html.erb.

Before we change anything, let’s first format this a little bit. We’re not actually changing anything, we’re just making it easier for us later on because the code will be more readable.

Now that it looks better, let’s first add the class form-control to our inputs. After :autofocus => true, we’ll type , class: "form-control". Let’s do this for the password section as well.

Let’s save this and go take a look. We’ll click on ‘Sign In’ and see that it looks a lot nicer. Let’s now do the second step of adding a class form-group to each section. We’ll convert this <div> into <div class="form-group">. Let’s repeat this for each of these sections.

Let’s save and take a look. We’ll notice that the spacing is a little bit nicer.

Let’s go back to the code and we’ll remove these <br> tags. We don’t need these <br> tags because Bootstrap’s form control is already placing these fields on a separate line. We’ll save and see that there’s no change.

Let’s now improve the button. Like we did last time with Restaurants, we’ll go to our code file, find our button code, add a , class: "btn btn-primary". Let’s save and go to our browser.

/app/views/devise/sessions/new.html.erb
<h2>Log in</h2>

<%= form_for(resource, as: resource_name, url: session_path(resource_name)) do |f| %>
  <div class="form-group">
    <%= f.label :email %>
    <%= f.email_field :email, autofocus: true, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :password %>
    <%= f.password_field :password, autocomplete: "off", class: "form-control" %>
  </div>

  <% if devise_mapping.rememberable? -%>
    <div class="form-group">
      <%= f.check_box :remember_me %> <%= f.label :remember_me %>
    </div>
  <% end -%>

  <div class="form-group">
    <%= f.submit "Log in", class: "btn btn-primary" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>
Much better. Next, we’ll improve our Sign Up page. We can find this page under app/views/devise/registrations/new.html.erb. This is the same process as before. We’ll first clean things up and remove the <br> tags. Then we’ll add a , class: "form-control" to each of our inputs. We’ll also convert each <div> to <div class="form-group">. Finally, we’ll add a , class: "btn btn-primary" to the button code. Let’s save and see how it looks. That’s better.

/app/views/devise/registrations/new.html.erb
<h2>Sign up</h2>

<%= form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
  <%= devise_error_messages! %>

  <div class="form-group">
    <%= f.label :email %>
    <%= f.email_field :email, autofocus: true, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :password %> <% if @validatable %><i>(<%= @minimum_password_length %> characters minimum)</i><% end %>
    <%= f.password_field :password, autocomplete: "off", class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :password_confirmation %>
    <%= f.password_field :password_confirmation, autocomplete: "off", class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Sign up", class: "btn btn-primary" %>
  </div>
<% end %>

<%= render "devise/shared/links" %> 
Let’s now style our Edit Profile page. To go to this page, we first need to sign in. We can then click on the ‘Edit Profile’ link. The corresponding view page is under app/views/devise/registrations/edit.html.erb.

Let’s clean this up. There’s a lot of stuff in this code file and much of it is here because Devise has so many different options you can set up. For example, we’ll see they have something called confirmable. That means we can force users to confirm their registration through an email sent to their email address. Options like these aren’t set up by default and won’t appear in our form unless we enable them.

Now that we’ve finished formatting our code, we can go ahead and add our class: "form-control" like before. Let’s now convert these <div> tags to <div class="form-group">. Let’s save and go back to take a look. Okay, looks good.

For the two buttons on this page, we’ll do things a little differently. Let’s add the "btn btn-primary" class to the first one, which will make it blue. But let’s make the second button for canceling an account a red color – we wouldn’t want users to click here by accident. To do that, we’ll go back to our code and first add the standard class: "btn btn-primary".

For the second button, we’ll use a different Bootstrap class used for generating a red button: "btn btn-danger". If we ever forget which classes to use for the different Bootstrap options, we can always go check the documentation first.
Also, notice that this button uses "method: :delete", which we first saw last time when we created the ‘Sign out’ link. We need to use this whenever we’re destroying something, whether it’s an active user session like last time or an entire user account this time. Let’s save this file and go visit our browser.

/app/views/devise/registrations/edit.html.erb
<h2>Edit <%= resource_name.to_s.humanize %></h2>

<%= form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f| %>
  <%= devise_error_messages! %>

  <div class="form-group">
    <%= f.label :email %><br />
    <%= f.email_field :email, autofocus: true, class: "form-control" %>
  </div>

  <% if devise_mapping.confirmable? && resource.pending_reconfirmation? %>
    <div class="form-group">
      Currently waiting confirmation for: <%= resource.unconfirmed_email %>
    </div>
  <% end %>

  <div class="form-group">
    <%= f.label :password %> <i>(leave blank if you don't want to change it)</i>
    <%= f.password_field :password, autocomplete: "off", class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.label :password_confirmation %>
    <%= f.password_field :password_confirmation, autocomplete: "off", class: "form-control" %>
  </div>


  <div class="form-group">
    <%= f.label :current_password %> <i>(we need your current password to confirm your changes)</i><br />
    <%= f.password_field :current_password, autocomplete: "off", class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Update", class: "btn btn-primary" %>
  </div>
<% end %>

<h3>Cancel my account</h3>

<p>Unhappy? <%= button_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?" }, method: :delete, class: "btn btn-danger" %></p>

<%= link_to "Back", :back %>
There’s one more page that we can edit. If we go to the ‘Sign In’ page, we’ll see that there’s a ‘Forgot your password’ link. If we click on it, we’ll see that this page hasn’t been updated yet. The code for this page is under app/views/devise/passwords/new.html.erb. We’ll go through the same process as before. First we’ll format the code. Then we’ll add a class: "form-control" here. We’ll also convert these <div> tags into <div class="form-group">. Finally, we’ll add a class: "btn btn-primary" to the button. Let’s save and go look. Looks good.

/app/views/devise/passwords/new.html.erb
<h2>Forgot your password?</h2>

<%= form_for(resource, as: resource_name, url: password_path(resource_name), html: { method: :post }) do |f| %>
  <%= devise_error_messages! %>

  <div class="form-group">
    <%= f.label :email %>
    <%= f.email_field :email, autofocus: true, class: "form-control" %>
  </div>

  <div class="form-group">
    <%= f.submit "Send me reset password instructions", class: "btn btn-primary" %>
  </div>
<% end %>

<%= render "devise/shared/links" %> 
It’s time to save our progress. We’ll run git status, followed by git add .. Then we’ll commit our code to Git with git commit –m "Style Devise forms with Bootstrap". We can now push to GitHub with git push. And finally we’ll push to Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Style Devise forms with Bootstrap"
$ git push
$ git push heroku master
$ heroku open
We can launch our app with heroku open, and by clicking on the navbar links, we’ll see that the forms look a lot nicer now. In the next video, we’ll improve the alert messages that users will see when they sign up, sign in, or perform other actions on our site.

Customize Alerts And Error Messages:
Now that our Devise forms are looking good, let’s turn our attention to the alerts and error messages that our site shows to our users. We’ll start with alerts. After we perform certain actions on our site, like signing in or adding a new restaurant, we’ll see alerts that show up at the top of the page. For example, if we sign in, we’ll see an alert with “Signed in successfully.” But right now, there’s basically no formatting whatsoever, so let’s add some Bootstrap styling. We’ll see more about the available options on the Bootstrap website.

We’ll go to getbootstrap.com, click on the ‘Components’ tab and scroll down to see the section called ‘Alerts’. Bootstrap gives us a few basic examples in different colors. Getting Bootstrap alerts to work is usually pretty simple, we just add a special class depending on which type of alert we want to use. To get this green alert, we’ll add the class “alert alert-success”. We can even add a little ‘x’ to the alert to dismiss them. We do this by adding an extra ‘alert-dismissible’ class and adding this extra line of code for the close button.

However, things are more complicated for us because we need to get these Bootstrap styles to play nice with the Devise alerts, which are set up a little differently. I had to spend some time Googling the problem myself and ended up writing some complicated code of my own to fix it. Don’t worry about understanding my code for now, but just type in what I have to get the desired effect. We’ll go to our Application Layout file under app/views/layouts/application.html.erb and inside our ‘container-fluid’, we’ll delete the existing alert message code and replace it with the following. I’ll paste my code in and you can type it by hand or copy and paste it directly from the BaseRails transcripts in order to avoid typos.

/app/views/layouts/application.html.erb
...
    <% flash.each do |name, msg| %>
      <% if msg.is_a?(String) %>
        <div class="alert alert-<%= name == "notice" ? "success" : "danger" %> alert-dismissable">
          <button type="button" class="close" data-dismiss="alert"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
          <%= content_tag :div, msg, :id => "flash_#{name}" %>
        </div>
      <% end %>
    <% end %> 
...
I know this looks pretty complicated, but this code basically replaces the default alerts with Bootstrap-styled ones. It should work as long as you’re using Rails version 4.1 or later. If you’re using an earlier version of Rails, you’ll need to delete the quotes around ‘notice’ and add a colon in front. With this new code, let’s save and do one more thing.

We’ll go to our Bootstrap partial in app/views/layouts/_bootstrap.html.erb. Here is where we use the Bootstrap CDN to load the styles we need, but in order to get a feature like a close button to work, we need to use something called jQuery as well. We’ll copy this last section and paste it right above, replacing the word ‘JavaScript’ with the word ‘jQuery’. Let’s delete the URL for now. To find the right URL to use, let’s open our browser and go to code.jquery.com. We’ll click on the minified link to the latest version of jQuery and we should see a huge file. The URL here is what we need so let’s copy that and paste it into our code. We’ll remove the ‘http:’ in front and save.

/app/views/layouts/_bootstrap.html.erb
…
 <!-- Latest compiled and minified JQuery -->
 <script src="//code.jquery.com/jquery-2.1.1.min.js"></script>
…
Time to visit localhost. This time, we can sign out and see that our new alert message looks way better.

The last step we need to do to fix our alert messages is to go to our Restaurants Show page. We can find this under app/views/restaurants/show.html.erb. At the top, we’ll see that there’s a line starting with <p id="notice">. This code displays an unformatted alert and if we leave it here, we’ll see a duplicate error message because we already have another alert being created in our Application Layout file.

/app/views/restaurants/show.html.erb
<div class="row">
  <div class="col-md-3">
  …
Now that alerts have been set up, let’s now move on to our error messages. We’ll see error messages when we make mistakes in our forms. For example, if we try to sign up and leave the form blank, we’ll see some errors at the top. These default errors look pretty bad, so to fix it, we’ll go to our code and under app/helpers, we’ll create a new file called devise_helper.rb. Like before, we’ll add some custom code here as well. Either copy and paste it from the BaseRails transcript or pause the video and type it in carefully to avoid typos.

/app/helpers/devise_helper.rb
module DeviseHelper
  def devise_error_messages!
    return '' if resource.errors.empty?
        
    messages = resource.errors.full_messages.map { |msg| content_tag(:li, msg) }.join
    sentence = I18n.t('errors.messages.not_saved', count: resource.errors.count,
      resource: resource.class.model_name.human.downcase)

    html = <<-HTML
    <div class="alert alert-danger alert-dismissable">
      <button type="button" class="close" data-dismiss="alert"><span aria-hidden="true">&times;</span>
        <span class="sr-only">Close</span>
      </button>
      <h4>#{sentence}</h4>
      #{messages}
    </div>
    HTML

    html.html_safe
  end
end
Okay, here it is. It’s not important to understand the details of how this works, just know that this is the code we’ll need to add Bootstrap styling to our Devise error messages. Let’s save and test it out. We’ll go to the sign up page once more, leave it blank, and see that the error messages look a lot nicer.

We’re now ready to save our progress. We’ll run git status, followed by git add .. Then we’ll commit our code to Git with git commit –m "Customize alerts and error messages". We can now push to GitHub with git push. And finally we’ll push to Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Customize alerts and error messages"
$ git push
$ git push heroku master
$ heroku open
We’ll launch our app with heroku open. If we try signing up a blank user, we’ll see that the error messages look identical to what we saw on localhost. We’re now ready to move on to the next section, where we’ll finally reviews to the restaurants on our site.

8.Add Reviews(I)
Build a Review Scaffold:
In the last section, we used the Devise gem to add user accounts to our Yelpdemo site. Right now users can add restaurants (which we’ll eventually need to restrict to Admins only), but they’ll probably be more interested in writing reviews instead. In this section, we’ll be giving users the ability to add reviews while spending a little more time understanding the Rails concepts we’ve been using so far.

Let’s start by creating a structure for these reviews. Let’s think about what actions we’ll need. Users will want to Create new reviews, Read or view existing reviews, Update a review they wrote before, and Delete a review. Creating, Reading, Updating, and Deleting are the four actions we’ll need for any resource. Collectively, they’re known by their initials as CRUD.

To define a resource that uses these four actions, we use the rails generate scaffold command. We saw this command once already when we created our Restaurant resource, but I’ll explain in a little more detail this time.

In our command line, we’ll run rails generate scaffold Review rating:integer comment:text. The rails generate scaffold command asks us to name the resource we’re defining, which in this case is a Review, followed by each of the attributes and data types we want it to have. We want every Review to have a rating that’s an integer, which is just a whole number, and a text comment. We use the word ‘text’ here because a review will be paragraph length.

Command Line
$ rails generate scaffold Review rating:integer comment:text
When we run this command, we’ll see that Rails does a few things for us automatically. First, Rails created a migration file, which we know is used to create the new Review database. This database will have table columns for the ratings and comments that we defined as a Review’s attributes.

We’ll see that Rails also created for us a set of Review-related View Pages, which our users will see in their browser as they create, read, update, and delete reviews. We can see these View Pages under app/views/reviews. Like with our Restaurants, we have a View Page for when users edit a review, where the form they’ll use is stored in a form partial. We also have View Pages for writing a new review, seeing an index of all reviews, or showing a specific review. It’s the job of the View to decide what gets shown on the page. The View is one of the three pillars of a fundamental concept called Model-View-Controller, or MVC for short. You should have a reasonable grasp of the View because that’s where we’ve been writing most of our code so far.

Going back to our ‘rails generate’ command, we’ll see that Rails also created a file called reviews_controller.rb. This is the Controller, or the ‘C’ in MVC. If we go to the file under app/controllers/reviews_controller.rb, we’ll see that this controller defines different actions we can take on a review. For example, we’ll recognize each of the words we saw from our View Pages, like ‘index’, ‘show’, ‘new’, and ‘edit’. But we’ll also see some other actions we haven’t seen before, like ‘create’, ‘update’, and ‘destroy’. There are more actions than View Pages because not every action requires a webpage for users to see. For example, we can destroy or delete a review from our database without having a page on our site dedicated to that action.

Controller files are difficult to understand at first, but you can think of a controller’s job as like a Command Center, where it decides exactly what needs to happen for each of the actions we can perform on a resource. As we start adding in more custom functionality, we’ll be using Controllers more and more.

Going back to our command line, we’ll also see a review.rb file. This is the Model, or the ‘M’ in MVC. We’ll find this file under app/models/review.rb. The Model works together with the Controller and the Views to form the base of our web app. While the Controller is the Command Center that defines all the actions we can take on our resources and the View determines what users see on the page, it’s the Model’s job to handle any data-related tasks. For example, the Model has to validate any user-submitted data. Say a user tries to rate a Restaurant as 7 on a scale from 1 to 5, then it’s the Model’s job to check that 7 is outside of the allowable range. We’ll see more about data validation after this section.

Model-View-Controller can be a little overwhelming to grasp at first, but I find it only starts to click when you start using them in practice. That’s why it’s important to start seeing how they fit together early on. While using the ‘rails generate scaffold’ command creates our Review controller, Review model, and Review view pages for us automatically, we’ll eventually need to create these individually as we start building more non-standard back-end features.

So we just ran the rails generate scaffold command and it created all these files for us. At the bottom, we’re asked if we want to overwrite the scaffolds.css.scss file. We’ll say no by typing n.

Since one of these files created was the migration file, we need to run rake db:migrate to create our new Review database. We’ll also remember to restart our Rails server.

Command Line
rake db:migrate
Restart server if necessary

Command Line
$ rails s
If go back to our first tab and run rake routes, we’ll see that a new set of Review-related routes was added for us. We can see the new URLs we can visit here. Let’s go check it out by going to localhost and visiting localhost:3000/reviews. Let’s add a new review. We’ll set the rating to be five and for the comment, we’ll write “Fresh and delicious food!”. It doesn’t look great, but it’s functional. We won’t spend much time beautifying this, but let’s at least clean up the form.

We’ll find the code for the form under app/views/reviews/_form.html.erb. We’ve had plenty of practice creating Bootstrap forms, so let’s do that quickly now. We’ll add a form-control class to each of the fields. We’ll then convert each <div> into a <div class="form-group">. Let’s now delete theses <br>. Finally, we’ll add a class "btn btn-primary" to our button . Let’s save and go back to our browser to see how it looks. We’ll go to localhost:3000/reviews/new to see our new form. Much better!

/app/views/reviews/_form.html.erb
<%= form_for(@review) do |f| %>
  <% if @review.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(@review.errors.count, "error") %> prohibited this review from being saved:</h2>

      <ul>
      <% @review.errors.full_messages.each do |message| %>
        <li><%= message %></li>
      <% end %>
      </ul>

    </div>
  <% end %>

  <div class="form-group">
    <%= f.label :rating %>
    <%= f.number_field :rating, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.label :comment %>
    <%= f.text_area :comment, class: "form-control" %>
  </div>
  <div class="form-group">
    <%= f.submit class: "btn btn-primary"%>
  </div>
<% end %>
Let’s save our progress. We’ll type git status, followed by git add .. Then we’ll run git commit –m "Add Reviews". We can then push up to GitHub with git push. Finally, we’ll run git push heroku master. We’ve made some database changes, so we’ll run heroku run rake db:migrate and then heroku open to see our app.

Command Line
$ git status
$ git add .
$ git commit –m "Customize alerts and error messages"
$ git push
$ git push heroku master
$ heroku run rake db:migrate
$ heroku open
We can go to /reviews/new and try adding the same 5-star Review that we wrote in localhost. “Fresh and delicious food!” Looks like it’s working.

To recap, we added the Review scaffold and styled our Review form with Bootstrap, all while learning more about Model-View-Controller. In the next video, we’ll link each Review with the User who wrote it.

Link Reviews to Users:
In the last video, we built the feature to add reviews on our site, but these Reviews haven’t been linked to the Users who wrote them. In this video, we’ll establish the relationship by linking our Review and User databases.

Having the ability to visualize our data makes it much easier to set up our databases correctly, so let’s start off by downloading a free application to do exactly that. We’ll open a new tab and search for SQLite Database Browser. Let’s click on the SourceForge link and click ‘Download’. When the file finishes downloading, double-click to launch it. You might see a popup that says it can’t be opened. If so, try clicking on it while holding down the ‘Ctrl’ key.

In the application, let’s click ‘Open Database’ and navigate to our app’s folder. We’ll then go to db and open the development.sqlite3 file. We’ll then click the ‘Browse Data’ tab. Here, we can see all the Restaurants we’ve created within our app. We’ll see a column for each of the Restaurant fields, like ‘name’, ‘address’, ‘phone’, and ‘website’. But we’ll also see some extra fields that Rails added by default. The most important one is ‘id’, which is a unique number to identify each of our Restaurants. We’ll also see columns like ‘created_at’ and ‘updated_at’, where Rails tracks when each Restaurant was last modified. In addition to the Restaurants table, we’ll also be able to click on the dropdown menu to view our other tables, like our Users and our Reviews.

We want to link Reviews with Users, so we’ll want to add a new column in our Reviews database to track the User ID that each Review belongs to. To change the structure of our database, we’ll need to generate a migration. Back in our command line, let’s write $ rails generate migration AddUserIDToReviews user_id:integer. The inputs for the $ rails generate migration command are the name of the migration and the name of each column along with its data type. When our migration name is of the form AddXToY, Rails automatically knows that we’re looking to add columns to the Y database.

Let’s run $ rake db:migrate, and now we’ll restart our server. If we go back to our SQLite Database Browser and refresh the Reviews table, we can scroll to the right to see that our new column was created. This is good – this column will allow us to track the User who wrote each Review.

Command Line
$ rails generate migration AddUserIDToReviews user_id:integer 
$ rake db:migrate
Restart the server if necessary

Command Line
$ rails s
But how will our app distinguish between an ordinary field like rating or comment versus a special field like user_id that’s supposed to link to the ID column of our completely separate User database? The answer is that it can’t. We need to establish this connection between the two tables by adding some code to our Model files. It makes sense to do this from the Model because the Model handles all data-related tasks.

Let’s first open our Review Model file under app/models/review.rb. The association between Reviews and Users is that a Review belongs to the specific User who wrote it. So we’ll write belongs_to :user and save.

/app/models/review.rb
class Review < ActiveRecord::Base
  belongs_to :user
end
Every association is a two-way relationship. While a Review belongs to a User, a User can have many Reviews. So we’ll go to our user.rb file and write has_many :reviews. There are many kinds of associations, but the belongs_to/has_many association we use here is by far the most common. At the end of this line, we’ll tack on a comma and then dependent: :destroy. This dependent: :destroy just means that if a User is deleted, all of the Reviews written by that User should be deleted as well. Let’s save.

/app/models/user.rb
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable
  has_many :reviews, dependent: :destroy     
end
Our database structure is now set up correctly. Next, we’ll be making sure that for each new Review that’s saved to the database, the user_id field is filled in properly.

It doesn’t make sense to ask users to type in their user_id every time they write a new review, so we need to find another way to figure out which user_id to enter into our database. The simplest approach is to assume that they’re already signed in and just check the user_id for the currently signed in account.

Fortunately, the Devise gem has a special keyword for this purpose. Let’s open our browser and go to the Devise documentation page. If we scroll down, in the section titled ‘Controller filters and helpers’, we’ll see that ‘for the current signed-in user, this current_user helper is available’.

When a New Review form is submitted, we want our app to take the ID of the current user and enter that into the user_id field. Because the Controller is the Command Center that defines what happens when we take different actions, we’ll go to our app/controllers/reviews_controller.rb file. We want to define what happens when a Review is created, so under the ‘def create’ section, after this line of code to create a New Review, we’ll write: @review.user_id = current_user.id. This will set the user_id field of our newly created Review to be the ID of the currently signed in user.

We should also make sure that there is indeed a user who is signed in. Otherwise, this current_user keyword will lead to an error. If we go back to the Devise documentation, we’ll see that we can use this ‘before_action’ line to authenticate our user and force them to sign in if they want to write a review. Let’s copy this, add it to the top of our Controller file, and save.

/app/controllers/reviews_controller.rb
class ReviewsController < ApplicationController
  before_action :authenticate_user!
  before_action :set_review, only: [:show, :edit, :update, :destroy]
…
  def create
    @review = Review.new(review_params)
    @review.user_id = current_user.id
…
Let’s go to our browser and visit localhost:3000/reviews/new. As you can see, we need to sign in first. Let’s try adding a new review and see if the user_id field gets added to our database. We’ll write a 3-star review that says “Pretty average experience – nothing special really…”. After we submit, we’ll go to our SQLite Database Browser and refresh the Reviews table. We’ll see that the user_id field was filled in with the number 1. This matches with the ID for our username in our Users table. Great – looks like it’s working.

Let’s save our progress. We’ll type git status, followed by git add .. Then we’ll run git commit –m "Link Review to Users". We can then push up to GitHub with git push. Finally, we’ll run git push heroku master. We’ve made some database changes, so we’ll run heroku run rake db:migrate and then heroku open to see our app live.

Command Line
$ git status
$ git add .
$ git commit –m "Link Reviews to Users"
$ git push
$ git push heroku master
$ heroku run rake db:migrate
Let’s go to /reviews/new to write a new review. Let’s sign in first. We’ll write the same 3-star review we added in localhost. “Pretty average experience – nothing special really…”. After submitting, we don’t see an error, but unfortunately we can’t check if the field was really filled in. We don’t have a Heroku equivalent of the SQLite Database Browser, but fortunately we’ll learn about a workaround next time.

To recap, we established a link between reviews and users by adding a user_id field to our Reviews database. We also edited the code in our controller to make sure that this field was filled in correctly. In the next video, we’ll use something called the Rails Console to modify data that’s already been submitted.

Modify Data with Rails Console:
In the last video, we made sure that each new Review that’s saved to the database has its user_id field set correctly. We can see this in our SQLite Database Browser by viewing our app’s Reviews table. As we can see, the most recent review has the field filled in, but the earlier Reviews still have blank entries. This can cause errors later on because these orphaned Reviews won’t belong to any user. So in this video, we’ll learn about the Rails Console to see how to modify existing data.

We can access our Rails Console by going to our command line and running ‘rails console’. The Rails Console gives us the ability to interact with our app from the command line. Here we can write Ruby code and run commands in our app that we could never do in the browser.

Let’s start with ‘find’, one of the most useful Rails Console commands. We’ll type @ Review.find(1)@. This will search our database for the Review with ID equal to 1. We’ll be shown all the information that Rails stores about this Review from our database.

We don’t have to search by ID – we can use ‘where’ to search by any attribute. For example, let’s type Review.where(rating: 5). To see all Reviews with 5-star ratings. In this case, there’s only one Review that fits this criteria.

The real power of the Rails Console comes from the fact that we can modify existing data. This time, we’ll write @review = Review.find(1), which stores the Review with ID 1 in the review variable. Now we can write @review.rating = 4 and then type @review.save to save the changes to our database. If we go back to our SQLite Database Browser, we can refresh the Reviews table and see that the first Review now has a rating of 4 stars.

Rails Console
> @review = Review.find(1)
> @review.rating = 4
> @review.save
Let’s use the same approach to set the user_id field. We’ll write @review = Review.find(1), then @review.user_id = 1, and then @review.save to write the change to our database. In our SQLite Database Browser, we can refresh to see that the first review now belongs to the user with ID 1.

Rails Console
> @review = Review.find(1)
> @review.user_id = 1
> @review.save
But let’s say that we have hundreds of Reviews in our database with blank user_id fields. Rather than change them one by one, we can do them all at once by using a loop. We’ll go to our Rails Console and type @reviews = Review.all. This uses the @reviews variable to hold all the Reviews in our database. We’ll then write the Ruby code to create the loop:

Rails Console
> @reviews.each do |review|
> review.user_id = 1
> review.save
> end
This code loops over every Review in our database, and for each one of them, it sets the user_id to 1 and saves it. Just like that, all our Reviews have now been assigned to the same user. We’ll type ‘Ctrl-D’ to quit out of our Rails Console.

We can use the Rails Console for Heroku as well. We’ll type heroku run rails console. Any of the changes we make here will affect our live Heroku database. Let’s run @review = Review.last. This command shows us the latest review that was written and we can see that its user_id field was filled in properly. As we can see, by using the Rails Console, we can explore some of the data that’s hidden in our Heroku database.

Command Line
$ heroku run rails console 
Rails Console
> @review = Review.last
However, some of the reviews we wrote on Heroku were submitted before we set up the user_id field. If we run @review = Review.first, we’ll see that this one still has a blank user_id field.

Rails Console
> @review = Review.first
This time, instead of editing this field, we’ll delete the review entirely by running @review.destroy.

Rails Console
> @review.destroy
Now if we run @reviews = Review.all, we’ll notice that it’s gone. Let’s hit ‘Ctrl-D’ to quit out and since all the Heroku reviews with blank user_id fields have been deleted, we’ve averted any potential errors and are ready for the next video, where we’ll remove some unneeded URLs from our site.

Remove Unnecessary URLs:
Last time, we used the Rails Console to manually fill in the user_id fields for the reviews we wrote earlier. In this video, we’ll see how we can customize the default scaffold URLs to include only the ones that we need.

The rails generate scaffold command we ran created a complete set of View Pages for us in app/views/reviews, but we don’t really need all of these. We’ll need the New Review and Edit Review pages, but we don’t want a page that features just one Review, so we don’t need the Show Review page. Our Review Index page is a list of all our Reviews, but we’ll want these Reviews to be displayed on the same page as the Restaurant, so it doesn’t need its own page either. Let’s delete these two View Pages that we no longer need. Let’s also delete these json.jbuilder files as well.

Removing the URLs for these two pages is simple. We’ll go to our config/routes.rb file and after resources :reviews, we’ll add , except: [:show, :index]. This code just says that we want the full set of URLs, except for those for the Show and Index pages. Let’s save.

config/routes.rb
Rails.application.routes.draw do
  resources :reviews, except: [:show, :index]
…
What’s more difficult than removing the URLs is dealing with the resulting ripple effect. We now have other code files that refer to URLs that no longer exist. Let’s go to our app/controllers/reviews_controller.rb file and delete any code for the index and show sections. We’ll also delete the :show in the line at the top. Let’s save.

app/controllers/reviews_controller.rb
class ReviewsController < ApplicationController
  before_action :authenticate_user!
  before_action :set_review, only: [:edit, :update, :destroy]
 
  # GET /reviews/new
  def new
    @review = Review.new
  end

  # GET /reviews/1/edit
  def edit
  end

  # POST /reviews
  # POST /reviews.json
  def create
    @review = Review.new(review_params)
    @review.user_id = current_user.id
…
Another ripple effect of deleting URLs is that we have links to pages that no longer exist. We’ll need to check our code for links that point to the Index or Show pages. We’ll first go to our app/views/reviews/new.html.erb page. Rather than change the link route, let’s temporarily disable the link by replacing 'reviews_path' with '#'. Let’s save and do the same in our edit.html.erb page. We’ll disable both links and save.

app/views/reviews/new.html.erb
...
<h1>New review</h1>
<%= render 'form' %>
<%= link_to 'Back', '#' %>
...
app/views/reviews/edit.html.erb
...
<h1>Editing review</h1>

<%= render 'form' %>
<%= link_to 'Show', '#' %> |
<%= link_to 'Back', '#' %>
...
Now if we go to localhost:3000/reviews/new and click on the ‘Back’ link, we’ll see that nothing happens but thankfully, we won’t see an error.

There’s one more ripple effect we need to fix. Let’s say we go to write another review by visiting localhost:3000/reviews/new. We’ll make this a one-star review and write “Found a bug in my food – stay away!” If we try to submit this review, we’ll see an error that says ‘Routing Error. No route matches [GET] “/reviews/3”’.

Seeing error messages is a little scary at first, but let’s try to understand the error message itself. It’s saying that it can’t find a route, which has to do with URLs. The localhost:3000/reviews/3 URL would normally take us to the page that shows us the review we just wrote, which would be in the Show Review page. But since we deleted that page, Rails can’t take us to a URL that no longer exists.

To fix the problem, after writing a new review, we need to redirect to a different page instead. Let’s redirect to the home page. We’ll go to our controller file under app/controllers/reviews_controller.rb, and under the create section, we’ll replace @review with the route for the home page, root_path and save.

app/controllers/reviews_controller.rb
  ...
  # POST /reviews
  # POST /reviews.json
  def create
    @review = Review.new(review_params)
    @review.user_id = current_user.id

    respond_to do |format|
      if @review.save
        format.html { redirect_to root_path, notice: 'Review was successfully created.' }
        format.json { render :show, status: :created, location: @review }
        …
Now we’ll try submitting another Review. We’ll go back to localhost:3000/reviews/new and we’ll create a 5-star review that says “Unbelievable chef!”. This time it works – we were redirected to the homepage.

Let’s save our progress. We’ll type git status, followed by git add .. Then we’ll run git commit –m "Remove Show and Index review URLs ". We can then push up to GitHub with git push. Finally, we’ll run git push heroku master. Now we’ll run heroku open to see our app.

Command Line
$ git status
$ git add .
$ git commit –m "Remove Show and Index review URLs "
$ git push
$ git push heroku master
We can go to /reviews/new and try adding the same 5-star Review that we wrote in localhost. “Unbelievable chef!” Looks like it’s working.

While we now may be able to create reviews that are linked to our user account, these reviews aren’t linked to the specific restaurant they were written for. We’ll need to let Rails know that every review in our database needs to be linked with a restaurant in our Restaurant database. This is what we’ll work on in the next video.

9.Add Reviews (II)
Link Reviews to Restaurants:
In the last section, we created reviews and linked them to the users who wrote them. In this section, we’ll continue setting up our reviews, starting with this video where we’ll link them to restaurants.

The process for setting up the link between our Reviews database and our Restaurants database is identical to the one we used last time for Users. We’ll first add a restaurant_id field to our Reviews database by generating a migration. Let’s run rails generate migration AddRestaurantIDToReviews restaurant_id:integer. Now we’ll run rake db:migrate and restart our Rails server.

Command Line
$ rails generate migration AddRestaurantIDToReviews restaurant_id:integer
$ rake db:migrate
If we go to our SQLite Database Browser, we can open our Reviews database. Here we’ll see our new table column.

Our next step is to establish the link between this restaurant_id field and the ID column in the Restaurants database. We’ll do this by going to our model file under app/models/review.rb. Like last time, reviews and restaurants have a belongs_to/has_many relationship. Reviews belong to a single restaurant while restaurants can have many reviews. So in this review.rb file, we’ll write belongs_to :restaurant and save. Then in our restaurant.rb file, we’ll write has_many :reviews and save.

/app/models/review.rb
class Review < ActiveRecord::Base
  belongs_to :user
  belongs_to :restaurant
end
/app/models/restaurant.rb
class Restaurant < ActiveRecord::Base
  mount_uploader :image, ImageUploader
  has_many :reviews
end
With our database set up, we now need to make sure that our restaurant_id field is filled in correctly when a review is saved to the database. Last time, we did this using Devise’s special current_user keyword. Unfortunately, a current_restaurant keyword doesn’t exist, so we’ll need to find another way.

We’ll solve this by sticking the restaurant_id in the URL. Let’s run ‘rake routes’ to see what they look like before we change them.

Whenever we want to change anything that has to do with URLs, we’ll go to our config/routes.rb file. We’ll recognize this as the file that we used early on to set our home page. We have a resources :reviews that was added for us when we created our Review scaffold. This line automatically creates the necessary URLs we need for our various Review pages. To place the restaurant_id in our URL, we’ll nest our Review resource inside our Restaurant resource by moving resources :reviews underneath resources :restaurants. We’ll do this by adding a do at the end of resources :restaurants, moving resources :reviews inside, and finally closing this ‘do’ block with an ‘end’. Let’s save.

/config/routes.rb
Rails.application.routes.draw do
  
  devise_for :users
  resources :restaurants do
    resources :reviews, except: [:show, :index]
  end
  …
If we go to our command line and run rake routes again, we’ll see that the URL for the New Review form is now /restaurant/RESTAURANT_ID/reviews/new. Actually, every URL related to Reviews has changed and now includes the restaurant_id.

One of the ripple effects of nesting resources is that in our New Review form under app/views/reviews/_form.html.erb, we need to replace @review at the top with [@restaurant, @review] and save. This is a change we need to make every time we nest resources together and to make this work, we need to define the ‘@restaurant’ variable from our controller.

/app/views/reviews/_form.html.erb
<%= form_for([@restaurant, @review]) do |f| %>
…
In our app/controllers/reviews_controller.rb file, we can scroll to the bottom to see how the @review variable was defined. Our controller uses the ID in the URL to find the right Review.

Let’s do the same thing for the @restaurant variable. We’ll write:

app/controllers/reviews_controller.rb
…
def set_restaurant
  @restaurant = Restaurant.find(params[:restaurant_id])
end
…
This code uses the restaurant_id we just added to the URL to find the right Restaurant. Then at the top, where we have this before_action line, we’ll add something similar. We’ll write before_action :set_restaurant and save.

app/controllers/reviews_controller.rb
class ReviewsController < ApplicationController
  before_action :set_review, only: [:edit, :update, :destroy]
  before_action :set_restaurant
  before_action :authenticate_user!
  …
Another ripple effect of nesting resources is that we may still have links that point to the old URLs. But if we go to app/views/reviews, we’ll see that this isn’t an issue because we disabled our links in the last section. We’ll go back and fix the routes for these links later.

With all the ripple effects taken care of, let’s now make sure that the restaurant_id field is filled in correctly. We’ll go back to our reviews_controller.rb file and underneath where we set the user_id field, we’ll write @review.restaurant_id = @restaurant.id. This code fills in the restaurant_id field by using the ID of the current restaurant. Let’s save.

app/controllers/reviews_controller.rb
  …
  def create
    @review = Review.new(review_params)
    @review.user_id = current_user.id
    @review.restaurant_id = @restaurant.id
    …
Time to test this out. We’ll go to the new URL for our New Review form, localhost:3000/restaurants/2/reviews/new. The 2 in the URL means that this review will be attributed to the restaurant with ID 2, which in our case is Panera Bread. Let’s write a 2-star review that says “Not terrible, but not sure that I will be eating here again”. Let’s submit the review and check our SQLite Database Browser to see if the field was filled in.

We’ll refresh the Reviews table, scroll to the right, and see that it was filled in correctly. Great!

To fill in the empty restaurant_id fields for our earlier reviews, we’ll use our Rails Console. We’ll write:

Rails Console
> @reviews = Review.all
> @reviews.each do |review| 
> review.restaurant_id = 2
> review.save
end
Now if we go back to our SQLite Database Browser and refresh the table, we’ll see that all the empty fields have been filled in.

We covered a lot of ground in this video, so let’s save our progress. We’ll hit “Control-D” to exist the Rails Console. We’ll run git status, followed by git add .. We’ll now commit our code with git commit –m "Link Reviews with Restaurants" and push up to GitHub with git push. Finally, we’ll run git push heroku master. We added a new database column, so we have to run heroku run rake db:migrate. We can now run heroku open to see our app live.

Command Line
$ git status
$ git add .
$ git commit –m "Link Reviews with Restaurants"
$ git push
$ git push heroku master
$ heroku run rake db:migrate
$ heroku open
We want to write a new review for Panera Bread, but to do that, we need to figure out Panera’s restaurant_id because we’ll need it in the URL. We don’t have a SQLite Database Browser to use for our Heroku database, so we’ll just use our Rails Console to figure it out.

Let’s run heroku run rails console. Then we’ll run Restaurant.first to see the first restaurant in our database, which is Panera Bread. Its ID is 3, so let’s go back to our browser and go to /restaurants/3/reviews/new. Let’s add the same 2-star review from before. We’ll write “Not terrible, but not sure that I will be eating here again”.

After submitting, let’s go back to our command line and type @review = Review.last, we’ll see that our latest review had all its fields set properly.

Let’s run a loop to make sure that none of the earlier reviews have blank entries. We’ll type:

Heroku Rails Console
> @reviews = Review.all
> @reviews.each do |review|
> review.restaurant_id = 3
> review.save
end
As we can see, each review now has its restaurant_id filled in properly. We’ll now quit out of the Rails Console with ‘Ctrl-D’ and we’re ready for the next video, where we’ll learn to link to our review pages by learning about routing for nested resources.

Nest Resource URLs:
Last time, we linked reviews to the restaurants they were describing. But to go to the New Review form, we still need to type in the URL manually. For example, to write a new review for Panera Bread, we need to go to localhost:3000/restaurants/2/reviews/new. We’ve seen how to create links before, but the process will be a little different this time. We’ll learn more about that and link up everything correctly in this video.

First, let’s focus on fixing the ‘Back’ link on the New Review form page. We disabled this link in an earlier video, but let’s fix the route and re-enable it now. We’ll go to the View Page under app/views/reviews/new.html.erb. This link was originally supposed to bring us to the Review Index page where we could see a list of all the reviews submitted on our site. Instead, it makes more sense for it to direct to the restaurant itself.

To find the right route, let’s run rake routes in our command line. Unlike the other URLs we’ve seen in rake routes, the URL for the Restaurant Show page contains this :id. This means that in addition to the usual route, which in this case is restaurant_path, we also need to tell our app which restaurant we want to display. Otherwise, how would it know whether to go to the Panera Bread page or the Legal Sea Foods page? Back in our code, we’ll replace the hashtag with restaurant_path(@restaurant). We can use @restaurant here to refer to the current restaurant because we defined it earlier in our controller file.

/app/views/reviews/new.html.erb
<h1>New review</h1>
<%= render 'form' %>
<%= link_to 'Back', restaurant_path(@restaurant) %>
Let’s save and go back to our browser. We can refresh, click on the link and see that it takes us to the Panera Bread page as we expected. Great, let’s now move on to our Edit Review page.

Before we type in the URL, let’s check rake routes to see the URL format we should use for this page. It’s /restaurants/#/reviews/#/edit. Let’s look in our SQLite Database Browser to find some IDs we can use. In the Reviews table, we’ll see that our latest review has ID 5 and its restaurant_id field is 2. With that information, we’ll switch to our browser and go to localhost:3000/restaurants/2 /reviews/5/edit. Clearly, the links don’t work.

Let’s go to our edit.html.erb file. We’ll fix the ‘Back’ link like before by replacing the hashtag with restaurant_path(@restaurant). This ‘Show’ link originally would have taken us to the Show Review page, but we removed this URL, so let’s just delete this link and the vertical bar after it. Let’s save and go back to our browser. The ‘Back’ link works.

/app/views/reviews/edit.html.erb
<h1>Editing review</h1>
<%= render 'form' %>
<%= link_to 'Back', restaurant_path(@restaurant) %>
Now let’s give ourselves an easier way to get to the New Review form page. It makes sense to place this link on the page for the restaurant itself. We can find the code for this page under app/views/restaurants/show.html.erb.

We’ll place the ‘Write a Review’ link right above the ‘Edit’ and ‘Back’ links on the bottom. Let’s write <%= link_to "Write a Review", and now we’ll go back to rake routes to check which route to use. This time, the New Review URL format contains a :restaurant_id. So in addition to the new_restaurant_review_path, we also need to tell our app which restaurant this new review is for. Back in our code, we’ll write new_restaurant_review_path(@restaurant) as the route. Let’s also add convert this link to a Bootstrap button with , class: "btn btn-primary" and close our Ruby tag. Let’s save and go see.

/app/views/restaurants/show.html.erb
...
<%= link_to "Write Review", new_restaurant_review_path(@restaurant), class: "btn btn-primary" %>
<%= link_to 'Edit', edit_restaurant_path(@restaurant), class: "btn btn-link" %> |
<%= link_to 'Back', restaurants_path, class: "btn btn-link" %>
We’ll refresh the page and see our new link. If we click on it, it takes us to the New Review form page as expected.

Let’s also decide where to redirect our user after they submit the New Review form. We’ll write a new 5-star review with the comment “Awesome lunch spot! Try their You Pick Two deal.” We get taken to the home page, but it makes more sense to go to the restaurant’s page instead.

To change this, let’s go to our controller file under app/controllers/reviews_controller.rb. We’ll see the current route in redirect_to root_path. We’ll replace root_path with the route for the Restaurant Show Page, which is restaurant_path(@restaurant), or we can even use a shortcut that you’ll sometimes see, and make it just @restaurant. Even though we didn’t use a path here, Rails can figure out that we mean to go to the Show Page for the current restaurant. Let’s save and go write a new review to make sure this works.

/app/controllers/reviews_controller.rb
  ...
  # POST /reviews
  # POST /reviews.json
  def create
    @review = Review.new(review_params)
    @review.user_id = current_user.id
    @review.restaurant_id = @restaurant.id

    respond_to do |format|
      if @review.save
        format.html { redirect_to @restaurant, notice: 'Review was successfully created.' }
        format.json { render :show, status: :created, location: @review }
      ...
We’ll write another review for Panera Bread. Let’s make it a 4-star review with the comment “Great service and ambiance”. Perfect – we’re taken to the Panera Bread page.

It’s time to save our work. We’ll run git status followed by git add .. As a side note, the reason why we keep seeing this warning is because we deleted our show.html.erb and index.html.erb files earlier. Git doesn’t know what to do about these, so to fix it, we just need to run git add –A.

Let’s now commit our code to Git with git commit –m "Set up links and routing for Reviews". Let’s now push to GitHub with git push. And finally we’ll update our live app with git push heroku master.

Let’s run heroku open to check out our app. We can go to a restaurant page to see the New Review link we set up. Looks good. Now that linking is all set up, in the next video, we’ll see how to take the Reviews in our database and integrate them into our restaurant page.

Command Line
$ git status
$ git add .
$ git add -A
$ git commit –m "Set up links and routing for Reviews "
$ git push
$ git push heroku master
$ heroku open

Display Reviews:
In the last video, we set up all the links to our review pages. In this video, we’ll tackle the fun task of taking the reviews in our database and bringing them into the Restaurant Show page.

Here we can see the Restaurant Show page for Panera Bread. Let’s first bring the reviews for Panera out of our database and onto the page – we’ll worry about formatting it afterward. Let’s go to the code for this page under app/views/restaurants/show.html.erb. Below the ‘Write a Review’ link, we can display all the reviews for Panera by writing a loop:

/app/views/restaurants/show.html.erb
<% @reviews.each do |review| %>
  <p><%= review.rating %></p>
  <p><%= review.comment %></p>
<% end %>
…
Let’s save. This code cycles through each of the reviews and for each review, it displays the review’s rating as well as its comment in <p> tags. We’re using this @reviews variable here, but it hasn’t been defined in the controller yet, so let’s do that now.

We’ll go to our controller file under app/controllers/restaurants_controller.rb. Since the View Page we were using was the Show page, we need to define the @reviews variable under the Show section. We’ll write @reviews = Review.where(restaurant_id: @restaurant.id). This defines the @reviews variable to be all reviews where the Review belongs to the current restaurant. This means that when we go to the Panera Bread page, we’ll see only those reviews written for Panera, which is what we wanted. Let’s save the file and go back to our browser.

/app/controllers/restaurants_controller.rb
…
  def show
    @reviews = Review.where(restaurant_id: @restaurant.id)
  end
…
If we refresh the page, we’ll see all the Panera Bread reviews we’ve written so far. Obviously, it looks atrocious, but the ratings and review comments are all there. Now that it’s functional, let’s format this a little bit.

Rather than display the reviews below the restaurant info, it would be great to make use of all the white space on the right side. To do that, we’ll look to Bootstrap to help us with the page layout. Let’s go to www.getbootstrap.com to learn more.

We’ll go to the ‘CSS’ tab and click on the ‘Grid system’ section. If we scroll down a bit, we’ll see an example. We can imagine this area to be the entire screen. Bootstrap’s grid system splits the screen into 12 different columns of the same width. So we can create one column that’s 8 grids wide and a second column that’s 4 grids wide. Or we could create two columns that are each 6 grids wide.

Getting this to work is pretty easy. We just need to specify a <div class="row"> followed by each of the columns we need. For instance, to create one column that’s 8 grids wide and a second one that’s 4 grids wide, we’ll use <div class="row"> followed by <div class="col-md-8"> and <div class="col-md-4">.

Bootstrap even lets us specify a different layout for different screen sizes, so we can customize how our site will appear on phones, tablets, and desktops. We do this by changing the prefix used in the class. Here, we’re using the prefix ‘md’ but if we scroll up a bit, we can see there are lots of other prefixes we can use. There’s ‘xs’ which is for small devices like phones, there’s ‘sm’ which is for devices like tablets, ‘md’ which is for medium-sized desktops and ‘lg’ which is for large-sized desktops.

Now that we’ve seen the Bootstrap grid system, let’s use it on our Panera Bread page. We’ll divide this page into a two-column layout, with the restaurant info on the left and the restaurant’s reviews on the right. Let’s go back to our code and create this structure.

At the top, we’ll write:

/app/views/restaurants/show.html.erb
<div class="row">
  <div class="col-md-3">
  </div>
  <div class="col-md-9">
  </div>
</div>
…
This divides our page into one column that’s 3 grids wide and a second that’s 9 grids wide. Note that we won’t be focusing on responsive design and making sure this page looks good on multiple devices. We’ll just make it look good on desktop and laptop computers for now.

Let’s now move our restaurant info code and our ‘Write a Review’ button into the ‘col-md-3’ section. Then we’ll move the code for the reviews into the ‘col-md-9’ section. Let’s save and see how it looks. Much nicer!

Let’s now make a couple of small changes. We’ll remove the word “Name” and make the restaurant name bigger. Let’s also convert this website into a clickable link. In our code, we’ll delete the line with “Name” and convert these <p> tags into <h2> tags. We’ll also go to the website section and write link_to @restaurant.website, @restaurant.website. Let’s save and check the webpage. Great!

Let’s check to how our other restaurant pages look. We’ll go back to the home page and check out the Legal Sea Foods page. Unfortunately, we haven’t written any reviews for Legal Sea Foods yet. Rather than show an empty page, it would be nice if it could at least say “No reviews yet”. So back in our show.html.erb code file, before this loop, we’ll write:

/app/views/restaurants/show.html.erb
…
    <% if @reviews.blank? %>
      <h3>No reviews yet. Be the first to write one!</h3>
    <% else %>
      <% @reviews.each do |review| %>
        <p><%= review.rating %></p>
        <p><%= review.comment %></p>
      <% end %>
    <% end %>
…
Let’s now cut the loop code and paste it in underneath the ‘else’ statement. This code will check to see if there are any reviews to be shown. If not, it’ll say ‘No reviews yet’. Otherwise, our app will list out the restaurant’s reviews as expected. Let’s save and go see.

We’ll refresh this page and see that it’s a little better.

/app/views/restaurants/show.html.erb
<div class="row">
  <div class="col-md-3">
    <%= image_tag @restaurant.image_url %>

    <h2>
      <%= @restaurant.name %>
    </h2>

    <p>
      <strong>Address:</strong>
      <%= @restaurant.address %>
    </p>

    <p>
      <strong>Phone:</strong>
      <%= @restaurant.phone %>
    </p>

    <p>
      <strong>Website:</strong>
      <%= link_to @restaurant.website, @restaurant.website %>
    </p>

    <%= link_to "Write Review", new_restaurant_review_path(@restaurant), class: "btn btn-primary" %>
  </div>
   
  <div class="col-md-9">
    <% if @reviews.blank? %>
      <h3>No reviews yet. Be the first to write one!</h3>
    <% else %>
      <% @reviews.each do |review| %>
        <p><%= review.rating %></p>
        <p><%= review.comment %></p>
      <% end %>
    <% end %>
  </div>
</div>

<%= link_to 'Edit', edit_restaurant_path(@restaurant), class: "btn btn-link" %> |
<%= link_to 'Back', restaurants_path, class: "btn btn-link" %>
It’s time to save our progress. We’ll run $ git status followed by $ git add .. Now we’ll run $ git commit –m "Display reviews on Restaurant Page" to commit our code to Git. To push it to GitHub, we’ll run $ git push. Finally, we’ll run $ git push heroku master to update our Heroku app.

Let’s now run $ heroku open to see our site live. If we go to the restaurant page, we’ll see our new page layout and the reviews we’ve written so far. Looks good!

Command Line
$ git status
$ git add .
$ git commit –m " Display reviews on Restaurant Page "
$ git push
$ git push heroku master
$ heroku open
In this video, we displayed our reviews on our restaurant Show Page and used the Bootstrap grid system to set up our page layout. In the next video, we’ll replace our simple rating numbers with a very cool and functional star rating system.

10.Add Star Ratings
Convert Numbers To Stars:
In the last video, we integrated reviews into our restaurant pages and added a page layout using the Bootstrap grid system. This time, we’ll look at the jQuery Raty plugin to change our simple numbered ratings into fancy, clickable stars.

Let’s start by going to the plugin’s page. We’ll Google ‘jquery raty’ and click on the first link. This is the documentation for the plugin. We can see a preview for how it works in the default example. Pretty cool!

Let’s download it and set it up. We’ll click the button in the upper right to download the zipped file. When it finishes downloading, we’ll go to the file and unzip it. Let’s open the folder and find the first file we need under ‘lib’ called jquery.raty.js. We want to move this file into our app directory, so we’ll copy this file, open a new window, navigate to our app directory under yelpdemo/app/assets/javascripts and paste it in.

We’ll also need to take the images of the stars themselves and upload them to our Amazon S3 account so that both localhost and Heroku will be able to access them. Let’s go to aws.amazon.com and go to ‘AWS Management Console’. We’ll click on ‘S3’ and go to our bucket. Let’s create a new folder called ‘stars’. We’ll right-click this folder and make it public so that our app will have access to it.

Let’s open our stars folder, click ‘Upload’ and we can now drag and drop some images in.

We’ll go to the demo/images folder and upload the star-half.png, star-off.png, and star-on.png files. Once the upload is finished, we’ll select all three files, right-click, and make them public.

Now that setup is done, let’s try to get the stars to appear on the page. The Raty plugin has a lot of optional features, so let’s start by getting a basic example to work and then layering on other features we want. Let’s go back to the documentation page to see how this works.

In the default example, we’ll see that if we have any <div> tag, we can use this syntax to turn it into a clickable star rating. We’ll go to the code for the Restaurant Show page under app/views/restaurants/show.html.erb and let’s delete the line where we currently display the review rating. Instead, we’ll write <div class="star-rating"></div>. We add the class="star-rating" to distinguish this <div> tag from the other ones. Otherwise, every <div> tag on this page would suddenly become a star rating.

/app/views/restaurants/show.html.erb
…
<% @reviews.each do |review| %>
  <div class="star-rating"></div>
  <p><%= review.comment %></p>
…
Now that we’ve created a <div> tag, let’s use this line of code from the documentation. Unlike the HTML and Ruby code we’ve written so far, this code is written in jQuery. To use it, we’ll go to the bottom of our file and write:

/app/views/restaurants/show.html.erb
…
<script>
  $('.star-rating').raty();
</script>
The <script> tags tell our app that this code is jQuery, and unlike HTML or Ruby, it doesn’t matter where the code goes, but it’s typically placed at the bottom of the file so it’s easier to find. Let’s save and go back to our browser. If we refresh the page, we’ll see that it’s working, but all the images are broken. That’s because we haven’t told our app where the images are stored.

In the plugin documentation, we can scroll down until we see a section called ‘Path’. Every option we’ll be using has a section like this one in the documentation. We’ll use the path option to tell our app that the images are stored in our S3 bucket. We’ll find the right path to use by going to our Amazon tab, clicking on one of our images, and selecting ‘Properties’. We’ll use the URL here, minus the part with the image name.

Back in our code, inside the parentheses, we’ll add the following:

/app/views/restaurants/show.html.erb
…
<script>
  $('.star-rating').raty({
    path: 'https://s3.amazonaws.com/yelpdemo-test/stars'
  });
</script>
This time when we save and go back to our browser, we can refresh to see the images appear. Unfortunately, all our reviews show up as having zero stars. That’s because we haven’t told our app how many stars it should be showing.

To see how to do that, we’ll go back to the documentation and go up to the section titled ‘Score callback’. We’ll need to add a data-score attribute to our <div> and then in our jQuery, we’ll add these three lines of code. Let’s do that now.

After the class: "star-rating" of our <div> tag, we’ll add a 'data-score=' but instead of hard-coding a number, we’ll use our Review’s number rating. We’ll write <%= review.rating %>. Then we’ll go back to the documentation and copy these three lines of code. Let’s add a comma and paste this into our jQuery code.

/app/views/restaurants/show.html.erb
…
<% @reviews.each do |review| %>
  <div class="star-rating" data-score= <%= review.rating %> ></div>
  <p><%= review.comment %></p>
…
<script>
  $('.star-rating').raty({
    path: 'https://s3.amazonaws.com/ yelpdemo-test/Stars',
    score: function() {
      return $(this).attr('data-score');
    }
  });
</script>
Let’s also layer on another option to make the stars read-only. Otherwise, the stars will change when we hover over them. We’ll put a comma after ‘path’ and write

/app/views/restaurants/show.html.erb
…
<% @reviews.each do |review| %>
  <div class="star-rating" data-score= <%= review.rating %> ></div>
  <p><%= review.comment %></p>
…
<script>
  $('.star-rating').raty({
    path: 'https://s3.amazonaws.com/ yelpdemo-test/Stars',
    readOnly: true,
    score: function() {
      return $(this).attr('data-score');
    }
  });
</script>
Let’s save and take a look. Looking good! The new star ratings we’ve included add a lot to our site.

Let’s save our progress. We’ll run git status and then git add .. Then we’ll commit our code to Git with git commit –m "Add star ratings with Raty". We’ll upload our code to GitHub with git push. Finally, we’ll update our site on Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Add star ratings with Raty"
$ git push
$ git push heroku master
$ heroku open
We’ll run heroku open to see our app live. If we go to the Panera Bread page, we’ll see that it’s working. In the next video, we’ll build these star ratings into our New Review form and calculate an average rating for each of our restaurants.

Layer On More Options:
In the last video, we converted the number ratings on our Restaurant Show Page into star ratings by using the Raty plugin. In this video, we’ll use Raty to replace the rest of the number ratings on our site.

Let’s start out by adding some more information to this page. Users will want to see the average star rating for each restaurant, so let’s add that in right below the restaurant’s name.

First, we need to calculate the average rating. Since this is the Restaurant Show page, let’s go to our app/controllers/restaurants_controller.rb file and under the Show section, we’ll write @avg_rating = @reviews.average(:rating).round(2). This code will take all of a restaurant’s reviews, average its ratings, and round it to two decimal places.

But if there aren’t any reviews that have been written, it won’t have anything to average, so this will give us an error. Instead, we’ll write:

/app/controllers/restaurants_controller.rb
…
if @reviews.blank?
  @avg_rating = 0
else
  @avg_rating = @reviews.average(:rating).round(2)
end
…
This will set the average to be zero if there aren’t any ratings to calculate. Let’s save and go to our View Page at app/views/restaurants/show.html.erb.

Beneath the section for the restaurant name, we want to display the average as a set of stars. We’ll copy over the <div> tag from last time and paste it in. This time, instead of review.rating, we’ll use the @avg_rating variable that we just defined. Let’s save and see if it works. Great – our average even uses a half star.

app/views/restaurants/show.html.erb
…
<h2>
  <%= @restaurant.name %>
</h2>

<div class="star-rating" data-score= <%= @avg_rating %> ></div> 
…
The average we see isn’t very meaningful without knowing how many total reviews were used to calculate it. Let’s go back to our View Page code and below the star average, we’ll write:

app/views/restaurants/show.html.erb
…
<h2>
  <%= @restaurant.name %>
</h2>

<div class="star-rating" data-score= <%= @avg_rating %> ></div> 
<p><%= "#{@reviews.length} reviews" %></p>
…
This hashtag with curly braces is a special feature of Rails called string interpolation. That’s just a fancy word that means that our Ruby code inside the curly braces will be calculated and then placed on the page as text. @reviews.length displays the number of reviews that our restaurant has. We’ll save and go back to our browser. Great!

Now let’s improve the spacing on the right by placing these reviews in a Bootstrap table. We’ll go back to our code and above our loop, we’ll create the structure for our table by writing:

app/views/restaurants/show.html.erb
…
<table class="table">
  <tbody>
  </tbody>
</table>
…
We’ll want to create a new table row for each review, so inside the tag, we’ll copy over our loop code and place the content in its own table row and table data tags.

app/views/restaurants/show.html.erb
…
<table class="table">
  <tbody>
    <% @reviews.each do |review| %>
      <tr>
        <td>
          <div class="star-rating" data-score= <%= review.rating %> ></div>
          <p><%= review.comment %></p>
        </td>
      </tr>
    <% end %>
  </tbody>
</table>
…
We’ll delete the original loop, save, and refresh the page. The lines help a lot in separating the individual reviews.

The final thing we’ll do is incorporate clickable star ratings into our New Review form. Right now, users have to manually type in a rating number. It would make more sense to click to select the number of stars to include in their review.

Let’s start by going to the code for the form under app/views/reviews/_form.html.erb. We’ll delete the section for the rating and replace it with stars by writing <div id="star-rating"></div>. Notice that this time we’re using id instead of class. The difference is that class is used when we need to use an element in multiple places on the page while id is used only once.

We’ll now copy the jQuery section from our Restaurant Show Page and paste it below. We’ll replace the .star-rating with #star-rating because when we identify a class, we place a period in front, but when we identify an Id, we use a hashtag. We’ll also remove the readOnly section and the score section because we don’t want to display a specific score – we want to select one. Let’s also delete this comma.

Finally, to get this to work with our form, we’ll go to the documentation and use the Score Name feature, which lets us take the number of stars selected and turn it into data for our form. In our code, we’ll add a , scoreName: 'review[rating]'. Let’s save and try submitting a new review.

/app/views/reviews/_form.html.erb
…
<div id="star-rating"></div>
…
<script>
  $('#star-rating').raty({
    path: 'https://s3.amazonaws.com/yelpdemo77/Stars',
    scoreName: 'review[rating]'
  });
</script>
We’ll refresh the page and write a 3-star review. We’ll write a longer review this time. But rather than come up with the text ourselves, we’ll generate it using something called Lorem Ipsum. Lorem Ipsum is just meaningless text that’s designed to imitate what real text would look like. Let’s generate 2 paragraphs now. We’ll use this as our review text, so let’s copy it and paste it in.

Looks good, except that for two things: first, our two paragraphs have been consolidated into one. Second, rather than show up at the top of the page, our new review appears at the bottom.

The first problem happens because our app is struggling to turn raw text into nicely formatted HTML. We need to help our app with this, so let’s go to our show.html.erb code and replace review.comment with h(review.comment).gsub(/\n/, '<br/>').html_safe. Here, gsub replaces any new line characters, which we see as breaks between paragraphs, into <br> tags. The h and .html_safe at the end are used to help our app display text as html.

/app/views/reviews/__show.html.erb
…
<table class="table">
  <tbody>
    <% @reviews.each do |review| %>
      <tr>
        <td>
          <div class="star-rating" data-score= <%= review.rating %> ></div>
          <p><%= h(review.comment).gsub(/\n/, '<br/>').html_safe %></p>
        </td>
      </tr>
    <% end %>
  </tbody>
</table>
…
Let’s save and take a look. Great! Now let’s fix our second problem, where we want to display our reviews in order from newest to oldest. We’ll go to our controller file, and under the Show action, we’ll take our definition of the @reviews variable, and tack on a .order("created_at DESC"). This code just sorts the reviews to be ordered by when they were created, in descending order. Let’s save and take another look. Good, it’s now reversed.

/app/controllers/restaurants_controller.rb
…
  def show
    @reviews = Review.where(restaurant_id: @restaurant.id).order("created_at DESC")
    if @reviews.blank?
      @avg_rating = 0
    else
      @avg_rating = @reviews.average(:rating).round(2)
    end
  end
…
It’s time to save our progress. We’ll run git status, followed by git add .. Then we’ll commit our code to Git with git commit –m "Update New Review form with clickable star ratings"’. Let’s push up to GitHub with git push. Now we’ll update our Heroku site with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Update New Review form with clickable star ratings"
$ git push
$ git push heroku master
$ heroku open
Let’s check out our site with heroku open. We can try adding a new review to see if it works. We’ll add a 3-star review with the Lorem Ipsum text we generated earlier. It’s working!

Now that star ratings are working, we’re ready for the next section, where we’ll give our users a name and set their permissions.

11.Set Validations And Permissions
Add User Fields:
In the last section, we used the Raty plugin to add star ratings to our site. In this section, we’ll be adding some more fields to our user accounts and setting the permissions that control which users get to see which pages.

If we look at our home page, we’ll see that any user has the ability to add a new restaurant or modify an existing one. These are actions that we want to reserve for admin users only. So to distinguish between regular users and admin users, we need to add a new ‘Admin’ field that can either be true or false.

Let’s generate a migration to do that. We’ll write rails generate migration AddAdminToUsers admin:Boolean. boolean is the name of the data type that can be either true or false. We can see the migration we just generated under db/migrate/add_admin_to_users.rb.

Command Line
$ rails generate migration AddAdminToUsers admin:boolean 
We can revise this file manually before we run it with rake db:migrate. Because we won’t want most users to be given admin permissions, we’ll add a , default: false. Let’s save and run this migration with rake db:migrate.

db/migrate/add_admin_to_users.rb
class AddAdminToUsers < ActiveRecord::Migration
  def change
    add_column :users, :admin, :boolean, default: false
  end
end 
Command Line
$ rake db:migrate 
We’ll also restart our Rails server.

Command Line
$ rails s
We can now open our SQLite Database Browser to see the new column we created in our Users table.

It would also be great if our users were given first and last names. We’ll generate another migration with rails generate migration AddFieldsToUsers first_name:string last_name:string. Let’s run it with rake db:migrate and restart our Rails server.

Command Line
$ rails generate migration AddFieldsToUsers first_name:string last_name:string 
$ rake db:migrate
Restart your server if necessary.

We’ll reopen our database. In our Users table, we’ll see the two new columns we added.

One of the ripple effects of adding in a new column is that we need to fill in blank entries for Users that were created earlier. Let’s use the Rails Console to fill these in. We’ll go to the command line and run rails console. We’ll go to the only user we need to change with @user = User.find(1). Let’s fill in the admin field with @user.admin = true and fill in the other fields as well.

Finally, we’ll save with ‘@user.save’ and quit out of the Rails Console with ‘Ctrl-D’. Now we can refresh our Users table to see that our empty fields have been filled in.

Command Line
$ rails console
Rails Console
@user = User.find(1)
@user.admin = true
@user.first_name = "Alex"
@user.last_name = "Yang"
@user.save
Exit out of the console when done

Another ripple effect of adding a new column is that we need to update our User forms. We’ll go to app/views/devise/registrations/new.html.erb and add in form groups for the first name and last name fields so our users can fill it out. We won’t do this for the admin field because it’ll just default to false. Let’s copy the section for email and replace :email with first_name. We’ll also replace email_field with text_field. Let’s do the same for the last name.

We also only want the ‘autofocus: true’ to appear in the first name section, so we’ll delete it from last name and email. This autofocus line will automatically highlight the field when the page is loaded.

app/views/devise/registrations/new.html.erb
…
<div class="form-group">
  <%= f.label :first_name %>
  <%= f.text_field :first_name, autofocus: true, class: "form-control" %>
</div>

<div class="form-group">
  <%= f.label :last_name %>
  <%= f.text_field :last_name, class: "form-control" %>
</div>

<div class="form-group">
  <%= f.label :email %>
  <%= f.email_field :email, class: "form-control" %>
</div>
…
Let’s save and do the same for the edit.html.erb form. We’ll just copy over the three sections from the New User form and paste them into the Edit User page. Let’s save.

app/views/devise/registrations/edit.html.erb
…
<div class="form-group">
  <%= f.label :first_name %>
  <%= f.text_field :first_name, autofocus: true, class: "form-control" %>
</div>

<div class="form-group">
  <%= f.label :last_name %>
  <%= f.text_field :last_name, class: "form-control" %>
</div>

<div class="form-group">
  <%= f.label :email %>
  <%= f.email_field :email, class: "form-control" %>
</div>
…
Finally, now that the fields have been added, we need to make sure that they’re filled in properly in our database. Normally, we’d go to our Controller file to do this, but because Users were created with the Devise gem, the process is a little different this time. Let’s go to the Devise gem page to see how to do it.

If we scroll down, we’ll see a section titled ‘Strong Parameters’. We saw strong parameters earlier when we set up carrierwave. At the time, we had to tell our app that the image field we added was safe. Here, we’ll be doing the same thing for our first_name and last_name fields.

Devise requires us to sanitize each additional form field by using this devise_parameter_sanitizer. There are three different forms available: Sign In, Sign Up, and Account Update. Our users won’t use their first_name or last_name fields to sign in, but they’ll need it for the other two.

So to get this to work, we need to copy this code into our app/controllers/application_controller.rb file. We’ll replace :username with :first_name and duplicate this line for the last_name field. Then we’ll copy both of these lines and replace :sign_up with :account_update. Now let’s save.

app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
  # Prevent CSRF attacks by raising an exception.
  # For APIs, you may want to use :null_session instead.
  protect_from_forgery with: :exception
  
  before_action :configure_permitted_parameters, if: :devise_controller?

  protected

  def configure_permitted_parameters
    devise_parameter_sanitizer.for(:sign_up) << :first_name
    devise_parameter_sanitizer.for(:sign_up) << :last_name
    devise_parameter_sanitizer.for(:account_update) << :first_name
    devise_parameter_sanitizer.for(:account_update) << :last_name
  
  end
end
We can try this out by signing up a new user. We’ll create an account for my co-founder, Susie Ye, and set her email as susie@baserails.com. After signing up, we’ll open our SQLite Database Browser to see that the fields were filled in correctly. We’ll also notice that her ‘admin’ field was set to false by default.

With our new fields added, let’s save our progress. We’ll run git status followed by git add .. We’ll commit our code with git commit –m "Add fields to Users". Let’s push to GitHub with git push, and then to Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Add fields to Users"
$ git push
$ git push heroku master
Since we’ve added new columns to our database, we need to run heroku run rake db:migrate. Now we’re ready to run heroku open to see our app.

Command Line
$ heroku run rake db:migrate
$ heroku open
Let’s create an account for Susie again. Now let’s use the Rails Console in Heroku to make sure that her fields were filled in properly. We’ll run heroku run rails console. We’ll type @user = User.last to see that everything looks good.

Command Line
$ heroku run rails console
Just like we did in localhost, we need to fill in all the empty fields for our earlier Users on Heroku. Let’s run @users = User.all to see all the Users we’ve created. Other than Susie, there’s only one other account. Let’s access it with @user = User.first. We’ll set the name fields with @user.first_name = "Alex" and @user.last_name = "Yang". Then, let’s give ourselves Admin privileges with @user.admin = true. Finally, let’s save with @user.save and quit out of the Rails Console with ‘Ctrl-D’.

Heroku Rails Console
> @user = User.first
> @user.admin = true
> @user.first_name = "Alex"
> @user.last_name = "Yang"
> @user.save
In this video, we added first_name, last_name, and admin fields to our User accounts. In the next video, we’ll integrate these new name fields into the way our reviews are displayed.

Integrate Names Into Reviews:
In the last video, we added three new fields to our user accounts: first_name, last_name, and admin. In this short video, we’ll take our new name fields and integrate them into the displayed reviews on the Restaurant Show Page.

Currently, we’re using a two-column layout, with the restaurant info displayed on the left and the reviews displayed in a table on the right. Let’s see if we can split the table into two columns of its own, with the left part displaying the user’s name and review date while the right side shows the review itself.

We’ll go to the code for this page under app/views/restaurants/show.html.erb. We’ll take the table of our reviews and set the column widths in a table header. We’ll write:

app/views/restaurants/show.html.erb
<thead>
  <tr>
    <th class="col-md-3"></th>
    <th class="col-md-9"></th>
  </tr>
</thead>
This code creates two columns, one that’s 3 grids wide and another that’s 9 grids wide. Keep in mind that these grids are smaller than normal because we’re nesting the grid inside a table, and not our entire screen. That’s also the power of Bootstrap which lets us create grid layouts within grid layouts.

Now that we have two columns, we can add a new <td> tag to hold the content for the left side. Inside, we’ll write:

app/views/restaurants/show.html.erb
<td>
<h4>
  <%= "#{review.user.first_name.capitalize} #{review.user.last_name.capitalize}" %>
</h4>
</td>
This code takes the review’s author’s first name and capitalizes it and does the same thing with the last name. Let’s also display the review date below. We’ll write:

app/views/restaurants/show.html.erb
<td>
<h4>
  <%= "#{review.user.first_name.capitalize} #{review.user.last_name.capitalize}" %>
</h4>
<p><%= review.created_at %></p>
</td>
Let’s save and see this in our browser. Looks good for the most part. Let’s make two changes. First, for privacy reasons, we’ll replace the full last name with just its first initial. Second, we’ll need to add some formatting to this review date. We just want the month, day, and year.

Back in our code, we’ll take review.user.last_name.capitalize and add a [0] at the end. We’ll also add a period outside of the curly brace. Together, this code takes the first letter of the last name and adds a period.

Next, we’ll need to format the date. We’ll write .strftime("%-m/%-d/%y"). Here we’re using a function called strftime. If we Google ‘strftime ruby’ and click on the APIdock link, we’ll see the documentation for the function. There are all kinds of options we can use. We’ll need the month of the year without the zero in front, so %-m, followed by the day without the zero in front, so %-d, followed by the last two digits of the year, which is %y. Let’s save and see this in our browser. Much better!

/app/views/restaurants/show.html.erb
…
    <thead>
      <tr>
        <th class="col-md-3"></th>
        <th class="col-md-9"></th>
      </tr>
    </thead>
…        
            <td>
              <h4>
                <%= "#{review.user.first_name.capitalize} #{review.user.last_name.capitalize[0]}." %>
              </h4>
              <p><%= review.created_at.strftime("%-m/%-d/%-y") %></p>
            </td>
…
It’s time to save our progress. We’ll type $ git status followed by $ git add .. Then we’ll commit our code with $ git commit –m "Integrate name into Restaurant Show Page". Let’s push up to GitHub with $ git push. Now we’ll update our site on Heroku with $ git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Integrate name into Restaurant Show Page"
$ git push
$ git push heroku master
$ heroku open
We’ll now run $ heroku open to see our app live. If we go to the Panera Bread page, we’ll see the changes we made.

With this done, we’re ready for the next video, where we’ll add some validation rules to check that the data our users are submitting actually makes sense.

Validate Submitted Data:
Last time, we added our ‘first_name’ and ‘last_name’ fields to the reviews shown on the Restaurant Show page. In this video, we’ll add some validation rules to check that the data our users are submitting makes sense.

Right now, if we try to register a blank user, we’ll see from the error messages that our app checks the email and password fields. This is because the Devise gem validates email and password for us by default. But there aren’t any validation rules set up for the new name fields we added last time – we’ll need to do those manually.

Let’s start by going to our model file under app/models/user.rb. The model’s job is to handle any data-related tasks, which is why data validation code belongs here. Let’s go to our browser to see the full list of validations we can add. We’ll Google ‘rails validations’ and click on the first link.

These RailsGuides are some of the most useful reference guides online for Ruby on Rails. These comprehensive articles cover nearly every topic related to Rails and while they can get pretty technical, a quick skim will often serve as a great introduction to an unfamiliar topic.

When it comes to validations, the most basic validation we can do is to check that a field isn’t blank. We’ll click on ‘presence’ on the right. To set up the validation, we just need to write validates followed by each field we want to check, and then presence: true.

We want our app to check that the first_name and last_name fields are filled in, so we’ll go back to our code and write validates :first_name, :last_name, presence: true. Let’s save and try submitting our form again.

/app/models/user.rb
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable, :recoverable, :rememberable, :trackable, :validatable

  has_many :reviews, dependent: :destroy

  validates :first_name, :last_name, presence: true
end
This time, we’ll see new error messages that reflect the new rules we added. Let’s now add validations to our other models, starting with Reviews.

We’ll open the review.rb file and validate that each of the fields is filled in. We’ll write validates :rating, :comment, presence: true. Let’s add another validation for the rating. We want to run a few checks – we want to check that rating is an integer and that it’s between 1 and 5.

To do this, we’ll go back to the RailsGuides page and scroll up to the section on numericality. Numericality validates that the field is a number and comes with a few extra options we can use. We’ll use only_integer: true, greater_than_or_equal_to: 1, and less_than_or_equal_to: 5. Let’s go back to our code and write the following, along with a custom message by adding , message: "can only be a whole number between 1 and 5". Let’s save and try it out. If we try to submit an empty review, we’ll see our new rules appear in the error messages.

/app/models/review.rb
class Review < ActiveRecord::Base
  belongs_to :user
  belongs_to :restaurant

  validates :rating, :comment, presence: true
  validates :rating, numericality: {
    only_integer: true,
    greater_than_or_equal_to: 1,
    less_than_or_equal_to: 5,
    message: "can only be a whole number between 1 and 5"
  }
end
Let’s also take some time now to fix the error message styling that appears for our Reviews. Let’s go to the Bootstrap documentation to see the code that we need to add. We’ll go to www.getbootstrap.com, click on the ‘Components’ tab, and go to the section on ‘Alerts’. We’ll need to add the ‘alert alert-danger’ classes to create a red message, and we’ll tack on an additional ‘alert-dismissable’ class to allow us to close it. We’ll also need to add these two lines of code for the close button.

Let’s do this by opening our form code under app/views/reviews/_form.html.erb. After <div id="error-explanation", we’ll write class= "alert alert-danger alert-dismissable". Now let’s copy the two lines of code for the close button, and we’ll paste it in. Let’s also make the text a little smaller by changing the <h2> tag into an <h4> tag. Let’s save and refresh the page. Looks good!

/app/views/reviews/_form.html.erb
<%= form_for([@restaurant, @review]) do |f| %>
  <% if @review.errors.any? %>
    <div id="error_explanation" class= "alert alert-danger alert-dismissable">
      <button type="button" class="close" data-dismiss="alert"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
      <h4><%= pluralize(@review.errors.count, "error") %> prohibited this review from being saved:</h4>
…
We’ll now add validations for our third and final model, Restaurants. We’ll open the restaurant.rb file and validate that each of the fields is filled in. We’ll write validates :name, :address, :phone, :website, :image, presence: true.

/app/models/restaurant.rb
validates :name, :address, :phone, :website, :image, presence: true
Let’s save and try it out. We’ll submit a blank restaurant form to see our new validation rules. Let’s take the time now to clean up these error messages. We’ll copy over the section from our Review form, and go to our Restaurant form code under app/views/restaurants/_form.html.erb and paste it in. Let’s save and refresh the page. Looks good!

Let’s also add a validation to check the format of the phone number. We’ll scroll to the top and go to the section called ‘format’. The syntax for this is validates followed by the field name, followed by format: { with:, and then something called a regular expression. A regular expression is just a way to convey a character pattern. In this case, we want our phone number to have the format (###) ###-####. We can code this into a regular expression with the help of a site called www.rubular.com.

We’ll put a sample phone number in the ‘test string’ section. Now to create our regular expression to match this phone number, we’ll use the quick reference guide at the bottom. For example, to match a digit, we’ll use ‘\d’. Putting this into the regular expression field, we’ll see that it matches with any of the digits in our phone number.

To match three digits, we’ll use ‘{3}’. Together, ‘\d{3}’ matches any three digits in a row. Matching the parentheses is a little different. Parentheses are special characters in regular expressions, so to match them, we need to add a backslash in front. So to match (123), we’ll write ‘\(\d{3}\)’. Putting this backslash in front is called escaping.

Using these rules, we can now create the rest of the regular expression. We’ll write \(\d{3}\) \d{3}-\d{4}. Finally, let’s also add a ‘\A’ in front to match the start of the string and a ‘\z’ in back to match the end. We’ll now use this regular expression as the format for our validation.

We’ll copy over this validation code. Let’s replace :legacy_code with :phone and let’s replace the section in between the slashes with the regular expression we just created. Let’s also customize the error message that users will be shown if they violate this format. We’ll replace this with must be in the format (123) 456-7890. Let’s save and try this out.

/app/models/restaurant.rb
validates :phone, format: { with: /\A\(\d{3}\) \d{3}-\d{4}\z/,
  message: "must be in the format (123) 456-7890" }
We’ll go to our New Restaurant Page and submit a blank form. Let’s also try using a phone number that doesn’t fit the format. Finally, we’ll see that using a correct format removes the phone number error message. Great!

Let’s create another regular expression for our website field. We’ll create a pretty basic one that checks whether the URL starts with http or https followed by ‘://’. We’ll change our test string to http://www.baserails.com/.

Matching the ‘http’ is simple. Some URLs will start with ‘https’ while others start with ‘http’, so we’ll need to match with zero or one ‘s’. To do that, we’ll use the ‘?’ and add ‘s?’. Next, we’ll have a colon and then these two slashes are also special characters, so we need to escape them by putting a backslash in front of each. Finally, we won’t run any checks on anything that comes afterward, so users can input any character as many times as they like. The ‘.’ Matches any character and the ‘*’ allows us to use as many as we like, so we’ll tack on a ‘.*’. Like last time, we’ll also add a ‘\A’ in front and a ‘\z’ in back. We’ll change the ‘http’ in our test string to ‘https’ and see that it still works.

Let’s go back to our code and create a new validation for our ‘website’ field. We’ll copy over the regular expression we created and customize the message to say ‘must start with http:// or https://’.

/app/models/restaurant.rb
validates :website, format: { with: /\Ahttps?:\/\/.*\z/,
  message: "must start with http:// or https://" }
Finally, we’ll set up a validation for the restaurant’s address. It’s pretty complicated to do a full check of whether an address is valid because there are so many possible exceptions, but we’ll create a basic rule that fits most address patterns.

Let’s change our test string to ‘350 5th Avenue, New York, NY 10118’. We want to match some number of digits, so ‘\d+’, followed by some number of letters or punctuation marks, basically anything but a comma. So we’ll use the square brackets with the carrot to match a non-comma character and we’ll add a ‘+’ because we want one or more of them. Now we’ll need a comma followed by some more non-comma characters followed by another comma. And then a space and a capital letter, so we’ll use this and write ‘[A-Z]’ with a {2} because we want two of them. We’ll add another space and then we want five digits, so we’ll use ‘\d{5}’. Finally, we’ll put a ‘\A’ in front and a ‘\z\’ in back.

Let’s add in this validation for the address. We’ll change the earlier phone to :website and we’ll change the current phone to :address. We’ll copy in our regular expression and customize the message to say ‘must be in the format 350 5th Avenue, New York, NY 10118’. Let’s save and try it out. Great!

/app/models/restaurant.rb
validates :address, format: { with: /\A\d+[^,]+,[^,]+, [A-Z]{2} \d{5}\z/,
  message: "must be in the format 350 Fifth Avenue, New York, NY 10118" }
Here it is all together:

/app/models/restaurant.rb
class Restaurant < ActiveRecord::Base
  mount_uploader :image, ImageUploader

  has_many :reviews

  validates :name, :address, :phone, :website, :image, presence: true
  validates :phone, format: { with: /\A\(\d{3}\) \d{3}-\d{4}\z/,
    message: "must be in the format (123) 456-7890" }
  validates :website, format: { with: /\Ahttps?:\/\/.*\z/,
    message: "must start with http:// or https://" }
  validates :address, format: { with: /\A\d+[^,]+,[^,]+, [A-Z]{2} \d{5}\z/,
    message: "must be in the format 350 Fifth Avenue, New York, NY 10118" }
end
One small change that could help our users follow these formats is if we added some example text for them to model off of. We’ll go to our form code under app/views/restaurants/_form.html.erb and after each input, we’ll add a comma, and then write ‘placeholder:’ and then the placeholder text we want to use.

/app/views/restaurants/_form.html.erb
…
  <div class="form-group">
    <%= f.label :name %><br>
    <%= f.text_field :name, class: "form-control", placeholder: "Panera Bread" %>
  </div>
  <div class="form-group">
    <%= f.label :address %><br>
    <%= f.text_field :address, class: "form-control", placeholder: "201 Brookline Avenue, Boston, MA 02215" %>
  </div>
  <div class="form-group">
    <%= f.label :phone %><br>
    <%= f.text_field :phone, class: "form-control", placeholder: "(617) 247-0174" %>
  </div>
  <div class="form-group">
    <%= f.label :website %><br>
    <%= f.text_field :website, class: "form-control", placeholder: "http://www.panerabread.com/" %>
  </div>
  <div class="form-group">
    <%= f.label :image %><br>
    <%= f.file_field :image, class: "form-control" %>
  </div>
  <div class="actions">
    <%= f.submit class: "btn btn-primary" %>
  </div>
…
Let’s save and test it out. Looks good!

It’s time to save our progress. We’ll run git status and git add .. Then we’ll commit our code with git commit –m "Add data validations". Let’s push to GitHub with git push. We’ll then push to Heroku with git push heroku master.

Let’s run heroku open to see our app live. Playing with any of our forms should show us that our new rules have been set up correctly. Now that our validations are working, we’re ready for the next video, where we’ll set the permissions for which pages are accessible to regular users and which are only viewable for admins.

Command Line
$ git status
$ git add .
$ git commit –m " Add data validations "
$ git push
$ git push heroku master
$ heroku open

Set User Permissions:
In the last video, we added data validations to our User, Review, and Restaurant models. This time, we’ll set the permissions for what different users can see and do.

Let’s think about how different types of users will interact with our site. Users who haven’t signed in should be allowed to visit restaurant pages and read reviews, but they shouldn’t be allowed to write new reviews or add new restaurants. Signed-in users should have the added privilege of writing reviews and editing or deleting reviews that they’ve written before. Finally, admin users should be allowed to do all of the above but also add, edit, and delete restaurants. We’ll take these rules and build them into our code.

Let’s start with the pages users are allowed to see. These authorizations are set in our controller files, so let’s go to our app/controllers/reviews_controller.rb file to decide who can view our review-related pages. Users who haven’t signed in shouldn’t be allowed to create new reviews, edit existing reviews, or do any of these other actions, so we need to make sure users are signed in. Fortunately, we’ve already done that with the special Devise keyword, authenticate_user!.

We should also make sure that users are only allowed to edit, update, or destroy reviews that they wrote themselves. We’ll run this check by writing some code at the top: before_action :check_user, only: [:edit, :update, :destroy]. Let’s now define this new check_user method down at the bottom by writing:

app/controllers/reviews_controller.rb
...
  before_action :authenticate_user!
  before_action :check_user, only: [:edit, :update, :destroy]
... 
    def check_user
      unless @review.user == current_user
        redirect_to root_url, alert: "Sorry, this review belongs to someone else"
      end
    end
...
This code will check that the current user is indeed the review’s author. If not, the user will be redirected to the home page and shown the alert message “Sorry, this review belongs to someone else”. However, we’ll also want to give admins the ability to modify anyone else’s reviews. So we’ll wrap this section in parentheses and write || (current_user.admin?). Now, this code checks to see that either the current user is the review’s original author or they’re an admin. Let’s save and test it in our browser.

app/controllers/reviews_controller.rb
...  
    def check_user
      unless (@review.user == current_user) || (current_user.admin?)
        redirect_to root_url, alert: "Sorry, this review belongs to someone else"
      end
    end
...
We’ll visit the URL for editing a review. We could check ‘rake routes’ for the URL format, but it’s localhost:3000/restaurants/2/reviews/1/edit, where 1 is the ID of a valid review and 2 is the ID of the restaurant it was written for. We’ll see the form appear because our currently signed in user is an admin user. If we log out and return to the same URL, we’ll be prompted to sign in first. And if we sign in as a non-admin user who didn’t write the review, we should get redirected to the home page as expected. Perfect.

It’s inconvenient to type in the URL to get to the Edit Review page, so let’s provide links to edit and delete the review from the Restaurant Show Page. We’ll only want these links to appear for users who have permission to click them, so let’s go to our View Page under app/views/restaurants/show.html.erb and underneath the review itself, we’ll add some code:

app/views/restaurants/show.html.erb
...
<% if user_signed_in? %>
  <% if (review.user == current_user) || (current_user.admin?) %>
    <%= link_to "Edit", edit_restaurant_review_path(@restaurant, review) %>
    <%= link_to "Delete", restaurant_review_path(@restaurant, review), method: :delete %>
  <% end %>
<% end %>
...
This code can look complicated, but it’s just putting together a few of the concepts we’ve seen already. We’re checking to see if the user is signed in and then whether the user has permission to modify the review. If so, we’ll display the ‘Edit’ and ‘Delete’ links. Let’s save and go to the Restaurant Show page to see if they show up.

We’re currently signed in as a regular user who didn’t write any of these reviews, so we shouldn’t see any links when we refresh the page. Let’s try writing a new review of our own. We’ll make this a 3-star review and generate some Lorem Ipsum text that we can use. We’ll go to www.lipsum.com and generate two paragraphs. Let’s copy this over and submit our review. Good – we can see the links and they appear to be working.

Let’s try deleting this review. Uh oh, we got an error. It says “NameError in ReviewsController#destroy”. We have an undefined local variable or method ‘reviews_url’. From the highlighted line of code, we can see that our app is complaining about the part that says ‘reviews_url’. The code is saying that after deleting the review, we should be redirected to the Reviews Index page. But we got rid of that URL, so this page no longer exists. To fix the problem, we need to go into the controller file under apps/controllers/reviews_controller.rb and under def destroy, we’ll replace reviews_url with the route for the Restaurant Show Page, which is restaurant_path(@restaurant). Let’s save and go back to our browser.

/apps/controllers/reviews_controller.rb
...
def destroy
  @review.destroy
  respond_to do |format|
    format.html { redirect_to restaurant_path(@restaurant), notice: 'Review was successfully destroyed.' }
    format.json { head :no_content }
  end
end
...
We’ll create another review and try deleting it. This time, we’ll see that we no longer see the error.

Note that while this wasn’t done in the video, you should also do the same for the ‘update’ action – see Notes. Thanks Laurence!

Now that our Review Page permissions are done, let’s do the same for our restaurants. This time, we’ll go to our restaurants_controller.rb file. Users who aren’t signed in should only be allowed to view the Restaurant Show page and the Restaurant Index page. They shouldn’t be allowed to do anything else, like create or edit a restaurant. So we’ll force users to sign in for these other actions and at the top, we’ll write before_action :authenticate_user!, except: [:index, :show].

Now what permissions should non-admin users be given? They should have the same privileges as users who haven’t signed in because we want to reserve the ability to create new restaurants and modify existing ones for admins. So let’s do the same thing we did for reviews and write before_action :check_user, except: [:index, :show]. Then at the bottom, we’ll define the check_user method and write:

/app/controllers/restaurants_controller.rb
...
def check_user
  unless current_user.admin?
    redirect_to root_url, alert: "Sorry, only admins can do that!"
  end
end
...
Let’s save and go back to our browser. We’re currently logged in as a non-admin, so let’s try adding a new restaurant. We’re taken to the home page and we see an alert as expected. Good.

/app/controllers/restaurants_controller.rb
class RestaurantsController < ApplicationController
  before_action :set_restaurant, only: [:show, :edit, :update, :destroy]
  before_action :authenticate_user!, except: [:index, :show]
  before_action :check_user, except: [:index, :show]
...
  def check_user
    unless current_user.admin?
        redirect_to root_url, alert: "Sorry, only admins can do that!"
    end
  end
...
Now that we’ve controlled the pages that users can see, let’s make sure that the links on the page match their permissions. The ‘New Restaurant’ link, as well as the ‘Edit’ and ‘Destroy’ links should only be visible to admins, so we’ll go to the code for the home page under app/views/restaurants/index.html.erb and let’s set up some checks.

Above the ‘New Restaurant’ link, we’ll write: <% if user_signed_in? && current_user.admin? %>, tab in the link, and put an <% end %>.

Before we run those same checks on our other links, let’s get rid of the ‘Show’ link and instead make the restaurant’s name itself a link to the Restaurant Show Page. We’ll replace the restaurant.name with link_to restaurant.name, add a comma, and write the route for the restaurant Show page, which is just restaurant.

Now to remove the original ‘Show’ link, we’ll delete that line of code and go to our column header tag and replace colspan="3" with colspan="2".

Ok, to run our user permission checks for our other links is a little more complicated because they’re in the table. We’ll need to change the table structure itself to remove the columns reserved for the ‘Edit’ and ‘Destroy’ links. We’ll wrap the <th colspan="2"></th> with the same ‘if’ statement and follow it with an <% end %>. And we’ll do the same for the <td> tags containing our links.

Let’s save and go check it out. Looks good!

/app/views/restaurants/index.html.erb
<table class="table table-hover table-condensed">
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
      <th>Phone</th>
      <th>Website</th>
      <% if user_signed_in? && current_user.admin? %>
        <th colspan="2"></th>
      <% end %>
    </tr>
  </thead>

  <tbody>
    <% @restaurants.each do |restaurant| %>
      <tr>
        <td><%= link_to restaurant.name, restaurant %></td>
        <td><%= restaurant.address %></td>
        <td><%= restaurant.phone %></td>
        <td><%= link_to restaurant.website, restaurant.website %></td>
        <% if user_signed_in? && current_user.admin? %>
          <td><%= link_to 'Edit', edit_restaurant_path(restaurant), class: "btn btn-link" %></td>
          <td><%= link_to 'Destroy', restaurant, method: :delete, data: { confirm: 'Are you sure?' }, class: "btn btn-link" %></td>
        <% end %>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<% if user_signed_in? && current_user.admin? %>
  <%= link_to 'New Restaurant', new_restaurant_path, class: "btn btn-link" %>
<% end %>
It’s time to save our progress. We’ll run git status and git add .. We’ll commit our code with git commit –m "Set user permissions". Let’s push to GitHub with git push. Then we’ll push to Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m "Set user permissions"
$ git push
$ git push heroku master
$ heroku open
Finally, we’ll launch our app with heroku open. If we log in as a regular user, we’ll see that none of the home page links are showing. That’s a sign that our changes are working. Our app is mostly there, but in the next section, we’ll be adding in some mapping features with Google Maps integration as well as search functionality.

12.Add Bells And Whistles
Embed Google Maps:
In the last section, we set up the user permissions for each page on our site. In this section, we’ll add on a couple of feature extensions, starting with Google Maps integration.

Here on the Restaurant Show page, we currently display a bunch of information on the restaurant, including its address. It would be great if in addition to displaying the address, we could also show a map of its location. Luckily for us, embedding a Google Map is incredibly easy. We’ll Google ‘google maps api’ and click on the first link. We’ll go to the section called ‘Web’.

Here, we’ll see that there are two types of Google Maps APIs: the JavaScript API and the Embed API. An API, which stands for ‘Application Programming Interface’, is just a bunch of commands that allow developers to interact with outside applications. We can think of it as a toolbox that makes it easier to do certain tasks without having to write all the code from scratch. In this case, the Google Maps API makes our life much easier because we don’t have to build a mapping system from scratch. Instead, we can follow their setup process and quickly have an embeddable map ready to go.

To decide which API to use, we need to think about which features we need to have. In this case, the Google Maps Embed API has all but the most advanced functionality. Unless we need to draw on the map or layer on heatmaps or traffic conditions, the Embed API should have the features we need. We’ll still have the ability to zoom in and out, calculate routing directions, and even search for landmarks. Since we won’t need the more advanced features for our Yelpdemo app, let’s click on the Embed API link to see how to set it up.

Embedding a Google Map onto our site is relatively simple. All we need is copy this <iframe> code and customize it to have the options we need. Let’s copy this now and then go to our Restaurant Show page code under app/views/restaurants/show.html.erb and paste it in below the New Review link.

/app/views/restaurants/show.html.erb
…
    <%= link_to "Write a Review", new_restaurant_review_path(@restaurant), class: "btn btn-primary" %>

    <iframe
      width="450"
      height="250"
      frameborder="0" style="border:0"  
      src="https://www.google.com/maps/embed/v1/search?key=API_KEY&q=record+stores+in+Seattle">
    </iframe> 
  </div>
…
We’ll start by customizing the dimensions of the map. We want to make sure it fits on the left-hand side, so let’s make it 300 pixels wide by 300 pixels tall. We’ll leave the ‘frameborder’ and ‘style’ that come by default and now we need to figure out what URL to put here. To help with that, the documentation has a section on ‘Forming the URL’. Let’s check it out.

Every Embed API has a URL of the same format. There are only three pieces we need to customize: the ‘mode’, like whether we want a regular map or directions to an address; the ‘api_key’, which is a free key that Google Maps will give us; and any parameters or additional options we need.

Let’s start with the API key. We’ll visit the link they provide and create a new project. We’ll activate the Google Maps Embed API. The Embed API allows up to 2,000,000 requests per day. That should be plenty to use…for now. To get our API key, we’ll click on ‘API Access’ and under ‘Simple API Access’, we’ll copy the API key shown and replace that in our URL.

With the API key taken care of, let’s move on to the next piece, ‘mode’. There are four map modes: ‘Place’, which is a regular map with a pin at the location we want; ‘Directions’; ‘Search’, if we want to explore an area for specific locations; and ‘View’, which is just a basic map with no pins or markers. We’ll go with the first option, ‘Place’, so let’s put that into our URL now.

Now on to the map parameters. For the ‘Place’ option, we’ll see that there’s only one required parameter, called ‘q’. ‘q’ is the name of a landmark or an address that we can provide. Notice that whatever we use, any spaces need to be replaced with plus signs.

Let’s do that. Back in our code, we’ll replace the default address with the address of our restaurant. Since this is dynamic, we’ll need Embedded Ruby. We’ll write <%= @restaurant.address.parameterize %>. ‘parameterize’ converts the spaces in the address into dashes, which Google will also accept even though it’s not in the documentation. Let’s save and try this out.

If we refresh our Restaurant Show page, we should see a Google Map appear on our site. The dimensions are a little too big, so let’s go back to our code, and set the width to be 230 and the height to be 230 as well. Let’s also put two break tags on top for some spacing. Let’s save and take a look.

That looks a lot better. We can see that with relatively little effort, we can set up the Google Maps API and have a Google Map ready on our site. It lets us move around, zoom in or zoom out, and if our users are logged in to Google, they’ll even be able to see any locations they’ve saved in the past.

Let’s go back to the documentation to see some of the optional parameters we can add. If we scroll to the bottom, we’ll see the list, which includes fields such as ‘zoom’, ‘maptype’ and ‘language’.

Let’s say we want to set the zoom level. The values we can use range from 0, or the whole world, to 21, where we’ll be able to see individual buildings. The default zoom setting appears to be 17, so if we want to zoom out a little, we’ll go to our URL and tack on an &zoom=14. Let’s save and see the difference. If we refresh the page, we’ll see that it’s now zoomed out a little more.

/app/views/restaurants/show.html.erb
    ...
    <%= link_to "Write a Review", new_restaurant_review_path(@restaurant), class: "btn btn-primary" %>

    <br>
    <br>

    <iframe
      width="230"
      height="230"
      frameborder="0" style="border:0"
      src="https://www.google.com/maps/embed/v1/place?key=AIzaSyBJg0HiO2KtvExTuiWB6rKhmUUsHXFk6dY
        &q=<%= @restaurant.address.parameterize %>&zoom=14">
    </iframe>
  </div>
  ...
Alright, this looks good. Let’s save our progress. We’ll run $ git status and then $ git add .. We’ll commit our code to Git with $ git commit –m "Embed Google Map". Then, we’ll push to GitHub with $ git push. Finally, we’ll update our site on Heroku with $ git push heroku master. When that finishes, we’ll run $ heroku open to see our site live.

Command Line
$ git status
$ git add .
$ git commit –m "Embed Google Map"
$ git push
$ git push heroku master
$ heroku open
On the Restaurant Show page, we’ll see that our embedded Google Map works. Perfect!

With this mapping feature set up, we’re nearly done with our site. There’s only one major feature that’s incomplete – that’s the search form that we set up for our navbar many videos ago. In the next video, we’ll work on making this functional.

Set Up Search:
In the last video, we used the Google Maps API to embed a customizable map of our restaurant’s location into our site. In this video, we’ll set up search functionality so we can finally start using the search form in our navbar.

I’ve added a few more restaurants to our site so we’ll be able to search through them later. You can pause the video here and do the same if you’d like.

Search is a pretty advanced concept, but we’ll be working with a great gem called searchkick. Let’s visit the GitHub page now.

Searchkick is the in-house technology that was initially built and now open-sourced by a startup called Instacart, which is a same-day grocery delivery service.

One of the amazing things about the searchkick gem is that it can handle complex search queries. So if users have typos in their search terms, or pluralize their words, or have extra spaces, searchkick is able to figure out what they meant to type.

To set up the searchkick gem, we first need to install something called Elasticsearch. Elasticsearch relies on having Java installed, so if you don’t have Java, you’ll need to download it. We’ll search ‘download java’ and it should show up as the first link. Clicking it should take us directly to the download link.

Once Java is installed, Mac users can run brew install elasticsearch to set up Elasticsearch. Running brew info elasticsearch should show you some information, which will confirm that it was installed correctly. Next, we’ll run the ‘launchctl load…’ command that they give us. Finally, you’ll be able to see that it’s working by going to our browser and visiting localhost:9200. You should see a page that looks similar to this.

If instead you’re using Windows, click on the ‘Install Elasticsearch’ link on the gem page, then ‘download’, and then the ZIP file. When the download finishes, you’ll need to change directory into the ‘elasticsearch’ folder from your command line. We’ll be able to see an example of this if we go to the Elasticsearch site and click on the section called ‘running as a service on windows’. From the command line, you’ll need to cd into the ‘elasticsearch’ folder with whatever version you downloaded, and then cd into the ‘bin’ folder. From here, type the word ‘service.bat’ and hit enter. You should see a list of the keywords you can use. Then type ‘service install’, which will install elasticsearch on your computer. Then type ‘service start’, which will launch the Elasticsearch server. You’ll know it’s running if you visit localhost:9200 and you see a page like this.

Ok, now that Elasticsearch is installed, let’s continue with our setup of the searchkick gem. Back on the gem page, we’ll see that we need to add the gem to our Gemfile. We’ll go to our Gemfile and add gem 'searchkick' at the bottom. Let’s save and run $ bundle install from our command line. We’ll then restart our Rails server.

/Gemfile
gem 'searchkick'
Command Line
$ bundle install
Restart your server

Command Line
$ rails s
Going back to the gem page, the next step is to add the word ‘searchkick’ to the model file we’ll want to search. For us, we want to search our list of restaurants, so we’ll open our restaurant.rb file under app/models/restaurant.rb and we’ll put the word searchkick here and save.

/app/models/restaurant.rb
class Restaurant < ActiveRecord::Base
  mount_uploader :image, ImageUploader

  searchkick

  has_many :reviews

  validates :name, :address, :phone, :website, :image, presence: true
  validates :phone, format: { with: /\A\(\d{3}\) \d{3}-\d{4}\z/,
    message: "must be in the format (123) 456-7890" }
  validates :website, format: { with: /\Ahttps?:\/\/.*\z/,
    message: "must start with http:// or https://" }
  validates :address, format: { with: /\A\d+[^,]+,[^,]+, [A-Z]{2} \d{5}\z/,
    message: "must be in the format 350 Fifth Avenue, New York, NY 10118" }
end
Next, we need to load searchkick with the restaurants from our database. While the documentation says to run Product.reindex, we’ll actually run a different command since that one won’t work from the command line. Instead we’ll run rake searchkick:reindex CLASS=Restaurant In general, we’ll generally only need to run this command once. Searchkick will automatically update itself with any new Restaurants we add to our database.

Command Line
$ rake searchkick:reindex CLASS=Restaurant 
Now searchkick is mostly set up, so to see it in action, we need to get the search form in our navbar to work. It’s a multi-step process, so let’s first create a new URL for the page showing our search results. We’ll go to our config/routes.rb file. resources :restaurants is the code that creates our various restaurant-related URLs. To add a new one, we’ll go to the next line and write:

/config/routes.rb
Rails.application.routes.draw do

  devise_for :users
  resources :restaurants do
    collection do
      get 'search'
    end
    resources :reviews, except: [:show, :index]
  end
…
This creates a new URL at localhost:3000/restaurants/search . The word collection here just means that search will apply to more than one restaurant. If we were instead creating a URL that was applicable to only one restaurant, then we would use the word member. Let’s save this and move on to the second step, where we’ll go to the code for our search form under app/views/layouts/_navbar.html.erb.

The section for the search form appears in the section with the <form> tag. We’ll replace this with some Embedded Ruby for a form of our own. We’ll write:

/app/views/layouts/_navbar.html.erb
…
<%= form_tag search_restaurants_path, method: :get, class: "navbar-form navbar-left" do %>
  <p>
    <%= text_field_tag :search, params[:search], class: "form-control" %>
    <%= submit_tag  "Search", name: nil, class: "btn btn-default" %>
  </p>
<% end %>
…
This code looks complicated, so let me explain what it does. This first line creates a form that’s sent to the new route we created. The method: :get puts the search terms in the URL, which allows other users to use the link to see the exact search results we received. The navbar-form navbar-left class is a Bootstrap keyword that was used to style the original form. These next two lines are used to create the search field and the ‘Submit’ button that we see.

/app/views/layouts/_navbar.html.erb
…
<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
  <ul class="nav navbar-nav">
    <li><%= link_to "About", pages_about_path %></li>
    <li><%= link_to "Contact", pages_contact_path %></li>
  </ul>
  <%= form_tag search_restaurants_path, method: :get, class: "navbar-form navbar-left" do %>
      <p>
        <%= text_field_tag :search, params[:search], class: "form-control" %>
        <%= submit_tag "Search", name: nil, class: "btn btn-default" %>
      </p>
  <% end %>
<% end %>
    <ul class="nav navbar-nav navbar-right">
…
Let’s delete the old search form, save, and move on to the third step, which is to define the ‘search’ action in our controller file. We’ll go to app/controllers/restaurants_controller.rb and create a new section. We’ll write:

/app/controllers/restaurants_controller.rb
…
def search
  if params[:search].present?
    @restaurants = Restaurant.search(params[:search])
  else
    @restaurants = Restaurant.all
  end
end
…
If search terms were entered into the form, this code uses them to search our Restaurants database for any matches. These matches are stored in a variable called @restaurants. If the search form was left blank, then our app will just display all the Restaurants in the database. Let’s save and move on to the fourth and final step, which is to display the search results on its own View Page.

Since we created a new search URL and search action, we need to add a new search View Page to match. In our app/views/restaurants folder, we’ll right-click and add a new file called search.html.erb. Here, we’ll want to display each of our search results in a loop. Rather than write code from scratch, let’s just copy over the table we use on our home page. We’ll open index.html.erb and copy over the code for the table. Let’s paste that in and save. Let’s go to our browser to test it out.

/app/views/restaurants/search.html.erb
<table class="table table-hover table-condensed">
  <thead>
    <tr>
      <th>Name</th>
      <th>Address</th>
      <th>Phone</th>
      <th>Website</th>
      <% if user_signed_in? && current_user.admin? %>
        <th colspan="2"></th>
      <% end %>
    </tr>
  </thead>

  <tbody>
    <% @restaurants.each do |restaurant| %>
      <tr>
        <td><%= link_to restaurant.name, restaurant %></td>
        <td><%= restaurant.address %></td>
        <td><%= restaurant.phone %></td>
        <td><%= link_to restaurant.website, restaurant.website %></td>
        <% if user_signed_in? && current_user.admin? %>
          <td><%= link_to 'Edit', edit_restaurant_path(restaurant), class: "btn btn-link" %></td>
          <td><%= link_to 'Destroy', restaurant, method: :delete, data: { confirm: 'Are you sure?' }, class: "btn btn-link" %></td>
        <% end %>
      </tr>
    <% end %>
  </tbody>
</table>
We’ll search our restaurants for the word ‘Bread’. When we hit enter, we’ll see all the restaurants that have ‘Bread’ in their name.

Even if we mistype and search a keyword like ‘Breads’ or even ‘Brads’, we’ll still see the same list of results. That’s one of the big advantages of using the searchkick gem over some of our alternatives.

It’s time to save our progress. We’ll type git status followed by git add .. We’ll commit our code with git commit –m "Add search functionality". Let’s push to GitHub with git push. And let’s push to Heroku with git push heroku master.

Command Line
$ git status
$ git add .
$ git commit –m " Add search functionality"
$ git push
$ git push heroku master
Before we can see our site live, we need to follow the searchkick instructions for deploying on Heroku. If we go back to the gem page and scroll down, we’ll see a section titled ‘Deployment’. We need to install one of three Heroku add-ons. Let’s go with SearchBox.

We’ll copy this first command and paste it into our command line. In order to install this add-on, heroku needs us to add a credit card to our account. The SearchBox gem operates under a free tier and they just want to make sure you that you’ll be able to pay if you exceed their limits. We’ll go to the URL they provide and add a credit card. When we’re done, we’ll come back to our command line and try running that command again. Now let’s go back to the Gem page and run the second command.

Finally, we’ll copy this last line, replace the word Product with the word Restaurant and hit enter.

We’ll now run heroku open to see our app live. Let’s test to see if it works by searching bread’ in the navbar. Perfect!

Command Line
$ heroku addons:add searchbox:starter
$ heroku config:add ELASTICSEARCH_URL=`heroku config:get SEARCHBOX_URL`
$ heroku run rake searchkick:reindex CLASS=Restaurant
$ heroku open
Now that search is functional, that concludes our yelp demo course. In the next video we’ll share some advice on where to go from here.

Course Summary:
Congratulations on building your finished Yelpdemo app! It certainly wasn’t easy. We built our site from scratch to include restaurant listings with images, user sign-in and sign-out, a database of reviews, clickable star ratings, integration with the Google Maps API, and search functionality.

Along the way, we learned so many skills, everything from navigating the command line to adding new gems to front-end design with Bootstrap. We even touched upon databases, image hosting with Amazon S3, and live deployment with Heroku.

Now every app is different, but I hope you were able to see from our customization that regardless of what kind of app you’ll be building, there are plenty of helpful gems, APIs, and other resources available online to help you.

So where should you go from here? I highly recommend checking out some of the individual videos to see some ways to further extend the app you’ve built. For example, you should consider adding pagination to our site so that a restaurant with thousands of reviews can be shown in multiple pages.

You should also consider doing the other full-length projects so you can cement your new knowledge by seeing how the same concepts apply to different ideas. Believe me, once you’ve built a few of these full-featured apps, you’ll be well on your way to having a solid understanding of Ruby on Rails.

When you feel ready, try building out an idea of your own. Feel free to post any general questions you have or advice you need in our Ask a Developer forum.

Finally, I’d love to hear from you! Email me at alex@baserails.com and tell me what you thought of the course. I’d also love to hear about additional content you want to see, or any projects you’re working on building now. Seeing your ideas come together is a huge inspiration for us here at BaseRails. Thanks for taking this course!





#Browse Our Feature Library
Back End Features
Add a Facebook 'Like' Button
Once you’ve launched your site, your next challenge is to let the world know about it. One of the lowest-effort ways to do that is to give your users the ability to spread the word on Facebook. In this video, I’ll show you how to add buttons to your site for people to like or share on Facebook.

First you should go to this URL: https://developers.facebook.com/docs/plugins/

Here you can see the social plugins Facebook offers for developers to add to their own websites. I’ll click on the first one, the Like button. Now I’ll fill in the form to select my own customizations. First, let’s plug in the URL that the users will be Liking. Since I just completed my Etsydemo application, I’ll copy over that URL and paste it in here. I can optionally set the width of the plugin, but I’ll leave it blank to use the default. Facebook offers a few different layout options. For example, the box count shows the number of Likes in a box while the button count shows the number of Likes right next to the button. Finally, the button option will show the button only, without showing the number of Likes. I’ll go with the button count option. I can also toggle between Like and Recommend. I’ll leave it as Like here. And finally, I can decide whether to display profile pictures of the user’s friends who have already Liked the page, and I can decide whether to include an additional Share button.

Once I’ve got all my settings right, I’ll click “Get Code” and Facebook will tell me to do two things. First, I need to add some code to my site so my app can communicate with Facebook. I’ll copy over this code, and in my Sublime Text I’ll go to my app/views/layouts/application.html.erb file. Right below my <body> tag, I’ll paste it in. I’ll tab it in one.

Leaving it like this is fine, but my application layout file can start to feel cluttered if I’m connected with a lot of APIs, so I prefer to hide this away in a partial file. If you’ve gone through the Etsydemo course, you’ve seen this before. I’ll create a new file in my layouts folder called _facebook.html.erb. The underscore tells Rails that this is a partial file. Inside my new file, I’ll paste in my Facebook code. To make sure this gets included in my application layout file, I’ll need to add the following line. So first I’ll save here, and back my in my layout file I’ll write: <%= render 'layouts/facebook' %> and I’ll save. Great – that looks a lot cleaner now.

Lets go back to our Facebook instructions. The next step is to paste the second piece of code wherever we want our Like button to appear. Since I want mine to appear at the bottom of the home page, I’ll copy this and go to my app/views/listings/index.html.erb file. I’ll add a <br> tag at the bottom, and I’ll paste this code in at the bottom of the file. Let’s save and see how it looks in localhost. Looks pretty good, and you can see when I click it that the number changes from 0 to 1. I can also un-Like it by clicking the x.

Although the button is functional, it could look a lot better if we centered it over here. During the Etsydemo course, I already defined a CSS class called center. We can see that under app/assets/stylessheets/custom.css.scss. And here we have the center class. So I’ll go back to my index.html.erb code, and I’ll wrap my Like button in a <div class="center">. I’ll tab this in, and I’ll close the <div> tag here. After saving, we can we go back to see how it looks. Much better! This will look even better with a Twitter button right next to it, so make sure you check out the other BaseRails video showing how to do this.


Add Categories - Part I 
Add Categories - Part II
Add Categories - Part III
Divide Your Content With Pagination

#Deployment
Monitor Your Site and Load Pages Faster
It’s a great feeling to finish coding your app and deploy it live for everyone in the world to visit. However, you’ll want to know immediately if your website is down, so it helps to use a website monitoring service that can send you instant email notifications. And if your hosting your app for free on Heroku, doing this will have the side benefit of eliminating any long delays when you’re loading your page for the first time in a while.

In this video, I’m going to introduce to you to an amazing free service called “Uptime Robot” that will not only monitor your app, but also get rid of this annoying Heroku loading delay. If I visit an app that’s hosted for free on Heroku, it can sometimes take a long time to load. I’ll use an app I created called “Six Spoons” to demonstrate the delay I’m referring to. I’ll go to sixspoons.herokuapp.com. And as you can see, it’s taking a while. As we wait for it to load, let me explain to you why this is happening. If a website hosted for free on Heroku is inactive for more than an hour, the app will go to sleep. As soon as the next user visits the site, it takes around 30 seconds to awaken the app again. This isn’t a problem if you’re getting at least one visitor per hour, but when you’ve just deployed your app, you wouldn’t want your early users to deal with a 30 second delay each time they visit. Uptime Robot solves this problem by automatically visiting your site once every five minutes. This prevents your app from going to sleep and therefore eliminates the delay that users experience. There are actually a few options when it comes to website monitoring, but I recommend Uptime Robot because it’s free, it does its job, and it only takes a few minutes to setup. In fact, it’s one of the first things I’ll do after deploying any website.

Let me show you how it works. I’ll go to uptimerobot.com. And after you sign up, you’ll be sent an email to confirm your account. After you’ve done that, you’ll be able to login. I’ll login with alex@baserails.com. And now to setup monitoring for your app, just click on “add new monitor.” I’ll select HTTPs as my monitor type. You’ll then be able to choose a friendly name to be displayed in your dashboard. I’ll put “SixSpoons.” And now enter your website’s URL. So I’ll copy this, you’ll notice that it’s HTTPs. And I’ll paste it in here. And now select your monitoring interval. I’ll leave this at the default five minute interval. A really interesting feature of Uptime Robot is that it can even work for websites that require you to login. If you want, you can fill in a username and password to give access to Uptime Robot. Finally, I recommend checking the box here so you’ll be sent an email notification whenever Uptime Robot sees that your site is down. Now click “create monitor” to finish. If I close this dialog box, I’ll see that SixSpoons has now been added to my dashboard. In just a few minutes, Uptime Robot will start monitoring whether SixSpoons is up or not. With monitoring setup, you’ll know immediately if any tinkering you’ve done with your code has caused the website to break, and you’ll never need to deal with Heroku’s 30 second delay again. Now if I open a new tab, and I go back to SixSpoons, you can see how quickly it loads. Uptime Robot will make sure all your users will able to experience this fast load time.


#Front-End Design
Add Glyphicons to Your Buttons
One of the little front end things that can go a long way toward making your site look more professional is to incorporate glyphicons. Glyphicons are little icons or symbols that you can easily add to dress up buttons, forms, or other elements. In this video, I’ll show you how to add a glyphicon to a button. One of the main reasons why its easy to work with glyphicons is that many of them are already available through bootstrap. You can find them by going to the bootstrap website at getboostrap.com. Here you can go to the components tab on top. You’ll see there are all kinds of glyphs to choose from. Ranging from a star, to a trash icon, even to things like a shopping cart. If these aren’t enough, you can find even more on the glyphicons website.

If we go back to the bootstrap page and we scroll down, you can see that bootstrap provides some documentation about how to use glyphicons in a button. But our process is a little different, because our code is a mostly written using rails helpers like “link to”, not straight HTML. I’ll assume that you finished at least half of the Etsy demo course, but as long as you have a good understanding of how the “link to” helper works, you should be fine. Lets start with a newly completed Etsy demo application. As you can see in my localhost, I already have a new listing button on the home page where I’d like to add a glyphicon. I’ll go to my view page code under app/views/listings/index.html.erb. You can see the code that produces the button here <%= link_to "New Listings", new_listing_path, class: "btn btn-primary", data: { no_turbolink: true } %> where it says “link_to,” the name of the link, the route that the link directs to, the class that we need to add to create the bootstrap style button, and finally an additional option that turns off the rails turbo links feature. Don’t worry if you don’t know what that is. Adding a glyphicon is simple. I’ll first comment out this line of code and I’ll begin writing my own. I’ll write: <%= link_to new_listing_path, class: "btn btn-primary", data: { no_turbolink: true } do %>

On the next line, I’ll tab it over and I’ll write: <i class=""> 
And here I’ll need the name of the specific glyphicon I want to add. So going back to the bootstrap page, if I want to add, say, the “plus” for a new listing, I’ll copy over this glyphicon glyphicon plus code and I’ll paste it in here. Now I’ll close off this </i>, I’ll put a space, and now I need to put the text I want on the button, in this case its going to be “new listing”. On the next line, I’ll put an <% end %> statement to close out the “do” I had from earlier. If I save, I can now go to my localhost and refresh the page. You can see the glyphicon has now been added. Don’t go overboard with using glyphicons, but its pretty amazing how much of a difference these small but nicely designed symbols can make on your site.

/app/views/listings/index.html.erb
...
<%= link_to new_listing_path, class: "btn btn-primary", data: { no_turbolink: true } do %>
  <i class="glyphicon glyphicon-plus"></i> New Listing
<% end %>
...


#Internationalization
Part1: Display Non US Currency and date standard
Part2: Set default standards for non US country
Part3: Switch between standards for multiple countries
Part4: Translate Your Content Into Multiple Languages


Web Scraper Course Page
1.Introduction
Intro to web scraping
Hey there! Welcome to the BaseRails web scraping course. In this introduction video, we’ll talk about what web scraping is, why it’s incredibly useful, and get a quick look at what we’ll be working on during the rest of this course.

All right, let’s start from the top – what is web scraping? It’s what we use if we want to gain access to the vast amounts of data on the Internet. For example, a site like Amazon stores a ton of product data in its massive database. Unfortunately, we don’t have permission to just open up their database and explore around. We’re limited to viewing a little bit at a time through the search and browse functionality of the Amazon website. We can see the detailed data they have on an individual product, or some basic information for up to 20 products at a time. But there’s no way for us to aggregate all the data in one place unless we manually go through each page, copy the information we see into a database, and do this many, many times.

That’s where web scraping is really useful. With web scraping techniques, we can program our computer to visit many different Amazon pages at once, collect the data we want, and store it for us. Once we have this data available in our own personal database, there’s so much more that we can do. We could analyze the data to figure out things like the average price of HDTVs or identify the highest rated products on Amazon. We could even build a web app around this data. In fact, if we go to toppp.com, we’ll see that someone did just that. This site sorts the products available on Amazon so that users can browse the highest rated products in specific categories, or even overall. Users that click a product get taken directly to Amazon. Any purchases they make generate money for toppp.com through Amazon’s affiliate program. You can see how with web scraping and a simple interface, you can provide immediate value for your users.

So now that we’ve seen the high level picture of what web scraping is and why it’s useful, for the rest of this video, let’s quickly run through the project that we’ll be working on. After installing the software we need, we’re first going to learn the basics of web scraping by collecting data from Wikipedia. Once we have this under our belt, we’ll turn our attention to this course’s main project. We’re going to write a script to visit many different pages of the vacation rental site, Airbnb, and scrape information on the listings that we find, like the heading, location, and cost per night. We’ll then have our script store this info in our own Excel spreadsheet where we can play around and analyze the dataset. What you choose to do with the data that we retrieve is up to you!

Okay, in the next video, we’ll get started by learning to find the information we want by searching through the HTML of a Wikipedia page.

2.Identify and collect data
find data within html
In this video, we’ll be scraping a Wikipedia article on players and teams in the NBA. We’ll walk through the process our program will follow by manually stepping through some HTML code to find the pieces of data we need. All of this will lay the groundwork for us to start coding our script next time.

Let’s start by going to wikipedia.org and searching ‘List of current NBA team rosters’. This page basically consists of a table of contents on top, followed by a bunch of tables, one for each team in the NBA. All the information we see on this page is available to be scraped – that’s because every webpage is built using HTML and we’ll be able to find all of this data in the HTML code.

If you’re unfamiliar with HTML, it’s the code that forms the backbone of every website on the Internet. The structure of each page – like the number of rows and columns in this table, and the text that goes in each cell – this is all determined by the code behind the page.

Now HTML isn’t very friendly to the human eye. We can see what it looks like from within our Chrome browser by right-clicking and selecting ‘View page source’. It’s a mess. But if we look closely, we’ll see some parts that start to look familiar. For example, if we scroll down, we’ll see a section with “Eastern Conference”, “Atlantic Division”, “Boston Celtics”, etc. This part of the HTML code is used to create the table of contents at the top of the page.

The most important thing to remember when reading HTML is that it’s very structured, even if it seems like a mess at first. So looking at the code for the “Boston Celtics”, we’ll see <li something something>, <a something something>, <span something something>. HTML uses these things called tags to annotate, or mark up, the text so that the computer knows how to display it to the user. This <li> tag tells our browser that this is an element of a list, the <a> tag makes “Boston Celtics” into a link, and the <span> tag is used to add some formatting to specific sections of the page.

And remember that every opening tag will have a matching closing tag. So the <li> tag has a corresponding </li> tag, and the <a> tag has a </a> tag, and the <span> tag has a </span> tag. Here, the ‘/’ just means ‘close’. HTML becomes a lot easier to decipher when you start recognizing these matching opening and closing tags.

Learning to read HTML is important because we need to get good at finding the data we want that’s scattered throughout this code file. For example, if we wanted to pull out the names of every team in the NBA, we would need to identify the patterns that will help us find the data we need. In this case, it looks like the common thread is that they all fall on a line that starts with the tag <li class="toclevel-3 something">. If we type Command-F (or Ctrl-F if you’re on Windows), we can search li class="toclevel-3 and we’ll see that there are 30 results, which is perfect because there are 30 teams in the NBA.

If we had searched li class="toclevel-3 tocsection-3", we’d be too specific, capturing “Boston Celtics” and missing out on the other 29 teams. And if we had searched li class="toclevel, we’d have captured the conference names and division names in addition to the team names. The key is to find patterns that capture data at the specific level of detail that we want.

Essentially, web scraping boils down to the process of automating this Command-F routine so that a computer can search for the keywords we want and store them in a database for us.

Let’s try another example. This time, let’s grab the names of every player listed on an NBA roster. While we could search our HTML for Bass, Brandon, this time we’ll use a different approach. Let’s right-click on the text we want and choose “Inspect Element”. On the left, we’ll see the exact HTML that was used to render this text. It looks like the Bass, Brandon is nested inside a <td style="text-align:left;">, so we’ll go back to our source code and search <td style="text-align:left;">.

Your number may be higher or lower than mine, but I got 447 results. Since each team should have around 15 players, with 30 teams total, 15 times 30 is 450 so we’re definitely in the right range. Good – it looks like our search term was just specific enough.

Now that we’ve had a little practice with reading HTML code and using patterns to find the information we need, we’re ready to move on to the next video, where we’ll start writing a program to automate what we’ve done so far by hand.

create and run script
In the last video, we looked at a Wikipedia page and identified patterns in the HTML code to find important information, like the names of NBA teams and players on the roster. This time, we’ll use the patterns that we’ve identified to write a Ruby script to grab all this data for us.

Let’s start by opening up Sublime Text. Let’s save this file. I’m going to save this in my root directory as wikipedia_scraper.rb. Your root directory is whichever folder shows up by default when you open your Command Line.

What we’re going to do is first store all the HTML from the Wikipedia page onto our computer. Then, we’re going to pull out the specific information we want by selecting the right HTML tags.

I’ll try to always type out some code first, and then explain what I’m doing. If you’re new to Ruby or just new to programming in general, I recommend not worrying if you don’t understand everything 100% the first time around. This is one of those things where as you gain more experience, you’ll start to see which concepts are important to understand and which ones you can just accept as fact.

Let’s type some code:

wikipedia_scraper.rb
require 'open-uri'
require 'nokogiri'
 
url = "http://en.wikipedia.org/wiki/List_of_current_NBA_team_rosters"
page = Nokogiri::HTML(open(url))
Okay, let me explain what we’re doing here. At the top, we have these two require statements. Open-uri and nokogiri are examples of two Ruby gems. Gems are prepackaged code files that allow us to use powerful features that others have already written and shared. This saves us a ton of time because we don’t need to build these features ourselves from scratch.

The open-uri gem lets us access the content from different URLs from inside our text editor. It was installed by default when we installed Ruby so we just need to write require to use its features.

Nokogiri, which is named after a type of precise Japanese saw, is a gem that helps us read and search the HTML code of a webpage. Unlike open-uri, nokogiri was not installed by default, so in order to use it, we need to open our Command Line.

From here, type ‘gem install nokogiri’ and hit Enter. This process might take a while, but we’ll be able to use Nokogiri’s features from within our script.

Command Line
$ gem install nokogiri
*If you’re having trouble installing nokogiri, take a look at this link*

Going back to our code, we’re now storing our Wikipedia article’s address in a variable called url. Variables are words that store information so we can access it later on by simply calling that specific word.

And on the next line, we’re using both nokogiri and open-uri to open the URL from above and store the HTML code in another variable called page. I know that’s a lot to digest, so don’t worry about syntax for now (things like why we use two colons here) and instead focus on understanding the high-level steps that we’re doing.

Finally, we’ll add one more line: puts page. puts (which stands for ‘put string’) will display the HTML code that’s stored in the page variable on our screen. Lets save.

wikipedia_scraper.rb
require 'open-uri'
require 'nokogiri'
 
url = "http://en.wikipedia.org/wiki/List_of_current_NBA_team_rosters"
page = Nokogiri::HTML(open(url))

puts page
Together, the code we’ve written makes up our script which we can run through our command line. We’ll need to navigate to the location where our wikipedia_scraper.rb is stored. Mine is saved in my root directory, alexyang, so I’ll type ruby wikipedia_scraper.rb to run the script and hit ‘Enter’.

Command Line
$ ruby wikipedia_scraper.rb
What is all this? If we look back at our script, we’ll see that we wrote puts page, which displays all the HTML code that’s stored in the page variable. This is the entire content of the Wikipedia page in HTML format. In our Command Line, we can scroll up and see some <li> tags and <div> tags, so we know that we’re looking at HTML.

Now while this is difficult to read, we’ve actually taken a really important step. With all the HTML code stored in the page variable, we can now use nokogiri to pull out only the specific data we want. We’ll learn how to do that in the next video.

3.scrape web data
scrape wikipedia tables
Last time, we were able to display the HTML code of our Wikipedia page in our command line. In this video, we’ll learn how to scrape specific pieces of information by selecting the right HTML tags that contain the information we want.

Let’s go back to our code and change puts page to puts page.css('a').

wikipedia_scraper.rb
require 'open-uri'
require 'nokogiri'
 
url = "http://en.wikipedia.org/wiki/List_of_current_NBA_team_rosters"
page = Nokogiri::HTML(open(url))

puts page.css('a')
Let’s save and run our script again.

Command Line
$ ruby wikipedia_scraper.rb
This time, rather than see all the HTML, we’ll see only the sections with an <a> tag. In HTML, the <a> tag is used whenever we want to add a link so this is really a list of every hyperlink on the page. For example, we can see there’s a link to the ‘About Wikipedia’ page and here’s another to the ‘Wikimedia Foundation’. Back in our browser, we’ll see these links at the bottom of the page. And from looking at our script, it was just this .css('a') that allowed us to select all the <a> tags.

Let’s revise our script again to scrape the names of all the NBA teams. If you remember from last time, each team name can be found on a line that starts with <li class="toclevel-3…, so we’ll replace .css('a') with .css('li.toclevel-3').

wikipedia_scraper.rb
…
puts page.css('li.toclevel-3')
In English, this code means find every <li> tag with a class of toclevel-3. The dot just means class. So this time we aren’t looking for all <li> tags, just those with the toclevel-3 class, which we know corresponds to the NBA team names. Let’s save and run this script again.

Command Line
$ ruby wikipedia_scraper.rb
This time, we got a list of just the lines of code containing the NBA team names. Going back to our browser, we can look at the page’s HTML code and see that our list matches.

Let’s now try doing the same thing for the list of NBA players. We know from last time that each name is on a line that starts with <td style="text-align:left;">. The syntax for matching this in Ruby is .css('td[style="text-align:left;"]').

wikipedia_scraper.rb
…
puts page.css('td[style="text-align:left;"]')
Why do we use this bracket format here instead of the period from the last example? The rule of thumb is that if it’s a class, you should use a .. If it’s an id, you should use a #. And if it’s anything else, you’ll need to use a []. The syntax here is TAG_NAME[ATTRIBUTE_NAME="ATTRIBUTE_VALUE"].

Let’s save and run our script again.

Command Line
$ ruby wikipedia_scraper.rb
We have a list with a ton of NBA names, some of whom you might recognize, like Kobe Bryant, Chris Paul, and Blake Griffin. But let’s make this a little easier to read by displaying just the player’s name without any of the surrounding HTML. To do that, we’ll go back to our script and add a .text at the end.

wikipedia_scraper.rb
…
puts page.css('td[style="text-align:left;"]').text
.text is a special method in Ruby that takes a line of HTML and pulls out the text from the code. For example, in this line of HTML, the words Bass, Brandon are the only part that are not inside an HTML tag. Let’s save and try it again.

Command Line
$ ruby wikipedia_scraper.rb
That’s sort of what we wanted. Only the text names are appearing now, but there aren’t any line breaks in between.

A way we can print each name on its separate line is to run our code through a loop. A loop is a sequence of instructions that gets continually repeated until it finishes or when we tell it to stop after a certain point.

Let’s write our first loop. We’ll get rid of puts and delete .text and write .each do |line| followed by puts line.text and then end.

wikipedia_scraper.rb
…
page.css('td[style="text-align:left;"]').each do |line|
  puts line.text
end
The .each here is a special Ruby method just like .text. If we have a list of many things, then the .each combined with do and the variable line creates a loop so we can run the same process for every item on the list. In our case, we have a list of many lines of HTML. And for each of those lines, we’re going to run puts line.text, which will display only the text name instead of the entire HTML line. Finally, the word end means that our loop is done.

Note that I chose to name my variable line here because it describes what our list contains, lines of HTML code, but I could just as easily replace these two @line@s with something else, like code or i or even potato.

The reason using this loop will add line breaks after each name is because the function puts always prints on a new line. Before when we were just running puts once, everything showed up on the same line. Now that we’re running through a loop hundreds of times, each name is being printed on its own line.

This is a lot to digest. In just 3 lines of code, we’ve learned about variables, methods, functions, and loops. It will take a while before the syntax will start to make sense, but when we continue working through this course, you’ll see the same concepts repeated over and over again. This will help you learn to read code, which the first step towards writing code of your own.

Let’s save and run this script again.

Command Line
$ ruby wikipedia_scraper.rb
There we go. We just scraped the names of every player listed on an NBA roster. Wikipedia even gives us these C’s and S’s, which denote whether that player is a captain of the team or currently suspended.

Although this was a pretty simple example, it shows the power of the Nokogiri gem in scraping webpages. There’s so much more that you can do in terms of selecting HTML tags and narrowing your search to specific classes, ids, and other data attributes. We’ll see more of that in the next video, as we begin our main project of scraping the Airbnb platform.

scrape airbnb listings
Last time, we got some practice reading HTML and scraping information from Wikipedia. Now let’s put those skills to use and as a more practical example, let’s take a look at scraping Airbnb. For those of you who are unfamiliar, Airbnb is an online vacation rental platform. Hosts list their properties on the site for travelers to book as an alternative to staying in an expensive hotel.

For example, if we wanted to see the available listings in Brooklyn, we would type it in the search bar, select Brooklyn NY, United States, and hit ‘Search’. On the left, we have a map displaying the locations of the listings and on the right, we’ll see a list with information for those same listings.

Now when we set out to scrape data from a site, it’s important to be really observant and get a sense for how the site is structured. We have to look at things like what data is useful, which pages contain that data, the structure of the URLs, and so on.

Let’s start with the data that’s available to be scraped. For each listing on the right, it looks like they all follow the same format. We can see the daily rate, the heading, the type (whether it’s a private room or an entire home), the number of reviews, and the location. We can also see a bunch of images of the listing as well as an image of the host.

This data could be really useful if we wanted to run any kind of analysis. For example, let’s say we were looking to put up our own listing and wanted to see the average pricing for private rooms available in our Brooklyn neighborhood of Greenpoint. By the end of this course, we’ll be able to analyze the data we’ve scraped and figure out how to price our listing.

We could also use this data to create a web app based on the same data set, but with an improved or different user experience. Sort of like how the site Hipmunk offers a new way to search for flights or how SeatGeek created a better way to buy tickets to live events.

Let’s turn our attention to Airbnb’s URL structure. We have airbnb.com/s/Brooklyn--NY--United-States?source=bb. If I had to guess the format, I’d say that the s stands for ‘search’, followed by / and then the location, but I’m not sure about this source=bb part. Let’s try deleting that from the URL and hitting ‘Enter’. The page appears to be the same, so since the source=bb doesn’t seem to affect anything, we’ll just leave it out. Given this format, we should be able to scrape listings from any location, as long as we replace Brooklyn--NY--United-States with the location of our choosing.

Now that we know the URL we want to scrape, let’s remember to check Airbnb’s scraping policies. This is something we’ll need to do before we scrape any website to make sure we’re not violating any of its rules. To check this, most sites have a page called robots.txt that sets what its scraping policies are. On the other hand, if a site you’re interested in scraping doesn’t have this file, that means you should be fine to go ahead.

For Airbnb, we’ll go to airbnb.com/robots.txt and we’ll see a pretty cool ASCII image of their logo at the top. The way to read a robots.txt file is to first check the User-Agent and then see which pages on the site are Allowed or Disallowed from scraping. Here, the asterisk after ‘User-Agent’ means that the rules below apply to everyone. But every site can set different policies for different people. For example, Airbnb could choose to give greater permission to Googles’ scrapers (which it uses to index the Internet) versus other people trying to scrape their site.

The URL that we want to scrape, /s/Brooklyn--NY--United-States, doesn’t show up under either “Allow” or “Disallow”. Since it was omitted, we should be able to safely scrape this page.

Ok, let’s start writing our script. We’ll open Sublime Text and save this new file. I’ll call mine airbnb_scraper.rb and save this in my root directory, ‘alexyang’, but you can save this anywhere. In this new file, let’s write the following. I’ll take a moment to add some comments and then briefly explain what we’re doing.

airbnb_scraper.rb
require 'nokogiri'
require 'open-uri'
 
# Store URL to be scraped
url = "https://www.airbnb.com/s/Brooklyn--NY--United-States"
 
# Parse the page with Nokogiri
page = Nokogiri::HTML(open(url))
 
# Display output onto the screen
puts page
This code should look familiar as we wrote a similar one for scraping the Wikipedia page of the NBA roster. I’ll go over each line again so you can begin to recognize the patterns.

These first two lines give us access to the scraping features of the nokogiri and open-uri gems. We’re storing the address from the page we’re scraping in a variable called url. We’re doing this so that if we decide to change the page we want to scrape later on, we’ll only need to change this single line of code. Now we’re handing off this URL for Nokogiri to read and all of the HTML of the page will be stored in the page variable. Finally, at the bottom, we’ll display the data we scraped on our screen.

These #s are a way for us to write comments to ourselves or other developers. The # just lets our computer know to ignore the text that comes after it on the same line. Since our script will eventually get to be pretty long, I’m using these comments to remind us what each line of code does.

Let’s try this out. To run this script, we’ll head to our command line and make sure we’re in the right folder. Since I placed my script in my root directory, ‘alexyang’, I can just run ruby airbnb_scraper.rb directly from here.

Command Line
$ ruby airbnb_scraper.rb
Okay, like last time with Wikipedia, we got a ton of HTML. This is the HTML code from the Airbnb search results for Brooklyn.

This is a lot of information so instead of displaying the entire page, let’s scrape just the name of each listing. If we go to back to the Airbnb site and right-click on the first listing name and hit “Inspect Element”, we’re taken to the HTML of the page.

Let’s think about the HTML selector we would use to get data for all the listing names. If we scrape this <div> with title=... we’d only scrape this one listing because the name is too specific. And if we scrape just class= "h5", we’d get all the HTML content with a header size of 5, which is probably too broad. But if we use the two classes h5 and listing-name together, that might work. In web scraping, it’s often a trial-and-error process to find the HTML selectors that fall in a sweet spot, not too general and not too specific, so they can grab the information we want. Let’s try this out.

We’ll look at the full HTML code by right-clicking and selecting ‘View Page Source’. Now let’s type Command-F or Control-F and search h5 listing-name. It looks like it’s finding the names of the listings. It also says it found 18 matches, and if we scroll down to the bottom of the search results page, we’ll see that that matches exactly. Great – it looks like this selector works.

Now let’s go to our Sublime Text and write:

airbnb_scraper.rb
…
# Display output onto the screen
puts page.css('div.h5.listing-name')
This code just means find and display every <div> tag with the two classes h5 and listing-name. We’ll need multiple periods when we select for two or more classes at once.

Let’s save and run it to see the results.

Command Line
$ ruby airbnb_scraper.rb
Great – we can see how the listings’ names match the same ones on Airbnb.

Let’s now write a loop to display just the listing name without the HTML, with each on a separate line.

airbnb_scraper.rb
…
# Display output onto the screen
page.css('div.h5.listing-name').each do |line|
  puts line.text
end
This is the same loop we ran earlier for the Wikipedia page of NBA players. This time, the HTML selectors are different because they’re targeting the Airbnb listing names. Like last time, the .each do |line| creates the loop and we’re using the .text method to display just the listing name itself without any of the HTML.

Let’s save and run this again.

Command Line
$ ruby airbnb_scraper.rb
There are 18 listings here and the text is the same, which means we grabbed the right HTML selectors.

Let’s go ahead and scrape the rest of the categories on this page. Back on Airbnb, we can right-click on the price and select “Inspect Element”. This <span> tag with the two classes h3 and price-amount seems promising.

In our code, let’s write:

airbnb_scraper.rb
…
# Display output onto the screen
page.css('div.h5.listing-name').each do |line|
  puts line.text
end

puts page.css('span.h3.price-amount')
Let’s save and run this.

Command Line
$ ruby airbnb_scraper.rb
We now see all the HTML code corresponding to the listing prices, but like we did last time, let’s write a loop to run through each line of code and display just the number on its own line.

airbnb_scraper.rb
…
# Display output onto the screen
page.css('div.h5.listing-name').each do |line|
  puts line.text
end

page.css('span.h3.price-amount').each do |line|
  puts line.text
end
We’ll save and re-run our script.

Command Line
$ ruby airbnb_scraper.rb
Good – we have 18 prices listed and they correspond with the listing prices on the Airbnb site.

Let’s do the same thing for the listing’s details. We’ll ‘Inspect Element’ and use the <div> tag with all three of these classes: text-muted, listing-location, and text-truncate.

In our script, we’ll write:

airbnb_scraper.rb
…
# Display output onto the screen
page.css('div.h5.listing-name').each do |line|
  puts line.text
end

page.css('span.h3.price-amount').each do |line|
  puts line.text
end

puts page.css('div.text-muted.listing-location.text-truncate')
Let’s save and run this.

Command Line
$ ruby airbnb_scraper.rb
Looks good, so let’s convert this into a loop like before:

airbnb_scraper.rb
…
# Display output onto the screen
page.css('div.h5.listing-name').each do |line|
  puts line.text
end

page.css('span.h3.price-amount').each do |line|
  puts line.text
end

page.css('div.text-muted.listing-location.text-truncate').each do |line|
  puts line.text
end
Let’s save and run it again.

Command Line
$ ruby airbnb_scraper.rb
This gives us the listing details, including the room type, the number of reviews, and the location. The three of these come grouped together in the HTML code, so we can’t use our usual scraping techniques to separate them. We’ll have to resort to something called parsing to split these apart. We’ll learn how to parse this later on, but let’s hold off for now.

We’ve already done a lot this time. We checked Airbnb’s robots.txt file to make sure we weren’t violating their scraping policies. Then we wrote our script to collect each listing’s name, price, and details. Next time, we’ll take the data we’ve collected and store it into a spreadsheet by making some revisions to our script.

4.store data
write data to csv file
In the last video, we scraped the first page of listings on the Airbnb site for places to rent in Brooklyn. In this video, we’re going to export our data into a CSV file so we can begin to analyze the information using Microsoft Excel. A CSV file, which stands for comma-separated values file, is just like the spreadsheet-version of a text file. It contains many values which are each separated by a comma, so when a program like Excel reads the file, each of those values get placed in its own cell.

Let’s start by telling our script to use the ‘csv’ gem that comes installed by default with Ruby.

airbnb_scraper.rb
require 'nokogiri'
require 'open-uri'
require 'csv'
 
# Store URL to be scraped
url = "https://www.airbnb.com/s/Brooklyn--NY--United-States"
 
# Parse the page with Nokogiri
page = Nokogiri::HTML(open(url))
 
# Display output onto the screen
puts page
This gem allows us to create CSV files as well as read information from existing CSV files.

We’re now going to take each of the pieces of information we’re scraping and assign it to a variable. For the first one, let’s call the variable name because we’re storing information about each listing’s name. This is the same process we used to assign information to the variables url and page.

We’ll write name = [ ]. This is saying that the variable name is going to be an array, which is represented by these open square brackets. An array is just a collection, allowing us to store multiple data points in a single variable. This array is currently empty because we haven’t written anything inside the brackets.

Next, we’re going to change the process that occurs each time our data loops through. We’ll replace puts line.text with name << line.text.

airbnb_scraper.rb
…
# Display output onto the screen
name = []
page.css('div.h5.listing-name').each do |line|
  name << line.text
end
…
This << symbol means to take the thing on the right, in this case, it’s the text within each line of HTML, and then add it to the variable on the left, name. Each line of HTML will go through this process so that by the time our loop finishes running, each of the 18 Airbnb listing names will have been added into our name array.

Like before, let’s assign a variable to this called price. We’ll write:

airbnb_scraper.rb
…
# Display output onto the screen
name = []
page.css('div.h5.listing-name').each do |line|
  name << line.text
end

price = []
page.css('span.h3.price-amount').each do |line|
  price << line.text
end
…
Here, we’re saying that the variable price will also be an array. To fill this array, we’re going to find in the HTML all the span tags with the two classes h3 and price-amount and add the text of the results into the ‘price’ variable.

Let’s do the same thing for the listing details.

airbnb_scraper.rb
…
# Display output onto the screen
name = []
page.css('div.h5.listing-name').each do |line|
  name << line.text
end

price = []
page.css('span.h3.price-amount').each do |line|
  price << line.text
end

details = []
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text
end
Great. So what we’ve done so far is assigned each category of data we’re scraping into these three separate arrays. We’ll now be able to access that data simply through the variable itself.

Let’s change this comment as well to say # Store data in arrays.

airbnb_scraper.rb
…
# Store data in arrays
…
Let’s now write the code to actually create the CSV file and fill it out with the data we’ve collected. I’ll write the code first and explain it afterwards:

airbnb_scraper.rb
…
# Write data to CSV file
CSV.open("airbnb_listings.csv", "w") do |file|
  name.length.times do |i|
    file << [name[i], price[i], details[i]]
  end
end
This first line is saying to open a file called airbnb_listings.csv in our current folder (or create it if it doesn’t exist already) and store it in the variable called file. Now the w here stands for “write” and this just means we’re writing, or adding, information into the file. The letter we use decides what privileges we want to have when working with this file. So instead of w we could also use r, which would allow us to read existing data from the file. Another popular one is a, which stands for append. The only difference between ‘write’ and ‘append’ is that ‘append’ adds data to the end of a file whereas ‘write’ will overwrite any data that exists already.

We’ll notice that the syntax in the first line looks similar to that of loops, with the do, variable, and end at the bottom. But it’s missing something. In order to make a loop, we need a method like .each or .times, and this doesn’t have that, which means this isn’t a loop and will only occur once. In this case, it gives us permission to write to the file until we hit the end at the bottom, when the file will be closed.

The next three lines create a loop because it has all three elements, a method, this do and a variable. This loop is different from our previous loops because instead of a .each method, we’re using this .times method. We use .each when we have a list of things and we want to do the same thing to every item on the list. .times is when we have a specific number in mind and we want to run the loop that number of times.

So this loop is saying do the below action 18 times. It’s 18 because that’s the number of data points in our name array. The first time we go through the loop, we’ll have this variable i that will equal 0, the next time it’ll be 1, then 2, and so on. Since we’re running this loop 18 times, i will run from 0 to 17 (remember that computers always start counting at 0).

Now what are we actually doing 18 times? In this line, we’re adding a new row of data to our airbnb_listings.csv file. This row has three columns. The data for the first column will come from our name array, the second from our price array, and the third from our details array.

Our first time through the loop, i will equal 0, so we’ll be adding the first name, first price, and first set of details to our spreadsheet. The second time through the loop, i will be 1, so we’ll be adding the second name, price, and details. So basically, we’re adding the name, price, and details for each of our 18 Airbnb listings.

Let’s save and finally run the code by typing ruby airbnb_scraper.rb.

Command Line
$ ruby airbnb_scraper.rb
This time, nothing shows up on the screen because rather than displaying the data here, we’re writing all of it into a CSV file. But that doesn’t mean it didn’t work! If we go to the same folder that our airbnb_scraper.rb file is in (in my case, that’s my ‘alexyang’ folder), we should see a file called airbnb_listings.csv. Let’s go ahead and open it with Excel (or if you don’t have Excel, with Google Drive).

This looks great! If we double-check with the Airbnb website, we can see that these listings match up exactly with the ones on the page.

One last thing we can do to make our CSV file better is to add titles to our columns. Back in our code, let’s add file << ["Listing Name", "Price", "Details"].

airbnb_scraper.rb
…
# Write data to CSV file
CSV.open("airbnb_listings.csv", "w") do |file|
  file << ["Listing Name", "Price", "Details"]

  name.length.times do |i|
    file << [name[i], price[i], details[i]]
  end
end
This is adding a single row of data to our CSV file. This first row will have three cells, “Listing Name”, “Price”, and “Details”, and these will serve as our column titles.

Let’s save and run our script again.

Command Line
$ ruby airbnb_scraper.rb
Since we’ve overwritten this CSV file, let’s close it and open it again. There we go. Our column titles have been added. Looks great.

So as a quick recap, in this video, we stored all of our listing information into array variables and used a loop to write the data contained in those variables into a CSV file. But notice that the third column of our data contains all the details of room type, the number of reviews, and the location. This is because when we were scraping that information, all this info was contained in the same HTML tag.

But what if we want to take these details and display them in separate columns so they’re easier to analyze? That’s where parsing comes in. In the next video, we’ll learn how to convert our details column into three separate columns by using parsing techniques.

parse data
In the last video, we outputted the data we collected from Airbnb into the three columns of this CSV file. This time, we’ll use a technique called parsing to clean up the formatting of the data.

For example, if we look in the first and third columns, we’ll see that the listing names and details all have these extra spaces in front. To fix this, we’ll go to our script and after line.text, we’ll add a .strip. We’ll do it once here for name and again for details.

airbnb_scraper.rb
…
# Display output onto the screen
name = [ ]
page.css('div.h5.listing-name').each do |line|
  name << line.text.strip
end
…
details = [ ]
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text.strip
end
…
The purpose of the strip method is to get rid of any leading spaces – it’s a pretty basic example of the types of problems that parsing is designed to solve.

We can test out this code in our command line without outputting it to a CSV file by commenting out this code block. Now let’s write puts name here and puts details here to print the results to our screen instead of to the CSV file.

airbnb_scraper.rb
…
# Store data in arrays
name = [ ]
page.css('div.h5.listing-name').each do |line|
  name << line.text.strip
end

puts name

price = [ ]
page.css('span.h3.price-amount').each do |line|
  price << line.text
end

details = [ ]
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text.strip
end

puts details

# # Write data to CSV file
# CSV.open("airbnb_listings.csv", "w") do |file|
#   file << ["Listing Name", "Price", "Details"]
# 
#   name.length.times do |i|
#     file << [name[i], price[i], details[i]]
#   end
# end
Keep in mind that scraping and parsing the data are different from printing the data into a CSV file. This code here is what actually scrapes the Airbnb site, and this code block here is printing our results into a CSV file.

Let’s save and run the script now.

Command Line
$ ruby airbnb_scraper.rb
Good – we’ll look and see that none of the data has any spaces in front anymore.

Ok, let’s go back to our spreadsheet. We’ll now work on fixing the remaining issue in the third column, where we have the room type, the number of reviews, and the location all combined together. Let’s see if we can split the information into three separate columns so it’s easier to analyze.

This a little more complicated, so we’ll need to go to our Airbnb search page for Brooklyn. We’ll hover over this second line of listing details and right-click to ‘Inspect Element’. We can see here that these three pieces of information are split by this space, bullet point, space. Let’s copy this and use it in our code.

In our code file, after this line.text.strip, we’ll add .split(/ · /).

airbnb_scraper.rb
…
details = []
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text.strip.split(/ · /)
end
…
This split method uses the space-bullet point-space pattern to divide the listing’s details into the three separate components that we need. This changes our original array of 18 listing details into an array of 18 sub-arrays, with each sub-array containing the listing type, number of reviews, and location.

Let’s check to make sure our code worked. We’ll delete the puts name from before and leave the puts details to print just these results to our screen.

airbnb_scraper.rb
…
# Store data in arrays
name = [ ]
page.css('div.h5.listing-name').each do |line|
  name << line.text.strip
end

price = [ ]
page.css('span.h3.price-amount').each do |line|
  price << line.text
end

details = [ ]
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text.strip.split(/ · /)
end

puts details
…
Let’s save and run the script again.

Command Line
$ ruby airbnb_scraper.rb
Good – each listing’s details are now separated into their own lines.

Now that we’ve verified that it works, let’s output the new information into our CSV file again. We’ll delete this puts details and uncomment our CSV code.

Here, the name, price, and details reflect the three columns in our database, so we’ll need to add a couple more columns for the new categories we’ve created.

Instead of details[i], let’s change it to details[i][0] and add a comma, details[i][1] and comma details[i][2].

airbnb_scraper.rb
…
details = [ ]
page.css('div.text-muted.listing-location.text-truncate').each do |line|
  details << line.text.strip.split(/ · /)
end

# Write data to CSV file
CSV.open("airbnb_listings.csv", "w") do |file|
  file << ["Listing Name", "Price", "Details"]

  name.length.times do |i|
    file << [name[i], price[i], details[i][0], details[i][1], details[i][2]]
  end
end
We’re using the brackets twice here because the details variable is an array of sub-arrays. In other words, details[i] will give us the array of three elements and details[i][0] will give us the first of those three elements.

We’ll also need to rename our column titles so let’s delete our “Details” title and add more specific ones:

airbnb_scraper.rb
…
# Write data to CSV file
CSV.open("airbnb_listings.csv", "w") do |file|
  file << ["Listing Name", "Price", "Room Type", "Reviews", "Location"]

  name.length.times do |i|
    file << [name[i], price[i], details[i][0], details[i][1], details[i][2]]
  end
end
Let’s save and run our script again.

Command Line
$ ruby airbnb_scraper.rb
Now, let’s open up our airbnb_listings.csv file. Awesome, we now have 5 columns for each of our Airbnb listings, which makes the data much easier to manipulate and analyze.

So in this video, we learned some basic parsing techniques, like using strip to remove leading spaces and using split to divide our details into three separate pieces. There’s a lot more you can do with parsing, but hopefully this gives you a taste of how it works.

We’re now done with scraping Airbnb’s first page of search results in Brooklyn, but it makes much more sense to scrape not just one page, but all the pages of results. In the next video, we’ll learn how to scrape multiple pages and continue to add to the data in our growing CSV file.

5.scale up
scrape multiple pages
Up to this point, we’ve scraped the important information from the 18 listings on Airbnb’s first page of search results in Brooklyn. Let’s take this a step further and scrape all the Brooklyn listings so we can analyze the data thoroughly.

Let’s go to the Airbnb site, scroll to the bottom, and click on page 2 to see how the URL changes. It seems like it’s just added this ?page=2 to the end. If we go to page 3, now it becomes ?page=3. If we click on 56, it becomes ?page=56. Clearly, this is the URL pattern that Airbnb uses.

It’s pretty easy to see the pattern here, but it’s important to understand the special cases as well. For example, our first page of search results omitted this ?page= pattern in the URL. But will it still work if we add it in? Let’s test it out – we’ll scroll to the bottom and click on the link for the first page.

Without any page number in the URL, “Historic House in Williamsburg” is the first listing I see. If I add a ?page=1 and hit Enter, “Historic House in Williamsburg” still shows up as the first result. It looks like it’s still the same. Good to know.

Now what happens if we exceed the 56th page? Let’s first scroll to the bottom and go to the last page. The first listing I see is “Huge Apartment in Caroll Gardens”. Let’s change 56 to 100. Looks like Airbnb will always show the same page of results once the page number gets too high.

What this tells us is that we need to scrape the total number of pages listed here at the bottom to tell our script how many pages to scrape. Alternatively, we could hard-code this 56 number into our code, but since we have no guarantee that it’ll always be 56, I’d like to avoid doing that. For example, if we were to search a smaller location than Brooklyn or some Brooklyn hosts decided to take down their listings, there would be fewer pages. And if there were only say 50 pages, then our script would scrape as usual, not knowing that the last 6 pages would all look the same. We would get a bunch of repeat listings in our spreadsheet and we wouldn’t even know it.

So let’s see how we can scrape this 56 number. We’ll right-click on it, select ‘Inspect Element’, and see that it says <a target="56">. Let’s now look at the full source code by right-clicking and selecting ‘View Page Source’. We’ll type Command-F or Control-F and search a target=. A few irrelevant matches show up first, but then we come to the section we’re looking for.

This <div class="pagination"> section looks to be the part of the HTML that contains the page numbers that we’re looking for. And this part is a little tough to read, but all the page numbers seem to share a similar structure. They all have an <a> tag with a target attribute.

So since there’s no clean way to get the 56 on its own, we’ll need to scrape all the page numbers (e.g. 1, 54, 55, 56) and just take the biggest one of the bunch. Not all the page numbers from 1 – 56 are listed here because that would take up too much space on the bottom of this page. But the last page will always be listed, and that’s the number we need.

Since the a target= selector was too broad, grabbing some irrelevant HTML above, we’ll need to be more specific. We’ll instead find the <div> tag with class pagination, then find the <ul> tag nested inside it, then find the <li> tag nested inside that, and finally find the <a> tag nested inside that. That should definitely be specific enough to scrape this section only.

Going back to our script, we’ll write similar code to what we did before. Let’s write the following:

airbnb_scraper.rb
…
# Parse the page with Nokogiri
page = Nokogiri::HTML(open(url))

page_numbers = []
page.css("div.pagination ul li a[target]").each do |line|
 page_numbers << line.text
end
…
Most of this should be familiar, but let me explain this selector we’re using. Each space here just means “nested inside”. So in English, this is saying to find the <div> tag with class pagination. Then find the <ul> tag nested inside the <div>. And then an <li> tag nested inside the <ul> tag and an <a> tag with a target attribute nested inside the <li> tag. Remember that we use .s for classes, #s for ids, and []s for everything else. All together, this code scrapes all the page numbers and stores them in the page_numbers array.

Let’s test to see if this works by adding a puts page_numbers and we’ll comment out our CSV code and save.

airbnb_scraper.rb
…
page_numbers = []
page.css("div.pagination ul li a[target]").each do |line|
 page_numbers << line.text
end

puts page_numbers
…
# # Write data to CSV file
# CSV.open("airbnb_listings.csv", "w") do |file|
#   file << ["Listing Name", "Price", "Room Type", "Reviews", "Location"]
# 
#   name.length.times do |i|
#     file << [name[i], price[i], details[i][0], details[i][1], details[i][2]]
#   end
# end
Command Line
$ ruby airbnb_scraper.rb
When we run this, we’ll see that it’s scraped the numbers 1, 2, 3, and 56. We can check this by going to our original URL (that’s the page our script is scraping), scrolling to the bottom, and seeing that we have 1, 2, 3, and 56.

With this working, we’ll go back to our script. We now need to figure out how to take the largest of our page numbers. Let’s create another variable called max_page and write the following:

airbnb_scraper.rb
…
page_numbers = []
page.css("div.pagination ul li a[target]").each do |line|
 page_numbers << line.text
end

max_page = page_numbers.max

puts page_numbers
Here we’re using .max to grab the biggest number in our page_numbers array. We’ll test to see if it works by deleting puts page_numbers and adding puts max_page.

airbnb_scraper.rb
…
max_page = page_numbers.max

puts max_page
Let’s save and try again.

Command Line
$ ruby airbnb_scraper.rb
Perfect – we got 56.

We’ll write a note so we remember what this code does.

airbnb_scraper.rb
…
# Scrape the max number of pages and store in max_page variable
page_numbers = []
page.css("div.pagination ul li a[target]").each do |line|
 page_numbers << line.text
end

max_page = page_numbers.max
…
So what do we do now? Well remember that the reason why we wanted this number 56 was so that we could know how many pages of search results to scrape. Now that we have the max number, we can just edit the URLs and scrape ?page=1, ?page=2, all the way up to ?page=56. And since this process is pretty repetitive, we can design it all in a loop.

Let’s delete the puts max_page and write max_page.times do |i|, tab in all the code before our CSV section (a shortcut to do this in Sublime Text is with ‘Command-]’ or ‘Control-]’) and close the loop with an end.

airbnb_scraper.rb
…
max_page = page_numbers.max

max_page.times do |i|

  # Store data in arrays
  name = [ ]
  page.css('div.h5.listing-name').each do |line|
    name << line.text.strip
  end

  price = [ ]
  page.css('span.h3.price-amount').each do |line|
    price << line.text
  end

  details = [ ]
  page.css('div.text-muted.listing-location.text-truncate').each do |line|
    details << line.text.strip.split(/ · /)
  end

end
…
This code will take max_page, which in this case is 56, and run the loop that many times. But to do this, there are a few changes we need to make.

First, we need to add a .to_i to the end of our max_page line.

airbnb_scraper.rb
…
max_page = page_numbers.max.to_i
…
This is a subtle point, but our computer interprets this max_page variable as a string, or text, but the .times method that creates the loop requires an integer. The .to_i tells our computer to interpret this as an integer instead.

The second change we need to make is to redefine the URL we use. Since we’re scraping more than just the first page, we need a dynamic URL that will change each time we go through the loop. Let’s write:

airbnb_scraper.rb
…
max_page.times do |i|

  url = "https://www.airbnb.com/s/Brooklyn--NY--United-States?page=#{i+1}"
  page = Nokogiri::HTML(open(url))

  # Store data in arrays
  name = [ ]
  page.css('div.h5.listing-name').each do |line|
    name << line.text.strip
  end
  …
This hashtag in the middle tells our script that the URL isn’t ?page=#{i+1}, but that i+1 needs to be calculated and added to the end of the URL. Remember that i is the number of times we’ve gone through the loop. But since computers start counting 0, 1, 2, whereas our URLs will start with page equals 1, 2, 3, we need to use i+1.

We’re almost ready to run our script. The final change we need to make is to bring our empty name, price, and details arrays outside of our loop. If we left them inside, then the first time through the loop, the array would start empty and be filled with our first page of listing results. The second time through the loop, this line of code would delete all the listings we just added, starting empty once again. So to allow all the data to accumulate, we need to move these lines of code outside the loop.

Let’s write some comments to remind ourselves of the code.

airbnb_scraper.rb
…
# Initialize empty arrays
name = []
price = []
details = []

# Loop once for every page of search results
max_page.times do |i|

  # Open search results page
  url = "https://www.airbnb.com/s/Brooklyn--NY--United-States?page=#{i+1}"
  page = Nokogiri::HTML(open(url))

  # Store data in arrays
  page.css('div.h5.listing-name').each do |line|
    name << line.text.strip
  end

  page.css('span.h3.price-amount').each do |line|
    price << line.text
  end

  page.css('div.text-muted.listing-location.text-truncate').each do |line|
    details << line.text.strip.split(/ · /)
  end

end
…
Let’s uncomment out this section and we’re finally ready to run this.

airbnb_scraper.rb
…
# Write data to CSV file
CSV.open("airbnb_listings.csv", "w") do |file|
  file << ["Listing Name", "Price", "Room Type", "Reviews", "Location"]

  name.length.times do |i|
    file << [name[i], price[i], details[i][0], details[i][1], details[i][2]]
  end
end

Let’s save and go to our command line.

Command Line
$ ruby airbnb_scraper.rb
This time when we run this, it’s going to take a while because there are 56 pages to scrape, so let’s wait a bit…

Okay, looks like it finished. Let’s open up our airbnb_listings.csv file. If we scroll down, we’ll see that we have 1,008 listings (we’re not counting the column titles). If there are 18 listings to a page and 56 pages total, then that’s exactly 1,008 listings. We’ve finally scraped and collected data for every Brooklyn Airbnb listing.

Great job! We were able to modify our script to scrape all the pages of Airbnb search results. We had to first scrape the number of pages, then use that in a loop to get everything. Now it might seem like we’re done, but there’s actually one remaining thing we have to do. We need to quality check the data to make sure that it’s exactly the way we expect it to be. That’s what we’ll focus on next time.

check data quality
Last time, we managed to collect the data on all 1,008 Brooklyn listings on Airbnb. They’re all in our CSV file, but let’s take some time to make sure they’re correct. Our logic was clear and we did a pretty good job of testing things as we went along, but from personal experience, I’ve found that 80-90% of the time, there’s always at least one thing that we missed.

Just from looking at this list, it seems that everything is fine for the most part. But for larger data sets, a better way to check is to add a filter. This might be slightly different depending on whether you’re using Google Drive or Excel for Windows, but for the Mac version of Excel, I’ll highlight all the data, go to ‘Data’, and click ‘Filter’.

Now if we click the arrow next to the column, we’ll be able to see a list of every value that appears in this column. So for a column like ‘Room Type’ with only a few options, it becomes really easy to see if anything seems out of place. Let’s go through each of these columns one-by-one.

Listing names are pretty unique, but expanding this and quickly scrolling through this list, it looks fine. Let’s check prices. They all show up as numbers, like we expect. We’ve seen ‘Room Type’ already, so we’ll go to ‘Reviews’. We’ll expand this and scroll to the bottom. That’s odd…these last four look like they belong in the ‘Location’ column. Let’s scroll back up to the top and click ‘Select All’. Now we can go back to the bottom and check the four that look out of place.

It’s really these 7 listings that are messed up. For some reason, they’re missing the reviews section, so the ‘Location’ info is getting pulled in instead. I suspect that these 7 listings have no reviews, so rather than display ‘0 reviews’, Airbnb chooses to omit that section completely.

Let’s see if we can find one of these listings in our browser. That way we’ll know how to revise our script to fix the problem. For example, let’s find this listing in Bushwick, “Sunny private entrance room!”. Airbnb doesn’t allow us to search by the listing name, so we’ll have to use the other information to find it. I’ll search ‘Bushwick’, limit the search to private rooms only. Then I’ll narrow the price range to display just listings that cost $45/night.

If we scroll down, we’ll see “Sunny private entrance room!” We can see that the details really do display just two sections, the ‘Room Type’ and the ‘Location’. So when our script splits this based on the ‘space bullet-point space’ pattern, rather than get three pieces, it’ll only get two. How do we modify our script to account for this?

One way to do this is to first check to see if the line.text.strip.split sub-array has two or three pieces. If it has three pieces, we’ll add it to the details array as usual, but if it only has two pieces, then we’ll need to do something different.

Let’s first store this line.text.strip.split(/ · /) sub-array in its own variable. We’ll write:

airbnb_scraper.rb
  …
  page.css('div.text-muted.listing-location.text-truncate').each do |line|
    subarray = line.text.strip.split(/ · /)
    details << line.text.strip.split(/ · /)
  end

end
…
Now to check the number of pieces, we’ll use something called an ‘if statement’. We’ll write:

airbnb_scraper.rb
  …
  page.css('div.text-muted.listing-location.text-truncate').each do |line|
    subarray = line.text.strip.split(/ · /)

    if subarray.length == 3
      details << subarray
    else
      # to do
    end
  end

end
…
This code says that if our subarray has 3 pieces, then we should add it to the details array as usual. The else says that if instead subarray doesn’t have 3 pieces, then we’ll need to tell our script to do something else. The end finishes our if statement.

Notice that we’re using the double equals sign here. The rule of thumb is to use a single equals sign when you want to assign a value to a variable, but to use two equals signs when we’re comparing two things. Here, we’re comparing the length, or the number of pieces in our subarray, with the number 3, so we need two equals signs.

Now let’s fill in the code for what to do when there are only two pieces:

airbnb_scraper.rb
  …
  page.css('div.text-muted.listing-location.text-truncate').each do |line|
    subarray = line.text.strip.split(/ · /)

    if subarray.length == 3
      details << subarray
    else
      details << [subarray[0], "0 reviews", subarray[1]]
    end
  end

end
…
This is what we’re adding to the details array. subarray[0] and subarray[1] are the two pieces we’re grabbing from the listing, the room type and the location. Since the number of reviews isn’t shown on the page, we need to add it here ourselves. So together, this mimics the format that the other listings have.

Okay, let’s save and try this out. We’ll run our script and wait for it to finish.

Command Line
$ ruby airbnb_scraper.rb
When it’s done, we’ll reopen our CSV file. Now let’s add in our filters from before and check our ‘Reviews’ column. First, we’ll notice that ‘0 reviews’ falls at the very top, and if we scroll to the bottom, we’ll see that there aren’t any more rogue locations in the list anymore.

We’ve now finished collecting our complete Airbnb data set for Brooklyn. In our next and final video, we’ll take a look at our data set and draw some insights and analysis from the information we’ve collected.

6.conclusion
analyze data
Congrats on making it this far! Now that we have our final database, we can analyze the data and draw some insights on the rental market in Brooklyn, NY. This could be really useful if, for example, we were trying to price our own Airbnb listing of a private room in the Brooklyn neighborhood of Greenpoint. Let’s open our CSV file with all the listings.

Now, we can add a filter. Here we’ll filter by room type, “private room”, and location, which is “Greenpoint”. After highlighting all the prices, we can go to the bottom and select ‘average’. The average price per night is ~$78.

We could make our analysis as detailed as we like. For example, we could average only those listings that have a certain number of reviews. We could even do things like figure out the relationship between price and number of reviews, the most expensive neighborhood in Brooklyn, and the neighborhood with the most listings. The possibilities are endless.

If we wanted to get more detailed, we could also extend our project further. For example, a good exercise is to try scraping data from multiple locations. Or you could add more columns of information by not just scraping the search results pages, but by going to each listing’s specific page and pulling out extra details like the maximum number of guests, or the number of bedrooms and bathrooms.

Writing our script and getting to this point certainly wasn’t easy, especially if you haven’t had much experience with code. Keep in mind that I don’t recommend memorizing any of the code we’ve written. The most important thing is to look over the script and understand the logic behind the code. Understand why we’re doing what we’re doing because this same logic can be used to scrape other sites as well.

Through writing this script, I hope you’ve learned not only the basics of web scraping, but also a little bit about the Ruby programming language and the power of using technology to gather and analyze data. I highly recommend you try out these techniques on a site of your choosing! Thanks a lot for taking this course.


Hari ini mudah mudahan kita bisa lebih menghargai orang lain
nda tau kenapa banyak sekali ini tugas bergentayangan
mudah mudahan semangat

besok pagi ada acara orang kawin di belakang rumah
juga ke kampus
juga setting mikrotik
juga setting database tentunya
mudah mudahan ada secercah harapan d kampus baru ini
buat sistem administrasi berbasis IT
mau di apa cape mi badan
semangat semangat

hari in bersiap untuk ke computer city
mudah mudahan juga di kampus tidak ada masalah yang berarti
juga mau ke mandai setting setting yang rusak disana


besok suda siap setting instalasi alat sudah terbeli semua
besok lanjut lagi ngoding cape meka malam ini
mikrotik baru sudah saya download semua filenya
turs besok memprogram web lagi

mau install figaro di mesin fatekuvri.ac.id

akhirnya ada titik terang masalah router usermanager
bagaimanapun juga banyak masalah yang mesti diselesaikan dari dulu
besok mudah mudahan mikrotik sudah bisa rampung ke warnet
bakalan seru ini hari hari d kampus

ada peserta rupanya abuabu
singkat cerita jumat ini
mungkin besok pi baru bagus warnet
karena speedy memang nda konek

akhirnya hari ini lanjut lagi d warnet
081245731123 p herman

pasang glyphicon user
icon aneh aneh
nda tau ternyata cuman bisa sape 200 simbol di bootstrap
siapa tau bisa di cari cuman besok saya masih urus dulu ini speedy

tapi saya mengajar ini pagi hari di uvri jadi mesti pintar bagi bagi waktu

mudah mudahan sudah ada rektor baru besok senin
bisa kacau balau kalu tidak ada rektor yang segera dilantik

ada tong juga masalah di warnet mandai ini harus segera kelar sebelum bulan puasa
mudah mudahan ada jurus baru bisa didapat:
1. upload file pdf di dropbox
2. kasi tampil lewat pdfjs_rails
3. bisa di download lewat tombol download
4. daftar nilai mahasiswa

tadi pagi saya tidak mengajar lagi
car dulu materi buat besok mengajar
sudah meka belajar javascript hari ini
ini mata sudah mengantuk
terlalu capek mi belajar kasian
semoga pint rumah sudah dikunci semua diluar
tulis tulis dulu ini digithub supaya bagus ki keliatn akun

pagi ini sudah melakukan aktifitas sehari hari
itu kucing juga dimandikan supaya cepat kering
dikasi pake kipas tornado

nda ada bakat maen game onet
jadi lanjut ini perbaiki runiah school
donwload juga samsung galaxy s2

stres ini lagi kacau drumah
nda tau banyak sekali ini proyek yang belum bisa dicairkan duitnya
in runiah - school minta dijalankan kembali

ngoding lagi kite hari ini
sebentar dibuatkan laporan pengeluaranyang telah kita lakuan selama menjaga website runiah school agar tetap berjalan
sebentar juga kita coba liat liat pelajaran kita di kampus

banyak yang dibuat hari ini di website runiah
pr buat runiah:
16 april 2015
buat gmail
buat dropbox
upload image
perbaiki all pages
perbaiki contact us


hari ini telah bekerja selama 10 jam buat runiah desain
kalu bisa banyak lagi yang mesti dikerjakan ya begitulah
mudah mudahan didapat selanya kalu datang tiap hari ke kampus
inimi yang jadi motivasi sekaligus semangat untuk bekerja ekstra kuat dilembaga

mauka juga ke rumahnya nenek sekarang kasi kabar dan tanda tangannya
besok agenda:
ke telkom
ke al azhar


dapat ilmu baru membuat helper



banyak errro nya aplikasi ku hari ini
coba dicari mulai dari uvri

sekarang mesin fatekuvri sudah bagus tinggal runiah lagi
mudah mudahan cepat banyak jadi website ku

besok coba coba konsentrasi buat jalani itu kursus websiteku
mumpung hari libur tapi mauka juga sebenarnya ke tonasa
jadi besok mandikan dulu mobil dan gori


btw aniwey hampir kelolosan nda push satu hari
besok banyak dikerja mudah mudahan berhasil semua apa yang dicita citakan amin
spy nda terlalu galau lagi tahun 2016 amin
lumayan hari ini sakit kepala mikirin craiglist
mudah mudahan sudah kelar 3 hari kemudian ini materi supaya aman nda bayar bayar lagi
scraping json cukup menantang juga
tapi besok jadi dosen dolo nda boleh neko neko
siapkan materi menggambar mesin buat anak anak besok
jangan sampai keteteran nda ada yang bisa dibawakan ke mahasiswa
ini postingan yang ke 101 coba lagi biar ada semangat
mudah mudahan anak anak pada ngerti kenapa kita mesti membayar biaya praktikum



awali hari ini dengan bismillah dan alhamdulillah
cari erornya dulu ini runiah-school

tugas cari bug belum selesai di runiah
semoga cepat tuntas dan segera di push ke website runiah
sebentar perbaiki ban
baru ke tonasa sampe malam
pulang itu nda taumi bisa koding atau tidak
addduh masih banyak utang ku di sini kasian

hari ini sudah ke tonasa
sudah juga kasi laporan keuangan mesjid
buat formulir marketing
tinggal RAB kamera 2 titik
tinggal laporan keuangan mesjid
sudah itu buat lagi hitung uang yang ada di kantong plastik
besok harus bisa bangun cepat
setelah besok kita relax libur
cari cari itu ip camera djual dimana
lagi presentasi sekarang tentang upri sama ka max
besok bisa ajar sampai jam 11

banyak mentong salah salahnya ini websitenya runiah
nda tau yang mana ini mi error nya terakhir

hari ini sy berhasil dapat error nya ini aplikasinya runiah
jadi bisa move on sekarang eee
sebentar juga bisa les lagi
erorki ini git push heroku nya runiah

sudah fix mi erronya runiah
ternyata mau dirubah .gitinit config nya
warnet jg sudah fix tadi malam
tinggal settingan manajemen bandwithnya

skrg fokus di desain webnya runiah masih hancur di production
juga mau kursus lagi
baik itu yang berbayar 
ataupun yang tidak
mana saya juga harus menyusun tugas perkuliahan juga
mekatronika dan menggambar mesin
alat alat peraga juga harus dipikirkan buat kedua mata kuliah tersebut
perlu diatur strategi asistensi mahasiswa juga
pokoknya hari ini kerja saja apa yang bisa dikerja

cari kerja di odesk
nonton balap mobil di youtube
mulai dari tamiya sampai mobil yang monster truck
setidaknya juga tidak lupa nonton demoetsy
jadi programer mau tidak mau mesti tahan banting
kepala terus saja berpikir, mata melotot laptop dan jari mengetik terus
siap tempur terus dengan teknologi
keras perjuangan tapi semoga hasilnya bagus
sebentar minimal chapter 4 demoetsy bisa didapat
sebentar istirahat jam 11 malam lagi

kemarin banyak sekali tutorial baserails yang dibaca
dimulai hari ini dengan menyetel domain runiah
kemudian membuat check_box_tag dan min max di craiglist
kemudian membuat tampilan nya lebih profesional di index
setelah itu dilanjutkan materi ke bab 7

tinggal 5 film baru saya ke telkom memang mantap ini craiglist
ke telkom dulu mengadu kenapa nda ada pi konfirmasi sampai sekarang mengenai mandai
sudah dari telkom ternyata full jaringanny
ini speedy mau di te dulu ini immang
AC:3C:0B:54:25:69
40:F0:2F:3C:75:59
B4:F0:AB:DD:CD:7F
F8:D0:BD:8E:DE:3E #riskaku
ini semua no mac address harus diblokir
tinggal buktikan apa memang selalu kita terganggu oleh torrent

hari ini sudah banyak yang di baca di baserails
sudah selesai di craiglist
skrg review lagi di restaurant
tadi juga sudah ke kelurahan minta stempel
skrng tinggal sebar itu amplop proposalnya mesjid
tapi mata ini sudah lelah sekali kasian
mudah mudahan ini bisa diulang semua besok kalu saya siap
mudah mudahan besok juga bisa mengajar anak anak mahasiswa dengan baik
juga hafal hafal bacaan alquran lagi
error git push sudah bisa teratasi karena di hapus master.lock

sudah selesai mengajar autocad hari ini
sudah juga pergi cari klinik kulit
skarang lagi kerja mailboxer gem
untuk melayani email yang masuk ke website runiah school
belum dapat efeknya sampai sekarang 
baru tahap konfigurasi devise
tambahkan name pada devise
sekarang melangkah ke install mailboxer
make mailbox controlller
make conversation controller

mulai coding folder_views and conversation.html
install gem chosen-rails
konfigurasi gem 
masih banyak error ini tapi mata sudah ngantuk
banyak tutorial tentang webrtc juga tadi di buka
tapi ini lagi lagi yang saya kasi masuk di runiah malah error aplikasi emailnya

sudah download aplikasi webrtc
sudah download aplikasi elearning
coba tes pelajaran yang akan dilakukan 
tapi sebentar ini ujian tes dulu aplikasi yang sudah sy beli
coba tetap pertahankan fokus
mana ini aplikasi messagesnya runiah error lagi
buat kan satu satu aplikasi kemarin step by step
sudah download juga presentasi webrtc
baru baru melamar kerja satu di odesk
mana sudah beli makan buat mini juga
sudah juga ambil alat alat di laboratorium

mesti buat strategi baru ini buat apply jobb di odesk
tapi malam ini mau belajar dulu buat ngajar besok
daripada anak anak tidak kuliah mending kita ngajar saja besok apa adanya
2 mei 2015 olahraga sore pake sepeda dalam rumah 30 menit
3 mei 2015 olahraga sore pake sepeda dalam rumah 30 menit
besok mengajar jam 10 pagi di upri
sudah itu jemput fira dari sekolahnya
sudah itu ujian ngoding buat baserails
sekarang belajar dulu di codecademy
besok ajukan permohonan untuk mundur dari penawaran al azhar
ini juga tetap lanjut penelitian laboratorium bahasa
Pr berat dirails
upload data dalam bentuk excel dan bisa lagi di download dalam bentuk excel
sudah selesai dulu belajar di codecademy malam ini 

Alhamdulillah hari ini selesai mengajar di kampus
bangun jemput adhi 
siap ujian online
dimulai dari task terakhir
buat scraping website dengan craiglist
sekarang baru melangkah ke pembuatan scrape nya di rails
cukup dulu

bikin scarping di rails mi
install bootstrap 3 dengan boostrap-sass
banyak mi dikerja ini hari untuk craiglist
sekarang ini adami di bagian edit show

mulai hari ini dengan kerja craiglist
sudah bagian part 5 tinggal finishing
buat anchor model
sudah fix anchor model

kamis buat commit satu kali dulu
habis mi kuota ku di base rails.com
ini web site juga mau searching yang gampang gampang dulu saja
buat absensi harian saja dulu
saatnya istirahat dulu ini
besok mengajar autocad lagi ini
sudah cek top eleven
besok jangan lupa fotokopi ktp
besok jangan lupa install laptopnya rudy
besok jangan lupa bawa mobil mobilan
besok jangan lupa catat pengeluaran
besok juga buat pembukuan dan laporan mesjid

hari ini sepertinya break dulu
besok masih banyak tugas di website
sepertinya mulai dari absensi manual ke online baru dijual ke alazahar atau runiah
ptertemuan dalam bentuk kolom checklist
buat grup menggambar mesin di facebook
sudah apply job recomended catarse

hari ini mulia ngoding lagi
hari ini juga saya mau pergi k pa idris dulu
sudah malam siap siap istirahat dulu
rencananya susun materi matakuliah