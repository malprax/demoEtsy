== README

This README would normally document whatever steps are necessary to get the
application up and running.

Things you may want to cover:

* Ruby version

* System dependencies

* Configuration

* Database creation

* Database initialization

* How to run the test suite

* Services (job queues, cache servers, search engines, etc.)

* Deployment instructions

* ...
malam ini sebenarnya istirahat sudah ngodingnya
badan sudah capek dan agak demam kayanya bakalan sakit lama ini
mana saya bawa komputernya teman lagi
besok insay ALLAH siap

tapi ini pelajaran base rails makin susah saja, nda tau mesti dari mana mesti saya ulang lagi ini bacaannya dulu

hari ini jumat 27 maret 2015 saya belum bisa ngerjain banyak

penawaran yang ada tinggalh penawaran, banyak hal yang baru tiap harinya saya dapat di pemrograman
mudah mudahan di UPRI lebih baik lagi dgn adanya divisi IT nya

divisi IT ini bertugas banyak membenahi semua sistem administrasi UPRI

dan mudah mudahan saja website belajara dari baserails sudah bisa diterapkan langsung ilmunya

target malam ini dilihat sedikit dulu trips dari base rails

rencananya mau tidur jam 12 saja dlu terlalu lelah hari ini


hari ini telah selesai rapat kerja semoga ke depan lebih baik lagi
dan semoga tidak ada lagi kerusuhan di subuh hari pada saat kita salat
adn semoga kursusku di etsy cepat kelar agar tidak lama lama ini uang habis

besok juga saya harus menyusun mata kuliah
besok juga kembali ngoding perbaiki desain depan website
besok juga menyusun praktikum
besok juga saya mau menyiapkan data data lengkap masalah kelurahan
besok juga saya mau print spanduk


hari ini mau melakukan semua agenda yang direncanakan sebelumnya

sekarang tinggal mengerjakan sisa pekerjaan yang ada gogogogog

cuman bisa istirahat malam ini guys
pekerjaaan masih banyak numpuk
mudah mudahan besok bisa diselesaikan
setelah itu baru bisa tenang tenang

start lagi aktifitas hari ini
mau menyusun materi kuliah malam ini

mudah mudahan anak anak mengerti apa yang saya lakukan
saya mesti cari referensi dulu untuk meyakinkan anak anak masalah resource nya

nda ada yang mahal kalu nda ada harga pembandingnya
 besok nda tau apa jadi ke tonasa
 mudah mudahan ada juga kejelasan mengenai ini proyek pengadaan di alazhar
 dan besok pun saya libur kalu dari segi perkuliahan
 mana mata sudah mengantuk ini isi jadwal kuliah
 rencananya mau tidur kalu sudah banyak commit ku
 ya minimal 7 commit lah biar ada aktifitasnya
 
 siapa tau saya bisa mengerjalan kursusku ini besok lebih bagus lagi
 
 hari ini nda bisa pulang cepat ada demo uvri menolak caretaker
 ternyata errorku di validates yaitu present semestinya presence
 
 malam ini cukup sekian dulu aktifitasnya
 besok saja baru nyantai kegiatannya
 
 besok ke unhas dan ke upri
 
 hari ini mau ke upri dan ke unhas
 ada error lagi ini saya dapat di schedule
 semoga bisa selesai ini urusan
 saya mau kerja juga bahan ajar ini
 
 ngantuk sudah malam ini
 
 malam ini vukup istirahatnya
 besok lanjut kursus 
 
 
 bikin website lagi sambil dengar ceramah
 
 besok jalan lg planning 
 semua mesti d planning lagi dari awal
 
 mudah mudahan besok saya ingat input data mahasiswa baru
 dan sekalian saya mau buat daftar nilai mata kuliah yang sudah keluar
 
 awali hari ini dengan basmalah
 
 schedule numpuk cari cari dulu inspirasi
 okey back to nature cari materi kuliah buat hari senin
 
 hari ini sukses buat jurnal album
 tinggal belajar buat website lagi dengan 3taps
 
 sebentar coba dicek lagi
 mungkin sampai jam dua belas sebentar
 
 hari ini mulai pukul 18.00 banyak agenda acara
 nda belajar meki sedeng
 
 mudah mudahan besok nda terlalu padat kegiatan sehingga mudah urusan web
 
 ini lagi readme banyak sekalimi di tulis cuman sekedar commit
 
 tapi besok banyak lagi acara ii
 mau di sahid penyumpahan
 tapi sudah ngantik ini kasihan
 
 mungkin sesuatu yang bisa dibuat hari ini adalah :
 menulis penelitian mobil
 mengajar materi mekatronika
 membuat fitur baru website
 membuat materi menggambar mesin
 
 
 
Please feel free to use a different markup language if you do not plan to run
<tt>rake doc:app</tt>.



Craigslist Scraper Course Page:
1.Explore 3taps API
Introduction:
Welcome! In this course, we’ll learn how to work with an API to collect data and use this as the foundation for building a web app from scratch. This is an essential skill if you want to gain access to data from the most popular websites. For example, you could look at the social data from Twitter, track job listings on LinkedIn, pull headlines from the New York Times, and even get real-time weather updates from Accuweather. For this course, we’ll be working with the popular classified ads site, Craigslist, and build a web app using their apartment listing data.

In this video, we’ll cover the basics of what we’ll be learning and go over the app we’ll be building. But first, let me mention that this course does require having some familiarity with Ruby on Rails (we are building a web app after all). I’m going to assume that this isn’t the first time you’ve built a web app, but if you’re new to working with code or if you find yourself in over your head, I recommend taking a step back and going through one of the beginner level BaseRails courses first.

Ok, so first, I want to provide some context to make sure you’ll be learning the right skills. If you want to gain access to data on the Internet, there are two different approaches. The first approach is to write a computer program that can find and grab useful pieces of information on a webpage. This is essentially the same process as if we were to visit a URL and manually copy/paste the data we wanted into a spreadsheet. The difference is that by using the speed and power of a computer, we can scan many, many pages very quickly. This approach is called “web scraping” or “screen scraping”. This won’t be something we cover in this course, but I recommend learning it at some point because it can be used on almost any website on the Internet.

The second approach to gain access to data is by using an API. This is the skill we’ll be learning here, and it’s useful only for sites that have an API available. Fortunately, more and more popular sites are creating their own APIs for developers to use. In other words, they wanted to make the data available to the public and created an official process for developers to make requests. For example, Amazon created an API to allow access to their trove of product information. In doing so, they’ve made it much easier to build apps around this data, which ultimately drives more traffic to their site. Now these APIs aren’t always free, as we can sometimes be charged a fee (especially for valuable or hard-to-find data). But in general, it’s best to use an API when one exists, and rely on screen scraping only as a backup plan.

In this course, we’re going to use an API to collect data from Craigslist. This is a really interesting case because despite the popularity of their site, Craigslist does not have their own API. Instead, we’ll be using the third-party 3taps API as an alternative. 3taps will serve as a good, real-life example to give us practice on how to read unfamiliar documentation and explore a new dataset.

Using 3taps, we’ll be focusing on Craigslist’s apartment listings that are available for rent in Brooklyn. We’re going to take the data we retrieve, store it in a database, and build a web app around it. By having control over the data ourselves, we’ll be able to build our own user interface and provide custom features that may not be available on Craigslist itself.

A good example of the kind of site you can build with this approach is www.padmapper.com. Padmapper has become a popular alternative to Craigslist for finding apartment rentals. It takes Craigslist apartment listings and overlays them onto a Google Map to create an improved apartment browsing experience. This just goes to show that once you have control over the data yourself, there’s really no limit to how you can present the information to your users.

Let’s now go over the app that we’ll have built by the end of this course. We’ll be creating an apartment rental site for Brooklyn, New York by collecting the most recent posts from Craigslist and building a nice UI around the data we’ve gathered.

First, we’ll collect the data through the 3taps API and store the information in a database. We’ll then display this data on a web app we’ll build in Rails. When users first get to our homepage, they’ll be able to filter their apartment search by different categories such as price, number of bedrooms and bathrooms, square footage, and so on.

Let’s try it out now. We’ll search for 2 bedroom apartments in the Brooklyn neighborhood of Williamsburg. We’ll get taken to a search results page with all the apartments that match the filters we’ve set. Here, we’ll be able to see a preview of what the apartment looks like, as well as some general information about each one. If we click on a post, we can see the images that were uploaded, the details that we’ve gathered, and the description.

Finally, after building the app, we’ll automate the data collection process to run every 10 minutes so that our content will be updated automatically.

Okay, in the next video, we’ll get started by exploring the 3taps API for the first time.


Using the Reference API:
In this video, we’ll get started with the 3taps API, which we’ll be using to collect the apartment listing data we need from Craigslist. I’m going to assume that you already have Rails installed, along with a text editor, command line, and everything else you need to build a web app. If you don’t have all of these installed, I recommend going to one of the beginner-level BaseRails courses and following along with the installation process there.

Ok, let’s start by opening our Google Chrome browser and going to www.3taps.com. After closing the popup that appears, let’s scroll down and click on ‘Register as a Developer’. Fill in the signup form and you’ll be sent an email with a link to activate your account. I already have an account so I’ll skip this step. Once you do that, you’ll be given an API key that you’ll need whenever you request data from 3taps.

Now that we’re all set up, let’s go take a look at the documentation. The 3taps API is actually three different APIs: Search, Polling, and Reference. Whenever we start working with an unfamiliar API, the number one most important thing we can do is read the documentation. Only by reading the documentation and making a bunch of different data requests can we really start to understand the data we have available and how to access it.

Let’s begin with the Reference API. “The 3taps Reference API provides information about the data sources, category groups, categories and locations available within the 3taps system.” So basically, we can use the Reference API to ask for information about the 3taps data set. We’ll need this to look up the specific names and acronyms that they use to classify data into different categories, subcategories, countries, regions, and cities.

I’ve already read this documentation pretty thoroughly and so I’ll cover the highlights with you, but it’s a good exercise to read it over yourself and see if you can make sense of it. Before, I was always tempted to cut corners and just skim it, but I learned that reading documentation well is such an underrated skill. The extra 30 minutes it takes to read the API’s documentation can save anywhere from a couple hours up to a few days of messing around with the API yourself. So be patient and always read the documentation – you should pause the video here and go do it.

No seriously, pause the video. I can wait.

Ok so hopefully you’ve at least skimmed to the bottom. Even if you didn’t understand everything, you’ll have seen that there are basically five different types of data requests we can make to the Reference API. We can ask for a list of Data Sources; we can ask for a list of Category Groups; we can also ask for Categories, Locations, and do Location Lookups.
But in this case, it’s hard to get a good grasp of this – after all, we don’t even know what Categories and Category Groups are! So let’s start playing around with this and make some requests to the Reference API.

Under the section called ‘Data Sources’, it says: “To obtain a list of data sources, make an HTTP GET request to the following URL: http://reference.3taps.com/sources”.

A GET request is just a visit to this URL asking for data. GET requests are really no different from the normal browsing we do on an everyday basis. For example, when we go to www.nytimes.com, we’re asking for data. The data that’s returned to us comes in the form of a webpage with headlines and images.

Let’s make a GET request to 3taps now by copying the URL and pasting it in a different tab. We can see it says “Your query does not include a registered authentication token (auth_token). Please sign up for an authentication token at https://developer.3taps.com/signup”.

So one way in which GET requests differ from normal browsing is that they can accept one or more parameters as inputs. In this case, 3taps won’t give us any data unless we include our authentication token. We can see this is also mentioned back in the documentation as a required parameter.

To add a parameter to our request, we’ll go back to the URL and add a ? followed by the name of the parameter, which is auth_token, followed by an =, and finally the value which we got from 3taps. We can find this after we sign in and go to “Dashboard”.

So we’ll copy this and paste it on top. After we hit ‘Enter’, we’ll now see a list of 3taps data sources on the page. While we’re using 3taps to access Craigslist, there are many more sites that 3taps could help us collect data from. A few of the largest ones are Cars.com, eBay, and the job search site, Indeed.

The list that we see is written in a format called JSON. JSON is a way of organizing data, mainly by using these name-value pairs. In this case, each of the data sources we see has both a code and a name. We’ll need the code later on when we request data from 3taps, so let’s go to ‘File→Save Page As…’ and save this page to our desktop as sources.json. This way, in the future, we can pull up this page as a reference without having to submit another request to 3taps.

Great, let’s jump to the next section of the documentation, for Category Groups. Here, we’ll need the same auth_token parameter, but we’ll be making our GET request to a different URL. Let’s copy this, go back to our other tab, and replace the portion of the URL before the question mark.

This time, we get a different list of the 3taps Category Groups. All the data they have is organized into one of these groups. The one we’re interested in is “RRRR”, “Real Estate”. Like last time, we’ll save this to our desktop.

Let’s do the same thing for the third section of the documentation, Categories. This one also requires only the auth_token parameter, so we’ll just copy this URL and paste it in like before.

The list we see this time is much longer. From the structure of each section, we can tell that Categories are really a subdivision of the Category Groups we saw previously. For example, the Category Group “Animals” is further divided into “Pets”, “Supplies”, and “Other”. If we scroll down to “Real Estate”, we’ll see that we have “Commercial Real Estate”, “Housing for Rent”, “Housing for Sale”, and so on. The one we’re interested in is “Housing for Rent”. Let’s save this to our desktop.

Let’s move on to the fourth section of the Reference API, Locations. Locations are a little different from what we’ve seen so far. In addition to the auth_token, we also need to provide a second parameter, level. This level can be ‘country’, ‘state’, ‘metro’, basically how specific you want it to be. We’ll first copy this URL and paste it in like before. Then at the end, we’ll add &level=country and hit Enter.

We now have a list of all the countries that 3taps collects data for. Each country has latitude and longitude ranges, a code, a full name, and a short name. Let’s find the United States – its code is “USA”.

Great. Now going back to the documentation, if we wanted to get a list of all the US states, we could go to our URL and replace the word country with state. Let’s try it out. If we hit Enter, we’ll see not only US States like Alabama and Alaska, but also Canadian States like Alberta and Australian States like Australian Capital Territory. We need to add a filter to limit our list to US States only.

In the documentation, in addition to the two required parameters, we also have the option to use these optional parameters below. In this case, we’ll leave the level we have now, but we’ll add the optional country parameter. It says “the parameter’s value must be a valid 3taps country code”, so we’ll go back to our URL and add an &country=USA, which was the country code we saw earlier in our list of countries. Now our list is correct – we have a list of all 50 states plus the District of Columbia.

Since we’re looking for apartment listing data in Brooklyn, NY, the state code is “USA-NY”. And to get Brooklyn, let’s go to the URL and replace level=state with level=city, and change country=USA to state=USA-NY and hit Enter. If we scroll down, the code for Brooklyn is “USA-NYM-BRL”. We’ll need this code later on, so let’s save this to our desktop as well.

Of course, there’s a lot more you can do with all the different combinations of countries, states, metros, and cities, so I encourage you to explore around and get a feel for this yourself. A good exercise is to see if you can find the city or metro of where you live.

We’ll skip over the fifth and final section of the Reference API because we won’t need it for our project. This last section is designed for reverse location lookups, when we have a 3taps location code and need to look up its level, latitude, longitude, and other details.

Now that we’ve taken a close look at the data available in 3taps, including the various sources, categories, and locations, we’re ready for the next section, where we’ll move on from the Reference API and turn our attention to the Polling API, which we’ll use to start collecting the apartment listing data we need.

Retrieve Posting Data:
Last time, we took a look at the 3taps Reference API to learn about the data they had available. We learned that 3taps collects data from many sites beyond just Craigslist, such as Cars.com, eBay, and Indeed. We also saw that 3taps uses Category Groups, Categories, and Locations to organize the data it retrieves. In this video, we’ll start using the Polling API to start gathering data for ourselves.

When we were first introduced to the 3taps documentation last time, we saw that there were three different APIs available: Search, Polling, and Reference. We’ve looked at the Reference API already, so let’s take a look at the two others, starting with the Search API.

“The 3taps Search API is responsible for searching against the database of postings. For example, it can be used to find all postings from a particular data source, category and location, or to find postings with a given annotation value.”

You can read over the rest of this if you like, but the Search API is optimized for searching quickly. It’s best for situations where you need to search for content with specific keywords. However, we’re not so interested in search. We just want to retrieve the most recent apartment listings regardless of what keywords they contain. For that, we’ll need to look to the Polling API.

‘The 3taps Polling API makes it possible for external systems to “poll” the Data Commons server to obtain a list of new and updated postings as they come in.’

This is exactly what we need. We want to check with 3taps periodically and gather all the new apartment listings that have come in since the last time. Like last time with the Reference API, I recommend that you take some time to read this over, as it’s more complicated than last time. When you’re ready, we’ll go over the highlights together.

Ok, first let’s understand the way that 3taps processes its incoming data. If each of these rectangles is a Craigslist post, with the older ones on the left, then 3taps is receiving a constant stream of new posts from the right. That means if we gather all the latest posts at one point in time, then when we check 10 minutes later, there will probably be new posts, these green rectangles, that have come in since then. So for us, these three posts are the new ones we should now retrieve.

But newness is relative – it depends on when we checked last. 3taps uses something called an anchor to give us only the new posts that we haven’t seen yet. We’ll see that this anchor is a required parameter in many of the requests we’ll make.

One final note: if there are too many new posts, 3taps will give them to us one page at a time. So in these situations, we’ll have to make more than one request to be able to get all of them.
With that context out of the way, let’s move onto the API itself. There are two different types of requests we can make. The first is the “Anchor” API call. An API call is just the same as the GET requests we were making in the last video. Since we haven’t made any data requests yet, we don’t have an initial anchor to use. That’s what this Anchor API is for. Once we’ve made our first data request, we’ll always get back an updated anchor to keep track of the last post we’ve received.

To use the Anchor API, we need two required parameters. The first is our auth_token, which we have from last time. The second is timestamp, which is used to give us an anchor value from that time. It says the timestamp needs to be “the desired date and time, as an integer number of seconds since the 1st of January 1970 (”unix time"), in UTC".

Let’s first understand Unix time. Unix time is a way to display date and time. Rather than use Month/Day/Year or Day/Month/Year, Unix time is just the number of seconds since January 1st, 1970. And UTC is used as a universal time zone. It’s an abbreviation for Coordinated Universal Time, but it’s in French, which is why the letters are out of order.

All in all, we need to provide the Unix time corresponding to the date and time we want, and we’ll be given an anchor value in return. I like to use one of the many tools online to help with converting regular time into Unix time. If we open a new tab and search ‘convert Unix time’, we can click on any of these links. On the convert-unix-time.com site, we can enter any date and time and it will convert it for us. Instead, we’ll just be copying over the timestamp shown for the current hour.

But first, let’s start building our API request by going back to the documentation and copying the Anchor URL they provide. We’ll open a new tab and paste that in. At the end, we’ll add a question mark followed by the name of our first parameter, auth_token, and then an =. We now need to put in our 3taps API key. If you didn’t write it down anywhere, you can always go back and click the ‘sign in’ link to see it. Let’s copy this and paste it to the end of our URL.

Now to add our second parameter, we’ll add an & and the name of the parameter, timestamp, followed by an =. We’ll copy the timestamp we saw earlier, and paste it in. After we hit Enter, we’ll see that we got an anchor we can use. We’ll need this anchor in a moment.

Let’s go back to the documentation. The second type of request we can make is the “Poll” API call – this is what we’ll use to collect our Craigslist posts. We’ll start off by putting in the required auth_token parameter along with the optional anchor we just received. Let’s first copy the URL and paste it into another tab. We’ll now add a ? followed by auth_token= and then copy over our API key. For our second parameter we’ll add an & followed by anchor= and we’ll grab our anchor from our previous request. Let’s hit Enter.
You should see a massive amount of text – this is all the data that 3taps has collected from its many sources in the past hour. The data is still in JSON format, but because it isn’t formatted nicely like before, it’s pretty tough to read. To solve this problem, we’ll download a Google Chrome extension called JSON Formatter.

In our Chrome browser, we’ll click this button on the right, go to “More tools”, and select “Extensions”. Scroll to the bottom and click on “Get more extensions”. In the search bar, type “JSON Formatter” and hit Enter. Under ‘Extensions’, click the button to download and select ‘Add’ to give it the right permissions.

Now if we go back to our data request and refresh the page, the JSON should be automatically displayed in a structured format and much easier to read. We can even click on the small gray arrows to collapse the sections we don’t need to see. Note that the data you see will probably be different from mine, as 3taps is receiving new data all the time. But the overall structure should be the same.

Each post contains a ton of information. For example, it has an ID, a source (in this case, cars.com), a category which we saw earlier in the Reference API, and the external URL which we can click on to see the actual listing itself.
We also get all this other data, like the post’s heading, timestamp, a bunch of annotations, and location information. This is the structure that 3taps uses for all the data it collects, whether they’re used car listings, job posts, or items for sale. But we’re only interested in seeing apartment rental listings from Craigslist, so we need to filter this to show only the posts we want. And that’s what we’ll be working on next time.

So to sum up, in this video we made our first actual data request. We learned how 3taps uses its system of anchor values to keep track of whether data is old or new, and we made an API call to get an initial anchor to use. We then used that anchor in a second request to get back data, which was formatted nicely for us from the JSON Formatter Chrome extension we installed. All of this practice with making API calls will be put to good use next time, as we add optional parameters to build out our request further.

Refine Our API Request:
In the last video, we received our first set of 3taps posting data. We got an initial anchor, which 3taps will use to remember which posts we have or haven’t seen yet.
As a refresher, here’s the API request we made last time. Note that your data may have changed, as it’s being updated constantly. If we collapse the postings section by clicking on the small gray arrow, we’ll see that there are 1,000 items, which is the maximum that 3taps will return to us. Most of these aren’t what we’re looking for though, so let’s add a few more parameters to our API request to refine the results we receive.

From the documentation, we can scroll down to the Poll API Call section and see that there are many optional parameters we can include. All but one of these are used for filtering the content that’s returned to us, which is what we’ll do now.

We’ll start by adding a filter for posts from Craigslist only. We’ll go back to our API call and add a source parameter. To check the code for Craigslist, let’s open the sources.json file on our desktop that we saved from the Reference API. The 3taps code for Craigslist is “CRAIG”, so let’s type that in and hit Enter.

Great – it seems like our results are now filtered to include Craigslist posts only. Let’s use the same approach and add a couple more filters. We’ll start by adding a category_group and category filter. Checking our category_groups.json reference file, we can see that ‘Real Estate’ has a code of ‘RRRR’. And opening our categories.json file, we’ll find ‘Housing for Rent’ listed under the code ‘RHFR’. Let’s add this to our API call: &category_group=RRRR&category=RHFR.

Okay, now we’re only looking at Craigslist apartment listings. If we take a look at this information, we should see that it matches exactly with that in the external URL. There’s even a lot of well-organized listing information contained in the annotations, like the number of bathrooms, whether cats are allowed, square footage, and so on.

Let’s add another parameter to filter by location as well. We can drill down and be as specific as we like here, setting the country, state, metro, even down to the zipcode. But for me, I’m going to add a city filter to limit my results to Brooklyn, NY. We already made a call to the Reference API previously, so I can open the locations.json file I have saved on my desktop and find that the 3taps code for Brooklyn is ‘USA-NYM-BRL’. Let’s add that to our URL, &location.city=USA-NYM-BRL, and hit Enter.

Now each one of the posting results will be in the city of Brooklyn. If we collapse the postings section, we’ll see that we have far fewer listings now. This makes sense, as our filters are now quite specific about what we’re looking for.

While there is a lot of data here, if we look carefully we’ll see that there are still some key pieces that aren’t being shown. For example, where is the body text of the post? Or the listing price?

We’ll be able to set which data fields we want to receive by using the final parameter called retvals, which is short for ‘return values’. The documentation says that retvals is:

“A string listing the fields which should be returned back to the caller. The various fields should be separated by commas. At present, the following fields can be included in this parameter.”

So the list below is the full range of posting fields that we can ask for. We can see the body and price fields we were looking for earlier. To use this, we’ll pick and choose the fields we want, and include them in our API request with commas in between. If we omit the retvals parameter, then 3taps will give us only these lower 8 fields by default. And if we need an explanation of what each field is, we can scroll down to see a description of each one at the bottom.

Let’s try this out. In our API request’s URL (which is getting pretty long now), we’ll type &retvals= and then we’ll pick a few fields to include. I’m going to omit fields like source, category, and category_group because those should be the same for all our posts. I’ll write location,external_url,heading,body,timestamp,price,images,annotations. Let’s hit Enter.

You can see that we got most of the same fields as before, but we now also have fields like body and price that we were missing earlier. The images field also gives us a list of URLs where we can find each of the images from this Craigslist post. Overall, the dataset that we see here is what we’ll want to build our web app around.

So in this video, we learned to use a variety of filters and other optional parameters to refine our API request. Now that we’ve had a chance to play around with the different options, our next step is to figure out how to make this same API call not through a URL, but through a script that we write ourselves in Ruby. That’s what we’ll be working on next time.


2.Import Data Into Our App
Convert Our Request to a Script:
In the last video, we refined our API request to include the specific source, categories, return values, and other data options we wanted. This time, we’ll make the same request, but through a Ruby script we’ll be writing, rather than through our browser. This is an important step because without a script, we won’t have a way to automate our request and integrate it into a web app later on.

Let’s start by opening a new file in Sublime Text. I’ll save this in my root directory (my “alexyang” folder) and call it craigslist_scraper.rb.

We’ll write our script in three chunks and I’ll explain as we go along. Here’s the first chunk:

craigslist_scraper.rb
require 'open-uri'

# Set API token and URL
auth_token = {AUTH_TOKEN}
polling_url = "http://polling.3taps.com/poll"
In this first section, we’re using the require statement at the top to give us access to the functionality of the ‘open-uri’ Ruby gem, which allows us to open URLs from within our script. Whereas in Rails, we would typically add gems to our Gemfile and install them by running bundle install, the process is slightly different when we’re working with a Ruby script. In this case, we just declare the gems we need at the top and install them manually, if necessary. The ‘open-uri’ gem comes installed by default, so we should be all set.

Below the require statement, we’re creating two variables, auth_token and polling_url. Pretty straightforward.

Okay, let’s write the second chunk of our script:

craigslist_scraper.rb
…
# Specify request parameters
params = {
  auth_token: auth_token,
  anchor: {ANCHOR}
}
If you don’t have the anchor we used from last time, just make another request to the anchor API to get a new one. In this section, we’re setting a couple of the basic parameters we want to use in our data request. It’s better not to spend time plugging in all of our parameters right away because we want to make sure that a basic request works first. In general, the more incrementally we can code, the easier it will be to find and fix errors that come up.

Here, our auth_token parameter is equal to the value of the auth_token variable we set above. And our anchor parameter is just hard-coded to what we used last time.

Let’s write the third chunk of our script:

craigslist_scraper.rb
…
# Prepare API request
uri = URI.parse(polling_url)
uri.query = URI.encode_www_form(params)

# Submit request
result = open(uri).read

# Display results to screen
puts result
This last chunk is a little more complicated, but let’s walk through it line-by-line. In these first couple lines, we’re preparing our URL request by starting with our base URL, which is the variable polling_url, and then adding on each of our parameters from the params variable above. To get into specifics, we need the parse method to take the string we have in our polling_url variable and convert it into a URI object, which we need in a data request. It sounds very technical but we’re basically telling our computer that this string here is actually a URL.

And the encode_www_form method takes the array of parameters we have above and converts it into the format with ampersands and equals signs. Together, these two lines are doing the equivalent of typing in the long URL in our browser.

We can think of this next line as essentially hitting Enter. It’s submitting our request (which is contained in the uri variable) and storing all the data that we get from 3taps in a variable named result.

Finally, we’re using the puts function, which stands for “put string”, to display all the information onto our screen.

It’s okay if you don’t understand all the individual details just yet. But it’s important to see the big picture, especially how each step here compares to the process of making this same request through our browser.

Let’s save and open up our command line to run this script. Since I saved the script in my root directory, ‘alexyang’, I can just run my script from here. If you saved your file somewhere else, you may need to cd (or change directory) into the folder where you saved it.

Let’s type ruby craigslist_scraper.rb and hit Enter.

Command Line
$ ruby craigslist_scraper.rb
It’s kind of hard to tell, but this is actually the same data we would get in our browser. It’s just very difficult to read because it isn’t formatted very well. The problem is that our script doesn’t realize that this data is all in JSON format. It thinks this is regular text and so it hasn’t applied any formatting whatsoever.

We can fix that by making a couple changes to our script. First, around our open(uri).read, we’ll wrap it with JSON.parse( and close our parentheses at the end. Then instead of puts result, we’ll type puts JSON.pretty_generate result.

craigslist_scraper.rb
…
# Submit request
result = JSON.parse(open(uri).read)

# Display results to screen
puts JSON.pretty_generate result
The JSON.parse is telling our script to interpret the 3taps data not as regular text, but as JSON. And the pretty_generate method formats that JSON to display nicely onto our screen.

Now to use these methods, we need to use the ‘json’ gem, which like ‘open-uri’ is also installed by default. So at the top, we’ll write require 'json'.

craigslist_scraper.rb
require 'open-uri'
require 'json'
…
Let’s save and run this again.

Command Line
$ ruby craigslist_scraper.rb
This time, the data should be much easier to read.

To finish off our script, the last thing we’ll do is add in all the other parameters we used from last time. In our params variable, let’s add a comma after the anchor parameter, and write a few more:

craigslist_scraper.rb
…
# Specify parameters
params = {
  auth_token: auth_token,
  anchor: {ANCHOR},
  source: "CRAIG",
  category_group: "RRRR",
  category: "RHFR",
  'location.city' => "USA-NYM-BRL",
  retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
}
…
This should all be pretty straightforward, except for the line starting with location.city. You’ll see that we couldn’t use the standard ‘name: value’ syntax here. Instead, we had to place the name in quotes and use a hashrocket instead (that’s what this => is called). In most cases, we’ll be fine using the ‘name: value’ syntax, but there are special cases like here when we have a period in the middle, where we need to fall back on the hashrocket syntax instead. They do exactly the same thing, but the ‘name: value’ syntax is just a shortcut that works 90% of the time.

Let’s save and run this script again.

Command Line
$ ruby craigslist_scraper.rb
Now we’ll see that all our results are from Craigslist, limited to posts related to housing for rent, and all the other filters that we set. We just took a really important step. The script that we wrote is going to serve as the foundation of database we’ll be using for our web app. In the next video, we’ll switch gears and begin building our web app. The plan is to get both pieces ready, so we’ll be able to integrate them together to finally have an app that can automatically pull in data from Craigslist.


Create a Rake Task:
Up to this point, we’ve managed to access Craigslist posts by making data requests to the 3taps API both through our browser and through the Ruby script we wrote. Now we’re going to switch gears and start building our web app.

For this portion of the course, I’ll assume that you’re already familiar with the fundamentals of building a Rails app, so I’m going to skip over basic Rails concepts like Gemfiles and launching the Rails server. That’ll allow us more time to focus on the more advanced topics that aren’t covered in the beginner-level BaseRails courses.

Let’s get started by creating a new Rails app from our command line. From my root directory, ‘alexyang’, I’ll type rails new craigslist_scraper and hit Enter.

Command Line
$ rails new craigslist_scraper
When this finishes, let’s type cd craigslist_scraper to change into our ‘craigslist_scraper’ directory, and then the subl . shortcut to open our app in Sublime Text. If you don’t have this shortcut set up, just open the file manually through the Sublime Text app.

Command Line
$ cd craigslist_scraper
$ subl .
With our code files open, let’s also go back to our command line, and open a second tab, navigate to our app’s folder, and launch our Rails server.

Command Line
$ rails s
You should be able to see that your app is running by opening the browser and going to localhost:3000.

Let’s begin by creating a structure for the main resource on our site, the Craigslist posts that we’re pulling from 3taps. For simplicity, we’ll use a scaffold and type rails generate scaffold Post, followed by each of the fields we want and their corresponding data types. Typically, we’d write heading:string body:text... but here’s a shortcut: we can leave off the :string and our app will still assume that the field is a string by default. So let’s delete this and write heading body:text price:decimal neighborhood external_url timestamp and hit Enter.

Command Line
$ rails generate scaffold Post heading body:text price:decimal neighborhood external_url timestamp
We’ll now run rake db:migrate to create our Post database and then restart our Rails server.

Command Line
$ rake db:migrate
Command Line
$ rails s
We can see our new index page by going to our browser and visiting localhost:3000/posts.

There’s no data here yet. Typically, we’d populate our database of Posts by manually entering them through our app’s New Post form, but let’s see if we can make a couple changes to the script we wrote last time and populate our database with real Craigslist data instead.

Before we do this, let me introduce the concept of a rake task. We can think of a rake task as a script that we can run from outside our app. For example, rake db:migrate and rake routes are two popular rake tasks that help us make database changes and view the available URLs for our app. We can see a list of all the rake tasks we can run by typing rake db -T -A.

Command Line
$ rake db -T -A
In the list that appears, the left column has the name of the rake task while the right side has a description, if it’s available.

In addition to these standard tasks, we can create our own custom rake task as well. And that’s exactly what we’re going to do – we’re going to convert the Ruby script we wrote into a custom rake task. Creating new rake tasks is much like generating a new controller. We’ll write rails generate task, and then come up with a name for our new group of tasks as well as each individual task itself. We’ll assign our tasks to a group called scraper, create two tasks, scrape and destroy_all_posts, and then hit Enter.

Command Line
$ rails generate task scraper scrape destroy_all_posts
A new file was created for us, so let’s go back to Sublime Text and go to lib/tasks to check it out.

This scraper.rake file can hold the code for multiple rake tasks, all grouped inside the namespace called scraper. Right now, it’s set up for two tasks: scrape, where we’ll be copying over our script from last time, and destroy_all_posts, which we’ll write in a later video to quickly reset our database of posts.

Let’s start by writing a description for our scrape task. We’ll write ‘Fetch Craigslist posts from 3taps’. Now we need to write the code for the task. Let’s open up our craigslist_scraper.rb file from last time which we’ll be using as a base, copy all the code, and paste it in between the do and the end.

lib/tasks/scraper.rake
namespace :scraper do
  desc "Fetch Craigslist posts from 3taps"
  task scrape: :environment do
    require 'open-uri'
    require 'json'

    # Set API token and URL
    auth_token = "36ba890f43a7cfa7e5a68e23c6ed435d"
    polling_url = "http://polling.3taps.com/poll"

    # Specify request parameters
    params = {
      auth_token: auth_token,
      anchor: 1503713374,
      source: "CRAIG",
      category_group: "RRRR",
      category: "RHFR",
      'location.city' => "USA-NYM-BRL",
      retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
    }

    # Prepare API request
    uri = URI.parse(polling_url)
    uri.query = URI.encode_www_form(params)

    # Submit request
    result = JSON.parse(open(uri).read)

    # Display results to screen
    puts JSON.pretty_generate result
  end
  …
Since the code is unchanged, we should be able to run it and see the same output from last time. So let’s save and go back to our command line. First, let’s type rake db -T -A to see our list of rake tasks again.

Command Line
$ rake db -T -A
If we look carefully, we’ll see the two new tasks we just added. To run our scrape task, we’ll just use rake scraper:scrape and hit Enter.

Command Line
$ rake scraper:scrape
Good, looks like it’s working. In the next video, instead of displaying the data to the screen, we’ll store it in our currently-empty database of Posts.


Save Posts to Database:
In the last video, we created our new Rails app and wrote a custom rake task to run our script. In this video, we’ll store the data we’ve scraped in our Posts database.

We’ll first need to create a row for each posting and pick out the heading, body, and other information here to fill in the row’s columns.

We first need to figure out the right syntax to use to grab a single field like the heading. It helps to view the 3taps data in our browser, so I’ve pulled up the API call from last time. Unlike in our command line, here we can see the full structure of the data. When this data is loaded up in Ruby, it’s stored in something called a hash. Remember that JSON is really just a kind of format to display data, but when Ruby sees JSON, it interprets it into a different format known as hash. So really, a hash is just the Ruby version of JSON data – you can think of them as essentially the same thing. You’ll be able to recognize hashes by their curly braces on the outside and their ‘name:value’ format on the inside.

This hash is really just three ‘name:value’ pairs. We have "success":true, "anchor":1503714374, and postings with all this information. That’s right – all the data we want is contained in the value corresponding to the postings name. We can see that by collapsing the postings section. See? Just like any other ‘name:value’ pair.

Instead of a single value like true or our anchor value, the third ‘name:value’ pair contains an array of 1,000 postings. We can tell it’s an array by the square brackets on the outside. (Remember, curly braces:hash :: square brackets:array.)

We’ll expand this back and instead collapse an individual posting to see that each posting is a hash as well. This means that postings is an array of hashes, itself contained inside a hash. A bit confusing, but it’s important to understand the structure of the data since we’ll need to work with it a lot and this will help us figure out what syntax to use.

Let’s open our rake task in Sublime Text under lib/tasks/scraper.rake. After the puts JSON.pretty_generate result, let’s add ["postings"].first.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts JSON.pretty_generate result["postings"].first
  end
  …
result["postings"] should give us the array of 1,000 postings, so result["postings"].first should give us the first of those postings. Let’s save and run our rake task again.

Command Line
$ rake scraper:scrape
Great – looks like we got exactly one posting back, as we expected. Let’s try grabbing the heading of this post. Since this a hash, we can get this value by adding a ["heading"] at the end.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts JSON.pretty_generate result["postings"].first["heading"]
  end
  …
So result["postings"].first gives us the first posting and the ["heading"] gives us the heading data for that post. Let’s save and try running this.

Command Line
$ rake scraper:scrape
This time, we should get an error that says “only generation of JSON objects or arrays allowed”. The reason why we’re seeing this error is because we’re still using pretty_generate to display our result. That was fine before, when our result was in JSON, or hash, format. But now that we’re displaying the heading only, our result should be a string and we won’t need pretty_generate anymore. A simple puts should be enough, so let’s delete this, save, and try it again.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["heading"]
  end
  …
Command Line
$ rake scraper:scrape
Perfect, looks like we got the heading we wanted. We’ll be able to use this same syntax to grab any of the other data for this post. For example, we can replace heading with body, save, and run it again.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["body"]
  end
  …
Command Line
$ rake scraper:scrape
It’s a little different for location though, because location is a hash as well. Scrolling up, we’ll see that location has a few different fields, but not every post will have these fields available. For example, the locality (which is what 3taps calls a neighborhood) is missing for this specific post. So let’s go back to our code and replace body with location to get the location hash. And then we’ll add a ["locality"].

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].first["location"]["locality"]
  end
  …
Let’s save and run our task again.

Command Line
$ rake scraper:scrape
I got a blank space because this first post doesn’t have a locality, so I’ll replace first with second just to show you that it works.

lib/tasks/scraper.rake
    …
    # Display results to screen
    puts result["postings"].second["location"]["locality"]
  end
  …
I’ll save and run this again.

Command Line
$ rake scraper:scrape
Good – there it is. Now that we know how to grab individual posting data, we can use this knowledge to populate our database of posts. Let’s go back to our text editor, comment out our puts code and write the following:

lib/tasks/scraper.rake
    …
    # Display results to screen
    # puts result["postings"].second["location"]["locality"]

    # Store results in database
    result["postings"].each do |posting|

      # Create new Post
      @post = Post.new
      @post.heading = posting["heading"]
      @post.body = posting["body"]
      @post.price = posting["price"]
      @post.neighborhood = posting["location"]["locality"]
      @post.external_url = posting["external_url"]
      @post.timestamp = posting["timestamp"]

      # Save Post
      @post.save
    end

  end
  …
Here, we’ve written a loop that takes each of the 1,000 or however many postings 3taps gives us, and creates a new Post object to put in our database. That’s stored in the @post variable and one-by-one, we’re filling in the columns for our database.

For example, this line takes the heading field from Craigslist’s data and uses it to fill in the heading column for our database. Similarly, this line takes Craigslist’s locality field that’s stored in the location hash and uses it to fill in the neighborhood column for our database. Finally, we save this @post variable so it gets entered into our database.

Let’s save and try this out.

Command Line
$ rake scraper:scrape
We don’t see any output on the screen this time, but that’s okay because we haven’t used puts to display anything. Instead, we can see if this worked by refreshing our localhost page.

Wow, it’s pretty ugly, but there we go – we’ve got a thousand new posts! Most of the columns seem to be filled in correctly, but scrolling to the right, we’ll see that there are some posts that have blank neighborhoods. That’s fine – we know that not all Craigslist posts have this neighborhood information available.

We’ve just populated our database with 1,000 live Craigslist posts. In the next video, we’ll work with the data we have here to improve the UI of our app.


3.Improve Display of Data
Clean Up Data Formats:
We now have a basic web app with some Craigslist posting data that we’ve loaded from 3taps. In this video, we’re going to clean up our index page with some basic styling to improve the presentation of this data.

Let’s start by using Bootstrap on this table on our index page. We’ll be using the bootstrap-sass gem, so let’s open up our browser and go to the gem page. Let’s follow the instructions and copy the line here. Then, we’ll open up our Gemfile, paste it in at the bottom, and clean this up a bit. The ‘sass-rails’ gem was included in our Gemfile by default, so we can skip this step. And then we’ll add the ‘autoprefixer-rails’ gem as they recommend.

Gemfile
...
gem 'bootstrap-sass', '~> 3.3.1'
gem 'autoprefixer-rails'
Let’s save and run bundle install.

Command Line
$ bundle install
Let’s also remember to restart our Rails server.

Command Line
$ rails s
We now need to setup our CSS and JavaScript files. Unlike the gem page, which tells us to make changes to our application.css.scss stylesheet, I’m going to create a new file in my app/assets/stylesheets directory called custom.css.scss. At the top, let’s copy these two lines of code.

app/assets/stylesheets/custom.css.scss
@import "bootstrap-sprockets";
@import "bootstrap";
We’ll save this and while we’re here, let’s also open the scaffolds.css.scss file that was created when we generated our scaffold and delete all this code to prevent it from conflicting with any custom CSS we write later on. It’s better to do this than to delete the file entirely, because it’ll be recreated if we generate a new scaffold in the future.

app/assets/stylesheets/scaffolds.css.scss

Let’s save and now go to our application.js file, where we’ll copy over the //= require bootstrap-sprockets line and paste it in underneath //= require jquery. Let’s save this as well.

app/assets/javascripts/application.js
…
//= require jquery
//= require bootstrap-sprockets
//= require jquery_ujs
//= require turbolinks
//= require_tree .
With Bootstrap set up, all we need to do to add Bootstrap styling to our table is go to our view page, which is under app/views/posts/index.html.erb, and change <table> to <table class="table">.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table">
  …
Let’s save and refresh our localhost page. It’s already looking a little cleaner. Let’s also add a couple Bootstrap table options. We’ll make it so that the rows are highlighted as we hover over them with the class table-hover. We’ll also add table-condensed to make each row a little shorter.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table table-hover table-condensed">
  …
Let’s save and reload the page. Good.

Next, let’s think about what data we want to display here on the index page versus on the show page. This body field is definitely too long and it’s messing up the spacing on our table, so we’ll get rid of it. The @external_url field is also really long, so we’ll remove that as well.

Let’s go to our view page and delete these two lines along with their corresponding column headings and save.

app/views/posts/index.html.erb
…
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td><%= post.heading %></td
      <td><%= post.price %></td
      <td><%= post.neighborhood %></td
      <td><%= post.timestamp %></td
      …
Our table spacing looks a lot better.

Let’s also remove these ‘Edit’ and ‘Destroy’ links and make this entire heading into a link to the ‘Show’ page. In our code, we’ll delete the column heading for these links and get rid of the ‘Edit’ and ‘Destroy’ code. To convert our ‘heading’ text into a link, we’ll add a ‘link_to’, and put a comma, followed by the route, which is ‘post’. Now we can delete the old ‘Show’ link as well.

app/views/posts/index.html.erb
<h1>Listing posts</h1>

<table class="table table-hover table-condensed">
  <thead>
    <tr>
      <th>Heading</th>
      <th>Price</th>
      <th>Neighborhood</th>
      <th>Timestamp</th>
    </tr>
  </thead>

  <tbody>
    <% @posts.each do |post| %>
      <tr>
        <td><%= link_to post.heading, post %></td>
        <td><%= post.price %></td>
        <td><%= post.neighborhood %></td>
        <td><%= post.timestamp %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New Post', new_post_path %>
Let’s save and refresh our page. Looks good. We can click on any of these post headings to see that it takes us to the ‘Show’ page, which means it’s working.

Let’s also delete the words ‘Listing posts’ at the top and put everything in a Bootstrap container. This just adds some padding to the sides of our screen.

app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    …   
  <%= link_to 'New Post', new_post_path %>
</div>
The last change we’ll make to the index page for now is to adjust the formatting of the ‘Price’ and ‘Timestamp’ fields. For ‘Price’, we want to display the apartment’s rent amount in dollars, so we’ll go back to our code and add the Rails helper ‘number_to_currency(’ in front and close the parentheses.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= post.timestamp %></td>
</tr>
Let’s save. Good. We can remove the decimal places by going back and adding a , precision: 0.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= post.timestamp %></td>
</tr>
Let’s save and check. Great!

If you’re ever unsure about all the different options available for something like number_to_currency, just search it in Google. I’ll type ‘number_to_currency rails’ and click on the first link. You can see that this api.rubyonrails.org site shows us the syntax for number_to_currency, which is to write number_to_currency followed by the number we want to format followed by any number of options we want to include. Here’s the precision option that we’re using and there are even some examples below.

Going back to our table, we can see that the ‘Neighborhood’ field is pretty tough to read. These are the locality code names that 3taps gave us, and we’ll skip this for now, but in a later video we’ll see how to convert these to more user-friendly names.

Finally, we have the ‘Timestamp’ field. This number is shown in Unix time, so we’ll want to convert this to a more easily understandable format. We’ll go to our code and write Time.at( and close our parentheses. Time.at does exactly what it sounds like – given a Unix time value, it tells us the normal date and time. We’ll also need to add a .to_i here because the timestamp field is stored in our database as a string. Since Time.at needs an integer, .to_i does the conversion for us.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= Time.at(post.timestamp.to_i) %></td>
</tr>
Let’s save and go see. Okay, our timestamp is now shown with the date, the time, and the timezone. But instead of displaying it in this format, we can just write how long ago the post was updated. We’ll write time_ago_in_words( and close our parentheses.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= time_ago_in_words(Time.at(post.timestamp.to_i)) %></td>
</tr>
Let’s save and see the change. It now says ‘3 days’. If it were closer to the time when the post was updated, it might say ‘5 hours’ or ‘33 minutes’ instead. I want to add the word ‘ago’ at the end, so it says ‘3 days ago’. We’ll go back to our code and since we’re trying to combine Ruby code with a string, we’ll use a technique called string interpolation. Let me show you how it works.

We can’t just write ‘ago’ at the end of this because then our app will think it’s Ruby code. And if we put this all in double quotes, then our app will think we want our timestamp to literally be ‘time_ago_in_words’ etc. With string interpolation, we can put a hashtag in front of our Ruby code and surround it in curly braces. This way, our app knows which parts are code and which parts are just strings. Anything inside the curly braces is interpreted as code.

app/views/posts/index.html.erb
<tr>
  <td><%= link_to post.heading, post %></td>
  <td><%= number_to_currency(post.price, precision: 0) %></td>
  <td><%= post.neighborhood %></td>
  <td><%= "#{time_ago_in_words(Time.at(post.timestamp.to_i))} ago" %></td>
</tr>
Let’s save and see if it worked. Great!

Finally, let’s rename the column header. We’ll call it ‘Last Updated’, save, and refresh.

app/views/posts/index.html.erb
…
  <th>Heading</th>
  <th>Price</th>
  <th>Neighborhood</th>
  <th>Last Updated</th>
…
Through our Bootstrap styling, data formatting, and removal of a couple columns, our table looks much better than it did at the start of this video. In the next video, we’ll continue working on this index page by adding pagination so we don’t need to load all 1,000 posts here at once.

Paginate the Index Page:
Here’s what our index page looks like now. What we’ll do in this video is add pagination to divide these 1,000 posts into multiple pages.

Whenever you want to add a new feature on your site, it helps to know which gems are available so you can avoid having to write all the code from scratch. A great resource for discovering and comparing gems is a site called The Ruby Toolbox.

For example, if we want to see our options for setting up pagination, we can search ‘ruby toolbox pagination’. We’ll click on the link to go to the Ruby Toolbox website. Ruby Toolbox organizes gems into different categories, one of which is pagination. The site ranks the gems in that category by popularity, which it calculates using a combination of gem downloads and activity on the gem’s GitHub page.

So here we can see that there are two main gems, will_paginate and kaminari, that are equally popular for pagination. If we want, we can click on the links to check out each gem’s documentation and compare the setup instructions and options that each gem comes with. In this case, I’ve used both of these before and they’re pretty similar, so let’s just go with the will_paginate gem.

To install the gem, we’ll copy this line and paste it into our Gemfile.

Gemfile
…
gem 'will_paginate', '~> 3.0.6'
We’ll save, run bundle install, and restart our Rails server.

Command Line
$ bundle install
Command Line
$ rails s
Now setting up this gem is pretty simple. There are only two things we have to do. First, we need to use this .paginate method or even better, the .paginate method with the option to specify the number of posts per page. Let’s copy this last part, open up our controller file, and paste it in after Post.all. If we want, we can change this 30 to any other number, but 30 posts per page sounds about right to me.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
end
…
Let’s save this.

The second thing we need to do is put this <%= will_paginate @posts %> line in our view page. Let’s copy this, go to our app/views/posts/index.html.erb file and paste it at the bottom, right before the <br>. We don’t even need to customize this at all because this sample code has @posts, which happens to be the same name as the variable that we’ve defined in our controller. Remember that whatever variables we define in our controller in the index section will be available to our corresponding view page, index.html.erb.

app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>
Let’s save this and see it in our browser. There we go. The page numbers appear at the bottom where we placed our line of code. We can go to the next page by clicking on ‘2’ or ‘Next’, and we can go to the last page by clicking on ‘34’. Great!

The will_paginate gem is all set up now, but let’s make the styling look consistent with our Bootstrap table by using a second gem called will_paginate-bootstrap. Let’s Google this and go to the gem’s GitHub page. Let’s follow the installation instructions and copy this line and paste it into our Gemfile.

Gemfile
…
gem 'will_paginate-bootstrap'
We’ll save, run bundle install, and restart our Rails server.

Command Line
$ bundle install
Command Line
$ rails s
Now to set it up, we only need to change a single line. In our index.html.erb file, where we wrote <%= will_paginate @posts %>, we need to add a , renderer: BootstrapPagination::Rails. Let’s copy this, go to our index.html.erb file, and paste it in here. And save.

app/views/posts/index.html.erb
…
  </table>

  <%= will_paginate @posts, renderer: BootstrapPagination::Rails %>

  <br>

  <%= link_to 'New Post', new_post_path %>
</div>
We’ll reload our localhost page and look, we’re done.

Our index page is now looking pretty good, with nice formatting and Bootstrap-styled pagination. We’ll hold off on improving our show page and instead in the next video, we’ll see if we can go back and grab more detailed information on these Craigslist posts from 3taps, like the number of bedrooms and bathroom.


4.Gather Detailed Data
Scrape Apartment Details:
In the last few videos, we created our web app, loaded it with Craigslist data that we got from 3taps, and added some basic styling to our index page to allow our app to look presentable. This time, we’ll go back and take a second look at our 3taps data to see if we can pull some extra details.

If we look at any apartment listing on Craigslist, we’ll see that there are these tags on the right side. These tags show details like the number of bedrooms and bathrooms, when the apartment will be available, and whether cats or dogs are allowed. But these tags vary from post to post. They’re all optional, so some listings will be more complete than others.

Let’s see if we can access these details through 3taps. We’ll go back to our rake task under lib/tasks/scraper.rake. If we run this task as-is, it’s going to store another 1,000 posts into our database. So since we just want to explore around, let’s comment out this whole section. Then we’ll replace this line with puts JSON.pretty_generate result["postings"], which will display all the posting data onto the screen.

lib/tasks/scraper.rake
…
# Display results to screen
puts JSON.pretty_generate result["postings"]

# # Store results in database
# result["postings"].each do |posting|

#   # Create new Post
#   @post = Post.new
#   @post.heading = posting["heading"]
#   @post.body = posting["body"]
#   @post.price = posting["price"]
#   @post.neighborhood = posting["location"]["locality"]
#   @post.external_url = posting["external_url"]
#   @post.timestamp = posting["timestamp"]

#    # Save Post
#    @post.save
…
Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Okay, let’s take a look at some of these. It looks like most of the tag data is stored in this field called annotations. This specific listing has information on the number of bathrooms, the number of bedrooms, the neighborhood name, a link to a Google map of the address, the date the apartment will be available, whether cats or dogs are allowed, and even the phone number and IP address of the person who posted it.

Let’s look at a different post. This one seems to have a bunch of the same fields. The format of the bathrooms (“1ba”) and bedrooms (“0br”) seems to be consistent (“2ba”, “2br”). The source_neighborhood seems to be user-inputted with lowercase ‘bedstuy’ here and all caps ‘BEDSTUY / CROWN HEIGHTS’ here, so it’s good that we took our neighborhood information directly from 3taps’s location field as it’ll already be standardized.

What else? The values for cats and dogs seem to be consistent as well. They both have “YES” in all caps up here and down here.

Let’s choose a few of these fields to add as columns in our database. We’ll pick bedrooms, bathrooms, cats, dogs, and I’ll also throw in a few more fields, sqft and two more that seem to be pretty common in Brooklyn. One is a field called w_d_in_unit, which tells whether a washer and dryer are available in the apartment, and another is called street_parking, which tells us whether street parking is available outside the building.

Let’s generate a migration to add these extra fields to our Post database. We’ll write rails generate migration AddFieldsToPosts bedrooms:integer bathrooms:decimal sqft:integer cats dogs w_d_in_unit street_parking.

Command Line
$ rails generate migration AddFieldsToPosts bedrooms:integer bathrooms:decimal sqft:integer cats dogs w_d_in_unit street_parking
There are a couple points I should note here. First, bathrooms is a decimal because an apartment can have a half bath without a shower. Second, you’ll notice that the 3taps bathrooms and bedrooms values don’t just have a number, like 2 or 3. Instead, they’ll say ‘2ba’ or ‘3br’. But if we tell our app to save something like ‘2ba’ as an integer, it’ll ignore everything after the ‘2’ and save it as just the number ‘2’. So this little shortcut makes our life easier when it comes to formatting data.

Let’s hit Enter and then run rake db:migrate to add these new columns to our Post database.

Command Line
$ rake db:migrate
We’ll also restart our Rails server.

Command Line
$ rails s
We want to repopulate our database with all the columns this time, so let’s clear the old data out first. We could do this through the Rails console, but we might need to do it again later on, so let’s write a quick rake task.

In our scraper.rake file, we’ll go to the bottom and fill in the section for the destroy_all_posts task we created earlier. As the description, let’s write “Destroy all posting data” and for the actual task, we’ll write the following:

lib/tasks/scraper.rake
desc "Destroy all posting data"
task destroy_all_posts: :environment do
  Post.destroy_all
end
This destroy_all method destroys all the objects in our Post database. Let’s save and run it with rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Now when we refresh our localhost page, we’ll see it’s empty.

With our database emptied, let’s go back to our scrape task and figure out the code we need to write to access these new fields. It should pretty similar to the code we wrote to grab the neighborhood. In that situation, we wrote posting["location"] to get the location hash and then ["locality"] to get the value from within the hash.

Let’s try grabbing the bedrooms field. We’ll grab a single posting using puts result["postings"].first, and then we’ll tack on a ["annotations"] to get the annotations hash and then ["bedrooms"] to get the bedrooms field.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["annotations"]["bedrooms"]
…
Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Good, we got it. There’s one problem though – this won’t work in situations where the bedrooms field is missing. For example, we can comment out this current line and look at the annotations hash of the first posting with puts JSON.pretty_generate result["postings"].first["annotations"].

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["bedrooms"]
puts JSON.pretty_generate result["postings"].first["annotations"]
…
I’ll save and re-run this.

Command Line
$ rake scraper:scrape
You can see that this posting lacks the sqft field, for example. So if we delete this line and run the same code as before but with sqft instead of bedrooms, let’s see what happens.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["annotations"]["sqft"]
…
Command Line
$ rake scraper:scrape
We got a blank line. In other words, our rake task couldn’t find the sqft field and so it returned nil. This could be a problem because we’ve told our database that the sqft column should be an integer so when it sees nil, rather than leave our column blank, it’s going to put in 0 as the square footage.

To avoid this situation, we’ll have to first check whether the field exists. We’ll go back to our code, comment out the line where we display results to the screen, and uncomment out the section where we store our results in the database. After we set the post’s timestamp, let’s write:

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["sqft"]

# Store results in database
result["postings"].each do |posting|

  # Create new Post
  @post = Post.new
  @post.heading = posting["heading"]
  @post.body = posting["body"]
  @post.price = posting["price"]
  @post.neighborhood = posting["location"]["locality"]
  @post.external_url = posting["external_url"]
  @post.timestamp = posting["timestamp"]

  if posting["annotations"]["bedrooms"].present?
    @post.bedrooms = posting["annotations"]["bedrooms"]
  end

  # Save Post
  @post.save
…
This is saying that if the bedrooms field exists, then save it to the bedrooms column of our database. We can even simplify this into a one-liner by moving the ‘if statement’ and deleting the end.

lib/tasks/scraper.rake
…
@post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
…
Let’s do this same thing for each one of our new fields.

lib/tasks/scraper.rake
…
# Display results to screen
# puts result["postings"].first["annotations"]["sqft"]

# Store results in database
result["postings"].each do |posting|

  # Create new Post
  @post = Post.new
  @post.heading = posting["heading"]
  @post.body = posting["body"]
  @post.price = posting["price"]
  @post.neighborhood = posting["location"]["locality"]
  @post.external_url = posting["external_url"]
  @post.timestamp = posting["timestamp"]
  @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
  @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
  @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
  @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
  @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
  @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
  @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

  # Save Post
  @post.save
…
Okay, let’s save and try running this.

Command Line
$ rake scraper:scrape
To see if it worked, I’m going to use a tool called SQLite Database Browser. You can download it by searching ‘SQLite Database Browser’, clicking the sourceforge link, and hitting ‘Download’. Once it’s installed, open it up, click on the ‘Open Database’ link on top, navigate to your ‘craigslist_scraper’ app directory, click on ‘db’ and double-click ‘development.sqlite3’. Make sure you’re in the ‘Browse Data’ tab and looking at the ‘posts’ table.

Scrolling to the right, we can see the new fields we’ve added and the good news is that most of them seem to be filled in. The majority of our posts have bedrooms and bathrooms filled in, along with cats and dogs, while sqft, w_d_in_unit, and street_parking are only available for a portion of our apartments.

With our new data fields added, it’s time to update our index and show pages with this new information in the next video.

Display Details:
Now that we’ve correctly populated our database with these new fields, let’s display this information on our app’s pages as well.

Let’s open up our Sublime Text and we’ll go to our view page code under app/views/posts/index.html.erb and add a couple new column headings:

app/views/posts/index.html.erb
<div class="container">
  <table class="table table-hover table-condensed">
    <thead>
     <tr>
       <th>Heading</th>
       <th>Price</th>
       <th>Beds</th>
       <th>Baths</th>
       <th>Neighborhood</th>
       <th>Last Updated</th>
     </tr>
    </thead>
    …
We’ll also add the data values below. After the line for ‘Price’, we’ll write:

app/views/posts/index.html.erb
<tbody>
  <% @posts.each do |post| %>
    <tr>
      <td><%= link_to post.heading, post %></td>
      <td><%= number_to_currency(post.price, precision: 0) %></td>
      <td><%= post.bedrooms %></td>
      <td><%= post.bathrooms %></td>
      …
Let’s save and see how it looks. Great!

Now for our Show page, we haven’t done any styling here yet, but I want to at least have the new data be displayed here so we’ll be ready when we need to format it later on. Let’s go to our code under app/views/posts/show.html.erb and below ‘Timestamp’, we’ll write:

app/views/posts/show.html.erb
…
<p>
  <strong>Timestamp:</strong>
  <%= @post.timestamp %>
</p>

<p>
  Bedrooms: <%= @post.bedrooms %>
</p>

<p>
  Bathrooms: <%= @post.bathrooms %>
</p>

<p>
  Square Footage: <%= @post.sqft %>
</p>

<p>
  Cats allowed: <%= @post.cats %>
</p>

<p>
  Dogs allowed: <%= @post.dogs %>
</p>

<p>
  Washer/dryer in unit: <%= @post.w_d_in_unit %>
</p>

<p>
  Street parking: <%= @post.street_parking %>
</p>
…
Let’s save and refresh our Show page. It’s neither pretty nor consistent, but at least the information is all here. While we’re here on the Show page, let’s also put this into a “container” class.

app/views/posts/show.html.erb
<p id="notice"><%= notice %></p>

<div class="container">
  <p>
    <strong>Timestamp:</strong>
    <%= @post.timestamp %>
  </p>
  ...
  <%= link_to 'Edit', edit_post_path(@post) %> | 
  <%= link_to 'Back', posts_path %>
</div>
We’ll save and refresh.

We now have a lot more data on each listing, from the price to the location, even on whether cats or dogs are allowed. In the next video, we’ll work on grabbing and displaying the last set of data we need, the images uploaded with each post.

Collect and Store Images:
We’ve now grabbed most of the relevant information on our Craigslist posts, but we’re still missing one very important thing: images.

We saw in an earlier video that 3taps gives us a list of URLs containing the images that were uploaded with the post. What we’ll do this time is grab those images and store them in our database.

Normally, when we want to attach images to a resource like our posts, we would use a file attachment gem like paperclip or carrierwave. This situation is different because we no longer need to attach an actual file – we can simply store the URL as a string instead.

Since each post can have multiple images, it’s best to create a new database for these image URLs that’s linked to our database of Posts. This is a has_many/belongs_to relationship, where a Post has many Images, and an Image belongs to a specific Post.

We’ll go to our command line and we could write rails generate model Image url:text, which would create an Image table for us with a single column, url. Notice that we’re storing the URL as text instead of string because strings max out at 256 characters and URLs for images could be very long, whereas URLs for Craigslist are standardized. After running this command, we’d then have to create another migration to add a post_id column which tells us which Post an Image belongs to.

But there’s a shortcut we can use to do it all in a single command. At the end of this, we’ll add a post:references. This will automatically create the post_id column for us. Let’s hit Enter, run rake db:migrate, and restart our Rails server.

Command Line
$ rails generate model Image url:text post:references
$ rake db:migrate
Command Line
$ rails s
Now that our database columns have been created, we need to go to our model files and set up the has_many/belongs_to relationship. If we open our app/models/image.rb file, we’ll see that the belongs_to side has already been done for us, so let’s open post.rb and write has_many :images. We’ll also add , dependent: :destroy, which will cause an Image to be deleted when the Post it belongs to is destroyed.

app/models/post.rb
class Post < ActiveRecord::Base
  has_many :images, dependent: :destroy
end
Let’s save that. If we want, we can open up our SQLite Database Browser, navigate to our app’s database, go to ‘Browse Data’, and look at our new Images table. Here are the url and post_id columns that we created. We now want to populate this table and have many image URLs in this column, all tied to an ID here that corresponds to an ID from our table of Posts.

To do this, we’ll open up our rake task under lib/tasks/scraper.rake. Like last time, let’s comment out the section where we save to our database so we can figure out the right syntax to use to grab the image URLs. We’ll then uncomment this line and write puts JSON.pretty_generate result["postings"].first["images"] which will grab the images hash that we want.

lib/tasks/scraper.rake
  …
  # Display results to screen
  puts JSON.pretty_generate result["postings"].first["images"]

  # # Store results in database
  # result["postings"].each do |posting|

  #   # Create new Post
  #   @post = Post.new
  #   @post.heading = posting["heading"]
  #   @post.body = posting["body"]
  #   @post.price = posting["price"]
  #   @post.neighborhood = posting["location"]["locality"]
  #   @post.external_url = posting["external_url"]
  #   @post.timestamp = posting["timestamp"]
  #   @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
  #   @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
  #   @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
  #   @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
  #   @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
  #   @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
  #   @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

  #   # Save Post
  #   @post.save
  # end
end
…

Let’s save and run this with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Ok, so to grab just this URL, we’ll look at the first image and take the name that corresponds to “full”. In our code, we’ll add .first["full"], but since the result won’t be a hash anymore, we’ll need to delete the JSON.pretty_generate.

lib/tasks/scraper.rake
…
# Display results to screen
puts result["postings"].first["images"].first["full"]
…
Let’s save, and run this again.

Command Line
$ rake scraper:scrape
Good – that’s the URL we wanted. Let’s see if we can get this to save to our database. We’ll comment out this line of code and uncomment the section where we save to our database.

lib/tasks/scraper.rake
  …
  # Display results to screen
  # puts result["posting"].first["images"].first["full"]

  # Store results in database
  result["postings"].each do |posting|

    # Create new Post
    @post = Post.new
    @post.heading = posting["heading"]
    @post.body = posting["body"]
    @post.price = posting["price"]
    @post.neighborhood = posting["location"]["locality"]
    @post.external_url = posting["external_url"]
    @post.timestamp = posting["timestamp"]
    @post.bedrooms = posting["annotations"]["bedrooms"] if posting["annotations"]["bedrooms"].present?
    @post.bathrooms = posting["annotations"]["bathrooms"] if posting["annotations"]["bathrooms"].present?
    @post.sqft = posting["annotations"]["sqft"] if posting["annotations"]["sqft"].present?
    @post.cats = posting["annotations"]["cats"] if posting["annotations"]["cats"].present?
    @post.dogs = posting["annotations"]["dogs"] if posting["annotations"]["dogs"].present?
    @post.w_d_in_unit = posting["annotations"]["w_d_in_unit"] if posting["annotations"]["w_d_in_unit"].present?
    @post.street_parking = posting["annotations"]["street_parking"] if posting["annotations"]["street_parking"].present?

    # Save Post
    @post.save
  end
end
The image URLs won’t be going in the database of Posts, so after ‘@post.save’, we’ll write:

lib/tasks/scraper.rake
    …
    # Save Post
    @post.save

    # Loop over images and save to Image database
    posting["images"].each do |image|
      @image = Image.new
      @image.url = image["full"]
      @image.post_id = @post.id 
      @image.save
    end  
  end
end
The code we just wrote is looping over the images hash of a post and for each of those URLs, it’s creating a new row in our Image database where we’re grabbing the URL and putting it in the url column. Then we’re taking the ID of the Post we just saved above and we’re putting that in the post_id column. Let’s save.

Before we run this, we’ll need to clear out our database of Posts again. Otherwise, we’re going to get repeats of the same 1,000 posts that are there already. To do that, we’ll run rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Now we’ll run rake scraper:scrape to populate our Post and Image databases.

Command Line
$ rake scraper:scrape
It takes a while to finish, but once it’s done, let’s look in our database to see if it worked. In our Images table, we can see we now have thousands of image URLs, each linked to a specific Post ID. That’s great.

Now, let’s display it in our Show page. Let’s open our app at localhost:3000/posts. We’ll click on one of these links to get to the Show page. We’ll see if we can display all the images for the Post down here.

Let’s first go to our controller file under app/controllers/posts_controller.rb, and in the ‘show’ section, we’ll define a new variable. We’ll write:

app/controllers/posts_controller.rb
…
def show
  @images = @post.images
end
…
This code finds all the images in our Image database that belong to the current Post. Let’s save this, and we’ll now be able to use this variable from our view page. Let’s go to app/views/posts/show.html.erb and right before the ‘Edit’ link, we’ll write:

app/views/posts/show.html.erb
  …
  <p>
    Street parking: <%= @post.street_parking %>
  </p>

  <% @images.each do |image| %>
    <%= image_tag image.url %>
  <% end %>

  <%= link_to 'Edit', edit_post_path(@post) %> |
  <%= link_to 'Back', posts_path %>
</div>
This will loop over each image and display the image that’s pulled from its URL. Let’s save and see this in our browser.

Alright, the images show up, but the spacing is off. To force them each onto a row of their own, we could add some <br> tags, but instead let’s add Bootstrap’s ‘thumbnail’ class. We’ll add a , class: "thumbnail" and save.

app/views/posts/show.html.erb
  …
  <% @images.each do |image| %>
    <%= image_tag image.url, class: "thumbnail" %>
  <% end %>

  <%= link_to 'Edit', edit_post_path(@post) %> |
  <%= link_to 'Back', posts_path %>
</div>
When we refresh, we’ll see that this has the extra benefit of adding a slight border around the image.

With images now set up, our dataset is nearly complete. There’s one last formatting change we should make, which is to translate these 3taps codes into actual neighborhood names. We’ll get started on that in the next video.


5.Scrape Location Data
Look Up Meighborhoods:
We’ve now saved all the data fields we want to our database. But let’s see if we can take the 3taps neighborhood codes and convert them into human-readable names. The perfect tool for the job is the 3taps Reference API that we used early on.

To refresh our memory, let’s go to the 3taps website and look at the documentation. We’ll be using the fourth section on Locations. If we want to get a list of neighborhood codes in Brooklyn, we’ll need the auth_token parameter, the locality parameter (which is 3taps’s name for a neighborhood), and also this optional city parameter which will limit our list to neighborhoods in Brooklyn only.

We’ll use these parameters to create a new rake task, where our goal will be to save a list of locality codes and their corresponding neighborhood names into our own database. But before we do that, we need to create the database itself. Let’s write rails generate model Location code name. This will create a new Location database with two columns, one for the 3taps code and another for the human-readable name.

Command Line
$ rails generate model Location code name
Let’s hit Enter, run ‘rake db:migrate’, and restart our Rails server.

Command Line
$ rake db:migrate
Command Line
$ rails s
Let’s now go to Sublime Text and open our lib/tasks/scraper.rake file. Scroll to the bottom and copy our ‘destroy_all_posts’ task which we’ll use as a template. Let’s paste it below and replace the description with “Save neighborhood codes in a reference table”. Instead of ‘destroy_all_posts’, let’s name this task ‘scrape_neighborhoods’.

lib/tasks/scraper.rake
  desc "Save neighborhood codes in a reference table"
  task scrape_neighborhoods: :environment do
    Post.destroy_all
  end

end
For the task’s code, we’ll delete this line and copy the code from the ‘scrape’ task above, up to the part where we store results in our database. Let’s paste it in here.

lib/tasks/scraper.rake
desc "Save neighborhood codes in a reference table"
task scrape_neighborhoods: :environment do
  require 'open-uri'
  require 'json'

  # Set API token and URL
  auth_token = "{YOUR_AUTH_TOKEN}"
  polling_url = "http://polling.3taps.com/poll"

  # Specify request parameters
  params = {
    auth_token: auth_token,
    anchor: {YOUR_ANCHOR},
    source: "CRAIG",
    category_group: "RRRR",
    category: "RHFR",
    'location.city' => "USA-NYM-BRL",
    retvals: "location,external_url,heading,body,timestamp,price,images,annotations"
  }

  # Prepare API request
  uri = URI.parse(polling_url)
  uri.query = URI.encode_www_form(params)

  # Submit request
  result = JSON.parse(open(uri).read)

  # Display results to screen
  # puts result["postings"].first["images"].first["full"]
end
Since the code to make a data request is pretty similar, we’ll be able to use this as a base and just customize some of the details instead. Our auth_token is still the same, so we’ll leave that here, but we’re no longer using the 3taps Polling URL. Let’s rename this to be location_url and replace the URL itself with the one from the documentation. Don’t forget to change the polling_url down below as well.

lib/tasks/scraper.rake
  …
  # Set API token and URL
  auth_token = "{YOUR_AUTH_TOKEN}"
  location_url = "http://reference.3taps.com/locations"

  …

  # Prepare API request
  uri = URI.parse(location_url)
  uri.query = URI.encode_www_form(params)
  …
For the parameters, we’ll keep the auth_token and delete the rest. Instead, the other two parameters we need are level: "locality" and city: "USA-NYM-BRL", which is the 3taps code for Brooklyn. For now, let’s just display the entire JSON hash, so we’ll write puts JSON.pretty_generate result and save.

lib/tasks/scraper.rake
  …
  # Specify request parameters
  params = {
    auth_token: auth_token,
    level: "locality",
    city: "USA-NYM-BRL"
  }

  …

  # Display results to screen
  puts JSON.pretty_generate result
end
Let’s run this with rake scraper:scrape_neighborhoods.

Command Line
$ rake scraper:scrape_neighborhoods
If we scroll up, we’ll see that all of these sections are contained in a hash called locations. And we want the code and the short_name fields. In other words, we want to be able to look up “USA-NYM-WIU” and see that it’s the code for “Williamsburg”.

To do that, we’ll comment out this line and write a loop similar to the one from our first task:

lib/tasks/scraper.rake
  …
  # Display results to screen
  # puts JSON.pretty_generate result

  # Store results in database
  result["locations"].each do |location|
    @location = Location.new
    @location.code = location["code"]
    @location.name = location["short_name"]
    @location.save
  end
end
For each result we get back from 3taps, this will create a new row in our Location database table and fill in the code and name columns with the code and short_name values 3taps gives us. Let’s save and run this to see if it works.

Command Line
$ rake scraper:scrape_neighborhoods
Now we’ll open our database in SQLite Database Browser and go to the Locations table. Perfect – our app now has a table of neighborhood codes and names to use as a reference. With this set up, we can now translate these codes on our index page in the next video.

Display Neighborhoods:
In the last video, we created a new Location database to store a list of both the 3taps neighborhood codes as well as their corresponding human-readable names. In this video, we’ll take the neighborhood codes that appear in our index page and translate them.

We could take each code and use the Locations table to look up the matching neighborhood name, but we should avoid doing that because we’ll need to run these translations every time we load the index page. Instead, we can be more efficient by storing the human-readable names directly into our Post database. This way, we’ll only need to translate them a single time and avoid having to run these lookups again in the future.

We’ll do the translations when we first collect the data from 3taps. That means we need to update our rake task under lib/tasks/scraper.rake. Here, where we’re saving the neighborhood code, we should look up this code in our database and save the neighborhood name instead. We’ll write:

lib/tasks/scraper.rake
namespace :scraper do
  desc "Fetch Craigslist posts from 3taps"
  task scrape: :environment do
    …
    # Store results in database
      result["postings"].each do |posting|
        
        # Create new Post
        @post = Post.new
        @post.heading = posting["heading"]
        @post.body = posting["body"]
        @post.price = posting["price"]
        @post.neighborhood = Location.find_by(code: posting["location"]["locality"]).name
        …
This will look in our Location database, find the row with a code that matches the one we’ve grabbed, and give us the corresponding neighborhood name instead. For example, if the posting’s ‘locality’ is “USA-NYM-WIU”, then this will look in our database, find the row at the bottom with a code of “USA-NYM-WIU” and give us the corresponding name of “Williamsburg”.

Let’s save this and before we run it, clear our database again with rake scraper:destroy_all_posts. Remember that since we added the dependent: :destroy to our model file last time, this rake task will not only delete all our Posts, but it’ll also delete the Images that belong to those Posts.

Command Line
$ rake scraper:destroy_all_posts
Now we’ll run our scrape task with rake scraper:scrape.

Command Line
$ rake scraper:scrape
We got an error: “NoMethodError: undefined method `name’ for nil:NilClass”. This is a pretty common error – it’s one that we’ll see when code that we think should equal one thing equals nil instead. It says the error is from line 40, and we’ll see that that’s the line we just changed.

Here’s where we’re using the name method which is causing the problem. The name method should normally be fine. Given a row in our Location database, the name method will tell us the value stored in the name column. The problem occurs when this part is nil, or when it can’t find a Location with this matching code field. That happens whenever we have a locality code that doesn’t exist in our database or more likely, when we come across a posting where the locality is blank.

When the neighborhood data is missing, it’s fine to leave that column in our database blank, but we definitely don’t want an error that’ll cause our task to stop running. So to solve this problem, we’ll use a convenient method called try. Instead of .name, we’ll write .try(:name).

lib/tasks/scraper.rake
…
@post.neighborhood = Location.find_by(code: posting["location"]["locality"]).try(:name)
…
If the name is available, it will work as normal, but if it’s not available, then it’ll leave our database column blank and keep going. Let’s save and clear our database again with rake scraper:destroy_all_posts.

Command Line
$ rake scraper:destroy_all_posts
Then we’ll run this again with rake scraper:scrape.

Command Line
$ rake scraper:scrape
Let’s go look at our index page. That’s much better. In the next video, we’ll take the information we’ve collected and work on creating some filters to help users more easily browse the posts on our site.


6.Add Data Filters
Build an Advanced Filter:
Our index page is looking great now. We’re showing all the data we want with nice formatting and even pagination. It’s time to make it easier to browse these posts by adding an advanced filter on top that will allow users to show only posts with a specific number of bedrooms, bathrooms, price ranges, and so on.

We’ll work up to having multiple filters, but we’ll start with a single filter for the number of bedrooms and then build it up layer-by-layer. Let’s go to our view page under app/views/posts/index.html.erb. Under our <div class="container">, we’ll write the following:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms %>
 
      <%= submit_tag "Search" %>
    <% end %>
  </div>

  …
Here we’re using form_tag to create a form. This form has one input field, bedrooms, and a submit button that says “Search”. By putting posts_path (which is the path for our index page), submitting this form will send us to the index page. The method: :get at the end makes sure it’s a normal GET request so we’re not saving anything to a database but instead, the parameters appear in the URL. Let’s save this and see how it looks.

If we try submitting this form with bedrooms as 1 for example, we’ll see that our bedrooms parameter appears in the URL, but the posts that are shown below remain unchanged.

Of the other two parameters, utf8=✓ is automatically added as it’s needed for Internet Explorer browsers, so we’ll leave it there. The commit parameter doesn’t really do anything though, and we can prevent it from showing up by going to our code and adding the , name: nil option to the end.

app/views/posts/index.html.erb
…
<%= submit_tag "Search", name: nil %>
…
Let’s save, go back to localhost:3000/posts and try submitting the form again. Great – we now just have the utf8 and bedrooms parameters.

Let’s use the bedrooms parameter to filter the posts that get shown. We’ll go to our controller file under app/controllers/posts_controller.rb and write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"])
end
…
This line takes the @posts variable that we’ve defined in the line above, selects only those in the list that have the specified number of bedrooms, and replaces the old list in that same @posts variable.

Let’s save and refresh the page. Now, all the posts in our table have only one bedroom, which means our filter is working. Let’s build on this and add a second filter for the number of bathrooms. We’ll start by adding a second input field to our form. We’ll copy the two lines for our bedrooms field and customize it to say bathrooms instead.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
After saving, we’ll go to our controller file and write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"])
  @posts = @posts.where(bathrooms: params["bathrooms"])
end
…
You can see how we’re chaining these together to narrow down our list based on the filter criteria. Let’s save and refresh the page to see our updated filter. We can try searching for 2-bedroom apartments with 1.5 bathrooms and see that it works.

But if instead we leave one of these fields blank by searching for just 2 bedrooms, our filter will return no results. It’s doing this because our app sees these as required fields. So when we leave the field blank, it searches for posts that have an empty string as the number of bathrooms, when of course there are none.

We need to tell our controller to apply the filters only when the field was filled in. To do that, we’ll add a couple ‘if statements’:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"]) if params["bedrooms"].present?
  @posts = @posts.where(bathrooms: params["bathrooms"]) if params["bathrooms"].present?
end
…
Let’s save and refresh the page. This time, it works!

But notice that the filters we apply always disappear after we hit ‘Search’. We can make them persist by adding an option to our input field. In our index.html.erb file, after text_field_tag :bedrooms we’ll write , params[:bedrooms] and do the same for our bathrooms input field.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
What this code does is set the default value of the field to be the value of the parameter in the URL. So when we hit ‘Search’, our search terms are used to auto-populate the filter for us.

Let’s save and try searching again. We’ll see that this time, our search results persist. Great job with filtering our first two fields!

Let’s add filters for each of the remaining fields users might want to search by. We’ll copy and paste this section and replace bedrooms with neighborhood.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>

      <%= label_tag :neighborhood %>
      <%= text_field_tag :neighborhood, params[:neighborhood] %>
 
      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll repeat this for a few more fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      <%= label_tag :bedrooms %>
      <%= text_field_tag :bedrooms, params[:bedrooms] %>

      <%= label_tag :bathrooms %>
      <%= text_field_tag :bathrooms, params[:bathrooms] %>

      <%= label_tag :neighborhood %>
      <%= text_field_tag :neighborhood, params[:neighborhood] %>

      <%= label_tag :price %>
      <%= text_field_tag :price, params["price"] %>

      <%= label_tag :sqft %>
      <%= text_field_tag :sqft, params["sqft"] %>

      <%= label_tag :cats %>
      <%= text_field_tag :cats, params["cats"] %>

      <%= label_tag :dogs %>
      <%= text_field_tag :dogs, params["dogs"] %>

      <%= label_tag :w_d_in_unit %>
      <%= text_field_tag :w_d_in_unit, params["w_d_in_unit"] %>

      <%= label_tag :street_parking %>
      <%= text_field_tag :street_parking, params["street_parking"] %>

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
Let’s save this and go to our controller file to add the code that will filter by these parameters. We’ll copy the last line and paste it in, changing bathroom to neighborhood. We’ll do the same thing again for price, sqft, cats, dogs, w_d_in_unit, and finally street_parking.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  @posts = @posts.where(bedrooms: params["bedrooms"]) if params["bedrooms"].present?
  @posts = @posts.where(bathrooms: params["bathrooms"]) if params["bathrooms"].present?
  @posts = @posts.where(neighborhood: params["neighborhood"]) if params["neighborhood"].present?
  @posts = @posts.where(price: params["price"]) if params["price"].present?
  @posts = @posts.where(sqft: params["sqft"]) if params["sqft"].present?
  @posts = @posts.where(cats: params["cats"]) if params["cats"].present?
  @posts = @posts.where(dogs: params["dogs"]) if params["dogs"].present?
  @posts = @posts.where(w_d_in_unit: params["w_d_in_unit"]) if params["w_d_in_unit"].present?
  @posts = @posts.where(street_parking: params["street_parking"]) if params["street_parking"].present?
end
…
Let’s save and refresh the page. It looks messy, but it should work. We’ll try typing in Williamsburg as the neighborhood and YES in the cats field and sure enough, the filter works!

Great job! In the next video, we’ll improve the format of our filters so it’s more intuitive to use.

Improve Filter Display:
Last time, we created these filters for data, but these text input fields aren’t ideal. Users shouldn’t have to type YES to search for apartments that allow cats. Instead, it should be a simple checkbox. In fact, the same is true for dogs, w_d_in_unit, and street_parking. Let’s go make that change.

In our index.html.erb file under app/views/posts, we’ll delete this text_field_tag line and replace it with:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :cats %>
      <%= check_box_tag :cats, "YES", params[:cats] %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
The syntax for this is the name of the parameter (:cats), followed by the value of the parameter when checked, which in our case is "YES" because that’s what will match what’s in our database. Finally, the params[:cats] at the end sets the default value of the checkbox.

Let’s repeat this for our three other fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :cats %>
      <%= check_box_tag :cats, "YES", params[:cats] %>

      <%= label_tag :dogs %>
      <%= check_box_tag :dogs, "YES", params[:dogs] %>

      <%= label_tag :w_d_in_unit %>
      <%= check_box_tag :w_d_in_unit, "YES", params[:w_d_in_unit] %>

      <%= label_tag :street_parking %>
      <%= check_box_tag :street_parking, "YES", params[:street_parking] %>

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll save and check it out. We’ll search for apartments in Williamsburg that allow cats and dogs. Good – it works.

Let’s now make our neighborhood field into a dropdown menu that displays all the possible neighborhoods in Brooklyn. We’ll go to our code and replace this text_field_tag line with:

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :neighborhood %>
      <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
Here, the select_tag is creating a dropdown menu for the neighborhood field. The options_from_collection_for_select is basically taking the objects in our Location database, which are neighborhood names, and it’s using the name column to populate our dropdown menu. The include_blank: true at the end will show a blank as the first dropdown result.

Let’s save and see the change in our browser. There we go – that should make it a lot easier for our users.

The last change we’ll make is split our ‘Price’ and ‘Sqft’ filters into a minimum and maximum range. Let’s copy this price section and rename them to be min_price and max_price. We’ll do the same for sqft.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <%= label_tag :min_price %>
      <%= text_field_tag :min_price, params[:min_price] %>

      <%= label_tag :max_price %>
      <%= text_field_tag :max_price, params[:max_price] %>

      <%= label_tag :min_sqft %>
      <%= text_field_tag :min_sqft, params[:min_sqft] %>

      <%= label_tag :max_sqft %>
      <%= text_field_tag :max_sqft, params[:max_sqft] %>
      …

      <%= submit_tag "Search", name: nil %>
    <% end %>
  </div>

  …
We’ll save and this time, we also need to adjust our controller code. So in our app/controllers/posts_controller.rb, rather than where(price: params["price"], we’ll write:

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  …
  @posts = @posts.where("price > ?", params["min_price"]) if params["min_price"].present?
  @posts = @posts.where("price < ?", params["max_price"]) if params["max_price"].present?
  …
end
…
Now let’s repeat that for sqft.

app/controllers/posts_controller.rb
…
def index
  @posts = Post.all.paginate(:page => params[:page], :per_page => 30)
  …
  @posts = @posts.where("price > ?", params["min_price"]) if params["min_price"].present?
  @posts = @posts.where("price < ?", params["max_price"]) if params["max_price"].present?
  @posts = @posts.where("sqft > ?", params["min_sqft"]) if params["min_sqft"].present?
  @posts = @posts.where("sqft < ?", params["max_sqft"]) if params["max_sqft"].present?
  …
end
…
Just so you know, you’ll notice that we’ll sometimes grab our URL parameters using double quotes for a string and sometimes we’ll use a colon for a symbol. These are interchangeable and do exactly the same thing.

Let’s save and take another look. Now we can filter for apartments that cost between $2,000 and $3,000.

Good job! Getting our filters working for text fields, checkboxes, and dropdown menus wasn’t easy. In fact, this still looks pretty bad, though it is functional. So next time, we’re going to use the Bootstrap grid system to organize this a bit and add some options to our inputs to make this look a little more professional.

Structure Filter Layout:
We now have working filters we can use to browse our database of Craigslist posts. This time, we’re going to clean this up by adding some layouts as well as placeholders and other options.

Let’s start by using the Bootstrap grid system to organize these into rows and columns. We want to put the headings in their own row above the input fields. That will give us four total rows: heading, input, heading, input.

We’ll go to our app/views/posts/index.html.erb file to set this up. First, let’s rearrange these fields a bit. We’ll move the price fields first as they’re the filters that are most likely to be used. So our first row will have price, bedrooms, bathrooms, and neighborhood. Our second row will have sqft, our four checkboxes, and our ‘Search’ button.

Let’s create a <div class="row"> and move the labels for our top fields here. We’ll close this <div> and create a new row for those input fields. Let’s do the same thing for our remaining fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <%= label_tag :min_price %>
        <%= label_tag :max_price %>
        <%= label_tag :bedrooms %>
        <%= label_tag :bathrooms %>
        <%= label_tag :neighborhood %>
      </div>

      <div class="row">
        <%= text_field_tag :min_price, params[:min_price] %>
        <%= text_field_tag :max_price, params[:max_price] %>
        <%= text_field_tag :bedrooms, params[:bedrooms] %>
        <%= text_field_tag :bathrooms, params[:bathrooms] %>
        <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
      </div>

      <div class="row">
        <%= label_tag :min_sqft %>
        <%= label_tag :max_sqft %>
        <%= label_tag :cats %>
        <%= label_tag :dogs %>
        <%= label_tag :w_d_in_unit %>
        <%= label_tag :street_parking %>
      </div>

      <div class="row">
        <%= text_field_tag :min_sqft, params[:min_sqft] %>
        <%= text_field_tag :max_sqft, params[:max_sqft] %>
        <%= check_box_tag :cats, "YES", params[:cats] %>
        <%= check_box_tag :dogs, "YES", params[:dogs] %>
        <%= check_box_tag :w_d_in_unit, "YES", params[:w_d_in_unit] %>
        <%= check_box_tag :street_parking, "YES", params[:street_parking] %>
       <%= submit_tag "Search", name: nil %>
      </div>

    <% end %>
  </div>

  …
Let’s save and take a look.

Not exactly how we expected. We need to set the number of columns each section gets. For example, of the 12 Bootstrap grids, we can allocate 4 grids to our price fields and 4 grids to our neighborhood field because it’s pretty long. Bedrooms and bathrooms will each get 2 grids.

So in our code, we’ll add a <div class="col-md-4"> around our price labels. In fact, we should probably combine these into a single label.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Price" %>
        </div>
        <%= label_tag :max_price %>
        <%= label_tag :bedrooms %>
        <%= label_tag :bathrooms %>
        <%= label_tag :neighborhood %>
      </div>
      
      …
Let’s do these other three as well.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>

      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Price" %>
        </div>
        <div class="col-md-2">
          <%= label_tag :bedrooms %>
        </div>
        <div class="col-md-2">
          <%= label_tag :bathrooms %>
        </div>
        <div class="col-md-4">
          <%= label_tag :neighborhood %>
        </div>
      </div>
      
      …
We’ll use these same grid spacings for the input fields below.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"] %>
          <%= text_field_tag :max_price, params["max_price"] %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"] %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"] %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
        </div>
      </div>
      
      …
Let’s now set the spacing for the headings and fields in the second section.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag :min_sqft %>
          <%= label_tag :max_sqft %>
        </div>
        <div class="col-md-1">
          <%= label_tag :cats %>
        </div>
        <div class="col-md-1">
          <%= label_tag :dogs %>
        </div>
        <div class="col-md-2">
          <%= label_tag :w_d_in_unit %>
        </div>
        <div class="col-md-2">
          <%= label_tag :street_parking %>
        </div>
      </div>
      
      …
Let’s also rename this label to say <%= label_tag "Washer/dryer in unit" %>.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
        …
        <div class="col-md-2">
          <%= label_tag "Washer/dryer in unit" %>
        </div>
        …
Now let’s set the same spacing for the input fields below.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"] %>
          <%= text_field_tag :max_sqft, params["max_sqft"] %>
        </div>
        <div class="col-md-1">
          <%= check_box_tag :cats, "YES", params["cats"] %>
        </div>
        <div class="col-md-1">
          <%= check_box_tag :dogs, "YES", params["dogs"] %>
        </div>
        <div class="col-md-2">
          <%= check_box_tag :w_d_in_unit, "YES", params["w_d_in_unit"] %>
        </div>
        <div class="col-md-2">
          <%= check_box_tag :street_parking, "YES", params["street_parking"] %>
        </div>
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil %>
        </div>
      </div>

    <% end %>
    …
Let’s save and refresh the page. That looks much better!

Let’s make a couple more changes. We’ll put our checkbox headings inline with the checkboxes themselves by going to our code and adding Bootstrap’s form-inline class to our form_tag.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
Then we’ll need to make sure that the labels and checkboxes fall within the same Bootstrap row, so let’s move the labels out of the third row and into the fourth.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag :min_sqft %>
          <%= label_tag :max_sqft %>
        </div>
      </div>
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"] %>
          <%= text_field_tag :max_sqft, params["max_sqft"] %>
        </div>
        <div class="col-md-1">
          <%= label_tag :cats %>
          <%= check_box_tag :cats, "YES", params["cats"] %>
        </div>
        <div class="col-md-1">
          <%= label_tag :dogs %>
          <%= check_box_tag :dogs, "YES", params["dogs"] %>
        </div>
        <div class="col-md-2">
          <%= label_tag "Washer/dryer in unit" %>
          <%= check_box_tag :w_d_in_unit, "YES", params["w_d_in_unit"] %>
        </div>
        <div class="col-md-2">
          <%= label_tag :street_parking %>
          <%= check_box_tag :street_parking, "YES", params["street_parking"] %>
        </div>
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil %>
        </div>
      </div>

    <% end %>
    …
While we’re here, let’s also add some placeholder text to our text fields.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"], placeholder: "minimum" %>
          <%= text_field_tag :max_price, params["max_price"], placeholder: "maximum" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"], placeholder: "# of beds" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"], placeholder: "# of baths" %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true }) %>
        </div>
      </div>

      …
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"], placeholder: "minimum" %>
          <%= text_field_tag :max_sqft, params["max_sqft"], placeholder: "maximum" %>
        </div>
        …
We’ll save and refresh the page again.

Okay, the next change we’ll make is to add some Bootstrap styling to each of these text fields as well as the ‘Search’ button. In our code, we’ll add a , class: "form-control input-sm" to the end. The form-control class is what gives it the Bootstrap look and the input-sm class sets the height of the field to be small. Let’s add this to each of our text fields. We’ll also add it to our dropdown menu after include_blank: true.

app/views/posts/index.html.erb
<div class="container">
  <div class="filter">
    <%= form_tag posts_path, method: :get, class: "form-inline" do %>
      …
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_price, params["min_price"], placeholder: "minimum", class: "form-control input-sm" %>
          <%= text_field_tag :max_price, params["max_price"], placeholder: "maximum", class: "form-control input-sm" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bedrooms, params["bedrooms"], placeholder: "# of beds", class: "form-control input-sm" %>
        </div>
        <div class="col-md-2">
          <%= text_field_tag :bathrooms, params["bathrooms"], placeholder: "# of baths", class: "form-control input-sm" %>
        </div>
        <div class="col-md-4">
          <%= select_tag(:neighborhood, options_from_collection_for_select(Location.all, :name, :name, params[:neighborhood]), { include_blank: true, class: "form-control input-sm" }) %>
        </div>
      </div>

      …
      
      <div class="row">
        <div class="col-md-4">
          <%= text_field_tag :min_sqft, params["min_sqft"], placeholder: "minimum", class: "form-control input-sm" %>
          <%= text_field_tag :max_sqft, params["max_sqft"], placeholder: "maximum", class: "form-control input-sm" %>
        </div>
        …
Finally, we’ll put a , class: "btn btn-primary" to style the ‘Search’ button.

app/views/posts/index.html.erb
        …
        <div class="col-md-2">
          <%= submit_tag "Search", name: nil, class: "btn btn-primary" %>
        </div>
        …
Let’s save and see our updated filters. Great – this looks way better than when we started.

But it looks like we forgot to combine our square footage label. Let’s go fix that now.

app/views/posts/index.html.erb
      …
      <div class="row">
        <div class="col-md-4">
          <%= label_tag "Square Footage" %>
        </div>
      </div>
      …
Let’s save and take a look. Great.

Now while this is looking pretty good, notice what happens when we try using some unrealistic search parameters. For example, let’s search for apartments with 25 bathrooms. As expected, our table comes up empty. But it would be much more user-friendly if we could display a message here instead.

So we’ll go to our code and below the filter section, we’ll add an ‘if statement’. We’ll write:

app/views/posts/index.html.erb
      …
    <% end %>
  </div>

  <% if @posts.empty? %>
    <hr>
    <h3>No results found</h3>
  <% else %>
    <table class="table table-hover table-condensed">
      …
    <%= link_to 'New Post', new_post_path %>
  <% end %>

Let’s save and refresh our search. It looks much better. In the next video, we’ll work on creating a homepage for our app and adding some CSS to put a little polish onto our site.

7.Add Front End Styling
Design Homepage
Add Thumbnail Images
Structure Show Page
Style Show Page

8.Deploy And Automate
Refresh Our Data
Deploy On Heroku
Automate Rake Tasks
Conclusion



